{
    "Canvas_api-1": {
        "buggy": "    /**\n     * Attempts to extract a useful Canvas error message from a response object.\n     * Sometimes Canvas API errors come back with a JSON body containing something like\n     * <pre>{\"errors\":[{\"message\":\"Human readable message here.\"}],\"error_report_id\":123456}</pre>.\n     * This method will attempt to extract the message. If parsing fails, it will return\n     * the raw JSON string without trying to parse it. Returns null if all attempts fail.\n     * @param response HttpResponse object representing the error response from Canvas\n     * @return The Canvas human-readable error string or null if unable to extract it\n     */\n    private String extractErrorMessageFromResponse(HttpResponse response) {\n        String contentType = response.getEntity().getContentType().getValue();\n        if(contentType.contains(\"application/json\")) {\n            Gson gson = GsonResponseParser.getDefaultGsonParser(false);\n            String responseBody = null;\n            try {\n                responseBody = EntityUtils.toString(response.getEntity());\n                LOG.error(\"Body of error response from Canvas: \" + responseBody);\n                CanvasErrorResponse errorResponse = gson.fromJson(responseBody, CanvasErrorResponse.class);\n                List<ErrorMessage> errors = errorResponse.getErrors();\n                if(errors != null) {\n                    //I have only ever seen a single error message but it is an array so presumably there could be more.\n                    return errors.stream().map(e -> e.getMessage()).collect(Collectors.joining(\", \"));\n                }\n            } catch (Exception e) {\n                //Returned JSON was not in expected format. Fall back to returning the whole response body, if any\n                if(StringUtils.isNotBlank(responseBody)) {\n                    return responseBody;\n                }\n            }\n        }\n        return null;\n    }\n",
        "start": 247,
        "end": 278,
        "fix": "    /**\n     * Attempts to extract a useful Canvas error message from a response object.\n     * Sometimes Canvas API errors come back with a JSON body containing something like\n     * <pre>{\"errors\":[{\"message\":\"Human readable message here.\"}],\"error_report_id\":123456}</pre>.\n     * This method will attempt to extract the message. If parsing fails, it will return\n     * the raw JSON string without trying to parse it. Returns null if all attempts fail.\n     * @param response HttpResponse object representing the error response from Canvas\n     * @return The Canvas human-readable error string or null if unable to extract it\n     */\n    private String extractErrorMessageFromResponse(HttpResponse response) {\n        String contentType = response.getEntity().getContentType().getValue();\n        if(contentType.contains(\"application/json\")) {\n            Gson gson = GsonResponseParser.getDefaultGsonParser(false);\n            String responseBody = null;\n            try {\n                responseBody = EntityUtils.toString(response.getEntity());\n                LOG.error(\"Body of error response from Canvas: \" + responseBody);\n                CanvasErrorResponse errorResponse = gson.fromJson(responseBody, CanvasErrorResponse.class);\n                List<ErrorMessage> errors = errorResponse.getErrors();\n                if(errors != null) {\n                    //I have only ever seen a single error message but it is an array so presumably there could be more.\n                    return errors.stream().map(e -> e.getMessage()).collect(Collectors.joining(\", \"));\n                }\n                else{\n                    return responseBody;\n                }\n            } catch (Exception e) {\n                //Returned JSON was not in expected format. Fall back to returning the whole response body, if any\n                if(StringUtils.isNotBlank(responseBody)) {\n                    return responseBody;\n                }\n            }\n        }\n        return null;\n    }\n"
    },
    "Canvas_api-2": {
        "buggy": "    public static Gson getDefaultGsonParser() {\n        GsonBuilder gsonBuilder = new GsonBuilder();\n        gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES);\n        //Custom type adapter for Date because: GSON throws a parse exception for blank dates instead of returning null.\n        //Also, it doesn't handle ISO 8601 dates with time zone info. Dates are hard.\n        gsonBuilder.registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {\n            @Override\n            public Date deserialize(final JsonElement json, final Type typeOfT, final JsonDeserializationContext context)\n                    throws JsonParseException {\n                if(json == null || StringUtils.isBlank(json.getAsString())) {\n                    return null;\n                }\n                try {\n                    ZonedDateTime zdt = ZonedDateTime.parse(json.getAsString());\n                    return Date.from(zdt.toInstant());\n                } catch(DateTimeParseException e) {\n                    LOG.error(\"error parsing date from Canvas: \" + json.getAsString());\n                    throw new JsonParseException(e);\n                }\n            }\n        });\n        return gsonBuilder.create();\n    }\n",
        "start": 54,
        "end": 76,
        "fix": "    public static Gson getDefaultGsonParser() {\n        GsonBuilder gsonBuilder = new GsonBuilder();\n        gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES);\n        //Custom type adapter for Date because: GSON throws a parse exception for blank dates instead of returning null.\n        //Also, it doesn't handle ISO 8601 dates with time zone info. Dates are hard.\n        gsonBuilder.registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {\n            @Override\n            public Date deserialize(final JsonElement json, final Type typeOfT, final JsonDeserializationContext context)\n                    throws JsonParseException {\n                if(json == null || StringUtils.isBlank(json.getAsString())) {\n                    return null;\n                }\n                try {\n                    ZonedDateTime zdt = ZonedDateTime.parse(json.getAsString());\n                    return Date.from(zdt.toInstant());\n                } catch(DateTimeParseException e) {\n                    LOG.error(\"error parsing date from Canvas: \" + json.getAsString());\n                    throw new JsonParseException(e);\n                }\n            }\n        }).registerTypeAdapter(Date.class, new JsonSerializer<Date>() {\n            @Override\n            public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {\n                if(src == null) {\n                    return null;\n                }\n                String dateString = ZonedDateTime.ofInstant(src.toInstant(), ZoneId.systemDefault())\n                        .format(DateTimeFormatter.ISO_INSTANT);\n                return new JsonPrimitive(dateString);\n            }\n        });\n        return gsonBuilder.create();\n    }\n"
    },
    "Dosgi_common-2": {
        "buggy": "    private void introspectTypeForExceptions(Class<?> iType) {\n        for (Method m : iType.getDeclaredMethods()) {\n            addExceptions(m);\n        }\n    }\n",
        "start": 53,
        "end": 57,
        "fix": "    private void introspectTypeForExceptions(Class<?> iType) {\n        for (Method m : iType.getDeclaredMethods()) {\n            addExceptions(m);\n        }\n        for (Method m : iType.getMethods()) {\n            addExceptions(m);\n        }\n    }\n"
    },
    "Hono_client-3": {
        "buggy": "    private R getRequestResponseResult(final Message message) {\n        final String status = MessageHelper.getApplicationProperty(\n                message.getApplicationProperties(),\n                MessageHelper.APP_PROPERTY_STATUS,\n                String.class);\n        final String payload = MessageHelper.getPayload(message);\n        return getResult(Integer.valueOf(status), payload);\n    }\n",
        "start": 234,
        "end": 241,
        "fix": "    private R getRequestResponseResult(final Message message) {\n        final Integer status = MessageHelper.getApplicationProperty(\n                message.getApplicationProperties(),\n                MessageHelper.APP_PROPERTY_STATUS,\n                Integer.class);\n        final String payload = MessageHelper.getPayload(message);\n        return getResult(status, payload);\n    }\n"
    },
    "Hono_client-4": {
        "buggy": "    /**\n     * Creates a command for an AMQP 1.0 message that should be sent to a device.\n     * <p>\n     * The message is expected to contain\n     * <ul>\n     * <li>a non-null <em>subject</em></li>\n     * <li>either a null <em>reply-to</em> address (for a one-way command)\n     * or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists\n     * of four segments</li>\n     * <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li>\n     * </ul>\n     * <p>\n     * If any of the requirements above are not met, then the returned command's {@link Command#isValid()}\n     * method will return {@code false}.\n     * <p>\n     * Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains\n     * the device id.\n     *\n     * @param message The message containing the command.\n     * @param tenantId The tenant that the device belongs to.\n     * @param deviceId The identifier of the device.\n     * @return The command.\n     * @throws NullPointerException if any of the parameters are {@code null}.\n     */\n    public static Command from(\n            final Message message,\n            final String tenantId,\n            final String deviceId) {\n\n        Objects.requireNonNull(message);\n        Objects.requireNonNull(tenantId);\n        Objects.requireNonNull(deviceId);\n\n        final StringJoiner validationErrorJoiner = new StringJoiner(\", \");\n        if (message.getSubject() == null) {\n            validationErrorJoiner.add(\"subject not set\");\n        }\n\n        final String correlationId = Optional.ofNullable(message.getCorrelationId()).map(obj -> {\n            if (obj instanceof String) {\n                return (String) obj;\n            } else {\n                return null;\n            }\n        }).orElseGet(() -> {\n            final Object obj = message.getMessageId();\n            if (obj instanceof String) {\n                return (String) obj;\n            } else {\n                return null;\n            }\n        });\n\n        if (correlationId == null) {\n            validationErrorJoiner.add(\"message/correlation-id not set\");\n        }\n\n        String originalReplyToId = null;\n        boolean replyToLegacyEndpointUsed = false;\n        if (message.getReplyTo() != null) {\n            try {\n                final ResourceIdentifier replyTo = ResourceIdentifier.fromString(message.getReplyTo());\n                if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {\n                    // not a command message\n                    validationErrorJoiner.add(\"reply-to not a command address: \" + message.getReplyTo());\n                } else if (!tenantId.equals(replyTo.getTenantId())) {\n                    // command response is targeted at wrong tenant\n                    validationErrorJoiner.add(\"reply-to not targeted at tenant \" + tenantId + \": \" + message.getReplyTo());\n                } else {\n                    replyToLegacyEndpointUsed = CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());\n                    originalReplyToId = replyTo.getPathWithoutBase();\n                    if (originalReplyToId == null) {\n                        validationErrorJoiner.add(\"reply-to part after tenant not set: \" + message.getReplyTo());\n                    } else {\n                        message.setReplyTo(\n                                String.format(\"%s/%s/%s\", CommandConstants.COMMAND_ENDPOINT, tenantId,\n                                        getDeviceFacingReplyToId(originalReplyToId, deviceId, replyToLegacyEndpointUsed)));\n                    }\n                }\n            } catch (IllegalArgumentException e) {\n                // reply-to could not be parsed\n                validationErrorJoiner.add(\"reply-to cannot be parsed: \" + message.getReplyTo());\n            }\n        }\n\n        final Command result = new Command(\n                validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),\n                message,\n                tenantId,\n                deviceId,\n                correlationId,\n                originalReplyToId,\n                replyToLegacyEndpointUsed);\n\n        return result;\n    }\n",
        "start": 76,
        "end": 171,
        "fix": "    /**\n     * Creates a command for an AMQP 1.0 message that should be sent to a device.\n     * <p>\n     * The message is expected to contain\n     * <ul>\n     * <li>a non-null <em>subject</em></li>\n     * <li>either a null <em>reply-to</em> address (for a one-way command)\n     * or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists\n     * of four segments</li>\n     * <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li>\n     * </ul>\n     * <p>\n     * If any of the requirements above are not met, then the returned command's {@link Command#isValid()}\n     * method will return {@code false}.\n     * <p>\n     * Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains\n     * the device id.\n     *\n     * @param message The message containing the command.\n     * @param tenantId The tenant that the device belongs to.\n     * @param deviceId The identifier of the device.\n     * @return The command.\n     * @throws NullPointerException if any of the parameters are {@code null}.\n     */\n    public static Command from(\n            final Message message,\n            final String tenantId,\n            final String deviceId) {\n\n        Objects.requireNonNull(message);\n        Objects.requireNonNull(tenantId);\n        Objects.requireNonNull(deviceId);\n\n        final StringJoiner validationErrorJoiner = new StringJoiner(\", \");\n        if (message.getSubject() == null) {\n            validationErrorJoiner.add(\"subject not set\");\n        }\n\n        final String correlationId = Optional.ofNullable(message.getCorrelationId()).map(obj -> {\n            if (obj instanceof String) {\n                return (String) obj;\n            } else {\n                return null;\n            }\n        }).orElseGet(() -> {\n            final Object obj = message.getMessageId();\n            if (obj instanceof String) {\n                return (String) obj;\n            } else {\n                return null;\n            }\n        });\n\n        if (correlationId == null) {\n            validationErrorJoiner.add(\"message/correlation-id not set\");\n        }\n\n        String originalReplyToId = null;\n        boolean replyToLegacyEndpointUsed = false;\n        if (message.getReplyTo() != null) {\n            try {\n                final ResourceIdentifier replyTo = ResourceIdentifier.fromString(message.getReplyTo());\n                if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {\n                    // not a command message\n                    validationErrorJoiner.add(\"reply-to not a command address: \" + message.getReplyTo());\n                } else if (!tenantId.equals(replyTo.getTenantId())) {\n                    // command response is targeted at wrong tenant\n                    validationErrorJoiner.add(\"reply-to not targeted at tenant \" + tenantId + \": \" + message.getReplyTo());\n                } else {\n                    replyToLegacyEndpointUsed = CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());\n                    originalReplyToId = replyTo.getPathWithoutBase();\n                    if (originalReplyToId == null) {\n                        validationErrorJoiner.add(\"reply-to part after tenant not set: \" + message.getReplyTo());\n                    } else {\n                        message.setReplyTo(\n                                String.format(\"%s/%s/%s\", CommandConstants.COMMAND_RESPONSE_ENDPOINT, tenantId,\n                                        getDeviceFacingReplyToId(originalReplyToId, deviceId, replyToLegacyEndpointUsed)));\n                    }\n                }\n            } catch (IllegalArgumentException e) {\n                // reply-to could not be parsed\n                validationErrorJoiner.add(\"reply-to cannot be parsed: \" + message.getReplyTo());\n            }\n        }\n\n        final Command result = new Command(\n                validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),\n                message,\n                tenantId,\n                deviceId,\n                correlationId,\n                originalReplyToId,\n                replyToLegacyEndpointUsed);\n\n        return result;\n    }\n"
    },
    "Tika_app-1": {
        "buggy": "        public void outputMetadata(String[] names) {\n           for (String name : names) {\n              writer.println(name + \": \" + metadata.get(name));\n           }\n        }\n",
        "start": 825,
        "end": 829,
        "fix": "        public void outputMetadata(String[] names) {\n           for (String name : names) {\n              for(String value : metadata.getValues(name)) {\n                 writer.println(name + \": \" + value);\n              }\n           }\n        }\n"
    },
    "HttpClient5-1": {
        "buggy": "    static List<SubjectName> getSubjectAltNames(final X509Certificate cert) {\n        try {\n            final Collection<List<?>> entries = cert.getSubjectAlternativeNames();\n            if (entries == null) {\n                return Collections.emptyList();\n            }\n            final List<SubjectName> result = new ArrayList<>();\n            for (final List<?> entry : entries) {\n                final Integer type = entry.size() >= 2 ? (Integer) entry.get(0) : null;\n                if (type != null) {\n                        final Object o = entry.get(1);\n                        if (o instanceof String) {\n                            result.add(new SubjectName((String) o, type));\n                        } else if (o instanceof byte[]) {\n                            // TODO ASN.1 DER encoded form\n                    }\n                }\n            }\n            return result;\n        } catch (final CertificateParsingException ignore) {\n            return Collections.emptyList();\n        }\n    }\n",
        "start": 279,
        "end": 301,
        "fix": "    static List<SubjectName> getSubjectAltNames(final X509Certificate cert) {\n        try {\n            final Collection<List<?>> entries = cert.getSubjectAlternativeNames();\n            if (entries == null) {\n                return Collections.emptyList();\n            }\n            final List<SubjectName> result = new ArrayList<>();\n            for (final List<?> entry : entries) {\n                final Integer type = entry.size() >= 2 ? (Integer) entry.get(0) : null;\n                if (type != null) {\n                    if (type == SubjectName.DNS || type == SubjectName.IP) {\n                        final Object o = entry.get(1);\n                        if (o instanceof String) {\n                            result.add(new SubjectName((String) o, type));\n                        } else if (o instanceof byte[]) {\n                            // TODO ASN.1 DER encoded form\n                        }\n                    }\n                }\n            }\n            return result;\n        } catch (final CertificateParsingException ignore) {\n            return Collections.emptyList();\n        }\n    }\n"
    },
    "HttpClient5-6": {
        "buggy": "    @Override\n    public void processChallenge(\n            final AuthChallenge authChallenge,\n            final HttpContext context) throws MalformedChallengeException {\n        Args.notNull(authChallenge, \"AuthChallenge\");\n\n        if (authChallenge.getValue() == null) {\n            throw new MalformedChallengeException(\"Missing auth challenge\");\n        }\n        this.challenge = authChallenge.getValue();\n        if (this.challenge == null || this.challenge.isEmpty()) {\n            if (this.state == State.UNINITIATED) {\n                this.state = State.CHALLENGE_RECEIVED;\n            } else {\n                this.state = State.FAILED;\n            }\n        } else {\n            if (this.state.compareTo(State.MSG_TYPE1_GENERATED) < 0) {\n                this.state = State.FAILED;\n                throw new MalformedChallengeException(\"Out of sequence NTLM response message\");\n            } else if (this.state == State.MSG_TYPE1_GENERATED) {\n                this.state = State.MSG_TYPE2_RECEVIED;\n            }\n        }\n    }\n",
        "start": 97,
        "end": 121,
        "fix": "    @Override\n    public void processChallenge(\n            final AuthChallenge authChallenge,\n            final HttpContext context) throws MalformedChallengeException {\n        Args.notNull(authChallenge, \"AuthChallenge\");\n\n        this.challenge = authChallenge.getValue();\n        if (this.challenge == null || this.challenge.isEmpty()) {\n            if (this.state == State.UNINITIATED) {\n                this.state = State.CHALLENGE_RECEIVED;\n            } else {\n                this.state = State.FAILED;\n            }\n        } else {\n            if (this.state.compareTo(State.MSG_TYPE1_GENERATED) < 0) {\n                this.state = State.FAILED;\n                throw new MalformedChallengeException(\"Out of sequence NTLM response message\");\n            } else if (this.state == State.MSG_TYPE1_GENERATED) {\n                this.state = State.MSG_TYPE2_RECEVIED;\n            }\n        }\n    }\n"
    },
    "HttpClient5-7": {
        "buggy": "    MultipartFormEntity buildEntity() {\n        String boundaryCopy = boundary;\n        if (boundaryCopy == null && contentType != null) {\n            boundaryCopy = contentType.getParameter(\"boundary\");\n        }\n        if (boundaryCopy == null) {\n            boundaryCopy = generateBoundary();\n        }\n        Charset charsetCopy = charset;\n        if (charsetCopy == null && contentType != null) {\n            charsetCopy = contentType.getCharset();\n        }\n        final List<NameValuePair> paramsList = new ArrayList<>(2);\n        paramsList.add(new BasicNameValuePair(\"boundary\", boundaryCopy));\n        if (charsetCopy != null) {\n            paramsList.add(new BasicNameValuePair(\"charset\", charsetCopy.name()));\n        }\n        final NameValuePair[] params = paramsList.toArray(new NameValuePair[paramsList.size()]);\n\n        final ContentType contentTypeCopy;\n        if (contentType != null) {\n            contentTypeCopy = contentType.withParameters(params);\n        } else {\n            boolean formData = false;\n            if (multipartParts != null) {\n                for (final MultipartPart multipartPart : multipartParts) {\n                    if (multipartPart instanceof FormBodyPart) {\n                        formData = true;\n                        break;\n                    }\n                }\n            }\n\n            if (formData) {\n                contentTypeCopy = ContentType.MULTIPART_FORM_DATA.withParameters(params);\n            } else {\n                contentTypeCopy = ContentType.create(\"multipart/mixed\", params);\n            }\n        }\n        final List<MultipartPart> multipartPartsCopy = multipartParts != null ? new ArrayList<>(multipartParts) :\n                Collections.<MultipartPart>emptyList();\n        final HttpMultipartMode modeCopy = mode != null ? mode : HttpMultipartMode.STRICT;\n        final AbstractMultipartFormat form;\n        switch (modeCopy) {\n            case LEGACY:\n                form = new LegacyMultipart(charsetCopy, boundaryCopy, multipartPartsCopy);\n                break;\n            case EXTENDED:\n                if (ContentType.MULTIPART_FORM_DATA.isSameMimeType(ContentType.MULTIPART_FORM_DATA)) {\n                    if (charsetCopy == null) {\n                        charsetCopy = StandardCharsets.UTF_8;\n                    }\n                    form = new HttpRFC7578Multipart(charsetCopy, boundaryCopy, multipartPartsCopy);\n                } else {\n                    form = new HttpRFC6532Multipart(charsetCopy, boundaryCopy, multipartPartsCopy);\n                }\n                break;\n            default:\n                form = new HttpStrictMultipart(StandardCharsets.US_ASCII, boundaryCopy, multipartPartsCopy);\n        }\n        return new MultipartFormEntity(form, contentTypeCopy, form.getTotalLength());\n    }\n",
        "start": 187,
        "end": 248,
        "fix": "    MultipartFormEntity buildEntity() {\n        String boundaryCopy = boundary;\n        if (boundaryCopy == null && contentType != null) {\n            boundaryCopy = contentType.getParameter(\"boundary\");\n        }\n        if (boundaryCopy == null) {\n            boundaryCopy = generateBoundary();\n        }\n        Charset charsetCopy = charset;\n        if (charsetCopy == null && contentType != null) {\n            charsetCopy = contentType.getCharset();\n        }\n        final List<NameValuePair> paramsList = new ArrayList<>(2);\n        paramsList.add(new BasicNameValuePair(\"boundary\", boundaryCopy));\n        if (charsetCopy != null) {\n            paramsList.add(new BasicNameValuePair(\"charset\", charsetCopy.name()));\n        }\n        final NameValuePair[] params = paramsList.toArray(new NameValuePair[paramsList.size()]);\n\n        final ContentType contentTypeCopy;\n        if (contentType != null) {\n            contentTypeCopy = contentType.withParameters(params);\n        } else {\n            boolean formData = false;\n            if (multipartParts != null) {\n                for (final MultipartPart multipartPart : multipartParts) {\n                    if (multipartPart instanceof FormBodyPart) {\n                        formData = true;\n                        break;\n                    }\n                }\n            }\n\n            if (formData) {\n                contentTypeCopy = ContentType.MULTIPART_FORM_DATA.withParameters(params);\n            } else {\n                contentTypeCopy = ContentType.create(\"multipart/mixed\", params);\n            }\n        }\n        final List<MultipartPart> multipartPartsCopy = multipartParts != null ? new ArrayList<>(multipartParts) :\n                Collections.<MultipartPart>emptyList();\n        final HttpMultipartMode modeCopy = mode != null ? mode : HttpMultipartMode.STRICT;\n        final AbstractMultipartFormat form;\n        switch (modeCopy) {\n            case LEGACY:\n                form = new LegacyMultipart(charsetCopy, boundaryCopy, multipartPartsCopy);\n                break;\n            case EXTENDED:\n                if (contentTypeCopy.isSameMimeType(ContentType.MULTIPART_FORM_DATA)) {\n                    if (charsetCopy == null) {\n                        charsetCopy = StandardCharsets.UTF_8;\n                    }\n                    form = new HttpRFC7578Multipart(charsetCopy, boundaryCopy, multipartPartsCopy);\n                } else {\n                    form = new HttpRFC6532Multipart(charsetCopy, boundaryCopy, multipartPartsCopy);\n                }\n                break;\n            default:\n                form = new HttpStrictMultipart(StandardCharsets.US_ASCII, boundaryCopy, multipartPartsCopy);\n        }\n        return new MultipartFormEntity(form, contentTypeCopy, form.getTotalLength());\n    }\n"
    },
    "JacksonDatatypeJsr310-1": {
        "buggy": "    @Override\n    public LocalDate deserialize(JsonParser parser, DeserializationContext context) throws IOException\n    {\n        switch(parser.getCurrentTokenId())\n        {\n            case JsonTokenId.ID_START_ARRAY:\n                if(parser.nextToken() == JsonToken.END_ARRAY) {\n                    return null;\n                }\n                int year = parser.getIntValue();\n\n                parser.nextToken();\n                int month = parser.getIntValue();\n\n                parser.nextToken();\n                int day = parser.getIntValue();\n\n                if (parser.nextToken() != JsonToken.END_ARRAY) {\n                    throw context.wrongTokenException(parser, JsonToken.END_ARRAY, \"Expected array to end.\");\n                }\n                return LocalDate.of(year, month, day);\n\n            case JsonTokenId.ID_STRING:\n                String string = parser.getText().trim();\n                if(string.length() == 0) {\n                    return null;\n                }\n\n                \n                return LocalDate.parse(string, _formatter);\n        }\n\n        throw context.wrongTokenException(parser, JsonToken.START_ARRAY, \"Expected array or string.\");\n    }\n",
        "start": 54,
        "end": 87,
        "fix": "    @Override\n    public LocalDate deserialize(JsonParser parser, DeserializationContext context) throws IOException\n    {\n        switch(parser.getCurrentTokenId())\n        {\n            case JsonTokenId.ID_START_ARRAY:\n                if(parser.nextToken() == JsonToken.END_ARRAY) {\n                    return null;\n                }\n                int year = parser.getIntValue();\n\n                parser.nextToken();\n                int month = parser.getIntValue();\n\n                parser.nextToken();\n                int day = parser.getIntValue();\n\n                if (parser.nextToken() != JsonToken.END_ARRAY) {\n                    throw context.wrongTokenException(parser, JsonToken.END_ARRAY, \"Expected array to end.\");\n                }\n                return LocalDate.of(year, month, day);\n\n            case JsonTokenId.ID_STRING:\n                String string = parser.getText().trim();\n                if(string.length() == 0) {\n                    return null;\n                }\n\n                if(string.contains(\"T\")) {\n                    return LocalDate.parse(string, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n                }\n                \n                return LocalDate.parse(string, _formatter);\n        }\n\n        throw context.wrongTokenException(parser, JsonToken.START_ARRAY, \"Expected array or string.\");\n    }\n"
    },
    "JacksonModuleAfterburner-2": {
        "buggy": "    protected PropertyAccessorCollector findProperties(Class<?> beanClass,\n            SerializationConfig config, List<BeanPropertyWriter> beanProperties)\n    {\n        PropertyAccessorCollector collector = new PropertyAccessorCollector(beanClass);\n        ListIterator<BeanPropertyWriter> it = beanProperties.listIterator();\n        while (it.hasNext()) {\n            BeanPropertyWriter bpw = it.next();\n            Class<?> type = bpw.getPropertyType();\n            AnnotatedMember member = bpw.getMember();\n\n            // First: we can't access private fields or methods....\n            if (Modifier.isPrivate(member.getMember().getModifiers())) {\n                continue;\n            }\n            // (although, interestingly enough, can seem to access private classes...)\n            \n            // 30-Jul-2012, tatu: [Issue-6]: Needs to skip custom serializers, if any.\n            if (bpw.hasSerializer()) {\n                if (!isDefaultSerializer(config, bpw.getSerializer())) {\n                    continue;\n                }\n            }\n            // [#9]: also skip unwrapping stuff...\n            if (bpw.isUnwrapping()) {\n                continue;\n            }\n            // [#51]: and any sub-classes as well\n            /* 04-Mar-2015, tatu: This might be too restrictive, as core databind has some \n             *   other sub-classes; if this becomes problematic may start using annotation\n             *   to indicate \"standard\" implementations. But for now this solves the issue.\n             */\n            \n            boolean isMethod = (member instanceof AnnotatedMethod);\n            if (type.isPrimitive()) {\n                if (type == Integer.TYPE) {\n\n                    if (isMethod) {\n                        it.set(collector.addIntGetter(bpw));\n                    } else {\n                        it.set(collector.addIntField(bpw));\n                    }\n                } else if (type == Long.TYPE) {\n                    if (isMethod) {\n                        it.set(collector.addLongGetter(bpw));\n                    } else {\n                        it.set(collector.addLongField(bpw));\n                    }\n                } else if (type == Boolean.TYPE) {\n                    if (isMethod) {\n                        it.set(collector.addBooleanGetter(bpw));\n                    } else {\n                        it.set(collector.addBooleanField(bpw));\n                    }\n                }\n            } else {\n                if (type == String.class) {\n                    if (isMethod) {\n                        it.set(collector.addStringGetter(bpw));\n                    } else {\n                        it.set(collector.addStringField(bpw));\n                    }\n                } else { // any other Object types; we can at least call accessor\n                    if (isMethod) {\n                        it.set(collector.addObjectGetter(bpw));\n                    } else {\n                        it.set(collector.addObjectField(bpw));\n                    }\n                }\n            }\n        }\n        return collector;\n    }\n",
        "start": 67,
        "end": 138,
        "fix": "    protected PropertyAccessorCollector findProperties(Class<?> beanClass,\n            SerializationConfig config, List<BeanPropertyWriter> beanProperties)\n    {\n        PropertyAccessorCollector collector = new PropertyAccessorCollector(beanClass);\n        ListIterator<BeanPropertyWriter> it = beanProperties.listIterator();\n        while (it.hasNext()) {\n            BeanPropertyWriter bpw = it.next();\n            Class<?> type = bpw.getPropertyType();\n            AnnotatedMember member = bpw.getMember();\n\n            // First: we can't access private fields or methods....\n            if (Modifier.isPrivate(member.getMember().getModifiers())) {\n                continue;\n            }\n            // (although, interestingly enough, can seem to access private classes...)\n            \n            // 30-Jul-2012, tatu: [Issue-6]: Needs to skip custom serializers, if any.\n            if (bpw.hasSerializer()) {\n                if (!isDefaultSerializer(config, bpw.getSerializer())) {\n                    continue;\n                }\n            }\n            // [#9]: also skip unwrapping stuff...\n            if (bpw.isUnwrapping()) {\n                continue;\n            }\n            // [#51]: and any sub-classes as well\n            /* 04-Mar-2015, tatu: This might be too restrictive, as core databind has some \n             *   other sub-classes; if this becomes problematic may start using annotation\n             *   to indicate \"standard\" implementations. But for now this solves the issue.\n             */\n            if (bpw.getClass() != BeanPropertyWriter.class) {\n                continue;\n            }\n            \n            boolean isMethod = (member instanceof AnnotatedMethod);\n            if (type.isPrimitive()) {\n                if (type == Integer.TYPE) {\n\n                    if (isMethod) {\n                        it.set(collector.addIntGetter(bpw));\n                    } else {\n                        it.set(collector.addIntField(bpw));\n                    }\n                } else if (type == Long.TYPE) {\n                    if (isMethod) {\n                        it.set(collector.addLongGetter(bpw));\n                    } else {\n                        it.set(collector.addLongField(bpw));\n                    }\n                } else if (type == Boolean.TYPE) {\n                    if (isMethod) {\n                        it.set(collector.addBooleanGetter(bpw));\n                    } else {\n                        it.set(collector.addBooleanField(bpw));\n                    }\n                }\n            } else {\n                if (type == String.class) {\n                    if (isMethod) {\n                        it.set(collector.addStringGetter(bpw));\n                    } else {\n                        it.set(collector.addStringField(bpw));\n                    }\n                } else { // any other Object types; we can at least call accessor\n                    if (isMethod) {\n                        it.set(collector.addObjectGetter(bpw));\n                    } else {\n                        it.set(collector.addObjectField(bpw));\n                    }\n                }\n            }\n        }\n        return collector;\n    }\n"
    },
    "Switchyard_admin-1": {
        "buggy": "    private void addComponents() {\n        _componentServices = new LinkedHashMap<QName, ComponentService>();\n        if (_config.getComposite().getComponents() == null) {\n            return;\n        }\n        for (ComponentModel component : _config.getComposite().getComponents()) {\n            // TODO: we need a separate node for components, to support cases\n            // where the component implements no services.  Should also consider\n            // multiple services per component.\n                ComponentServiceModel service = component.getServices().get(0);\n                _componentServices.put(service.getQName(), new BaseComponentService(service, component, this));\n        }\n    }\n",
        "start": 154,
        "end": 166,
        "fix": "    private void addComponents() {\n        _componentServices = new LinkedHashMap<QName, ComponentService>();\n        if (_config.getComposite().getComponents() == null) {\n            return;\n        }\n        for (ComponentModel component : _config.getComposite().getComponents()) {\n            // TODO: we need a separate node for components, to support cases\n            // where the component implements no services.  Should also consider\n            // multiple services per component.\n            if (component.getServices().size() > 0) {\n                ComponentServiceModel service = component.getServices().get(0);\n                _componentServices.put(service.getQName(), new BaseComponentService(service, component, this));\n            }\n        }\n    }\n"
    },
    "Switchyard_validate-1": {
        "buggy": "    private static Validator newValidator(final Object validatorObject, final Method publicMethod, QName name) {\n        Validator validator = new BaseValidator(name) {\n            @Override\n            public boolean validate(Object subject) {\n                try {\n                    return Boolean.parseBoolean(publicMethod.invoke(validatorObject, subject).toString());\n                } catch (InvocationTargetException e) {\n                    throw new SwitchYardException(\"Error executing @Validator method '\" + publicMethod.getName() + \"' on class '\" + publicMethod.getDeclaringClass().getName() + \"'.\", e.getCause());\n                } catch (Exception e) {\n                    throw new SwitchYardException(\"Error executing @Validator method '\" + publicMethod.getName() + \"' on class '\" + publicMethod.getDeclaringClass().getName() + \"'.\", e);\n                }\n            }\n            \n            @Override\n            public Class<?> getType() {\n                return publicMethod.getReturnType();\n            }\n        };\n\n        return validator;\n    }\n",
        "start": 238,
        "end": 258,
        "fix": "    private static Validator newValidator(final Object validatorObject, final Method publicMethod, QName name) {\n        Validator validator = new BaseValidator(name) {\n            @Override\n            public boolean validate(Object subject) {\n                try {\n                    return Boolean.parseBoolean(publicMethod.invoke(validatorObject, subject).toString());\n                } catch (InvocationTargetException e) {\n                    throw new SwitchYardException(\"Error executing @Validator method '\" + publicMethod.getName() + \"' on class '\" + publicMethod.getDeclaringClass().getName() + \"'.\", e.getCause());\n                } catch (Exception e) {\n                    throw new SwitchYardException(\"Error executing @Validator method '\" + publicMethod.getName() + \"' on class '\" + publicMethod.getDeclaringClass().getName() + \"'.\", e);\n                }\n            }\n            \n            @Override\n            public Class<?> getType() {\n                return publicMethod.getParameterTypes()[0];\n            }\n        };\n\n        return validator;\n    }\n"
    },
    "Qpidjms_client-3": {
        "buggy": "    public ConnectionSettings buildConnectionSettings()\n    {\n        ConnectionSettings conSettings = new ConnectionSettings();\n\n        conSettings.setHost(getHost());\n        conSettings.setPort(getPort());\n        conSettings.setTransport(getTransport());\n\n        // ------------ sasl options ---------------\n        if (getProperty(BrokerDetails.OPTIONS_SASL_MECHS) != null)\n        {\n            conSettings.setSaslMechs(\n                    getProperty(BrokerDetails.OPTIONS_SASL_MECHS));\n        }\n\n        // Sun SASL Kerberos client uses the\n        // protocol + servername as the service key.\n\n        if (getProperty(BrokerDetails.OPTIONS_SASL_PROTOCOL_NAME) != null)\n        {\n            conSettings.setSaslProtocol(\n                    getProperty(BrokerDetails.OPTIONS_SASL_PROTOCOL_NAME));\n        }\n\n\n        if (getProperty(BrokerDetails.OPTIONS_SASL_SERVER_NAME) != null)\n        {\n            conSettings.setSaslServerName(\n                    getProperty(BrokerDetails.OPTIONS_SASL_SERVER_NAME));\n        }\n\n        conSettings.setUseSASLEncryption(\n                getBooleanProperty(BrokerDetails.OPTIONS_SASL_ENCRYPTION));\n\n        // ------------- ssl options ---------------------\n        conSettings.setUseSSL(getBooleanProperty(BrokerDetails.OPTIONS_SSL));\n\n        if (getProperty(BrokerDetails.OPTIONS_TRUST_STORE) != null)\n        {\n            conSettings.setTrustStorePath(\n                    getProperty(BrokerDetails.OPTIONS_TRUST_STORE));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_TRUST_STORE_PASSWORD) != null)\n        {\n            conSettings.setTrustStorePassword(\n                    getProperty(BrokerDetails.OPTIONS_TRUST_STORE_PASSWORD));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_KEY_STORE) != null)\n        {\n            conSettings.setKeyStorePath(\n                    getProperty(BrokerDetails.OPTIONS_KEY_STORE));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_KEY_STORE_PASSWORD) != null)\n        {\n            conSettings.setKeyStorePassword(\n                    getProperty(BrokerDetails.OPTIONS_KEY_STORE_PASSWORD));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_SSL_CERT_ALIAS) != null)\n        {\n            conSettings.setCertAlias(\n                    getProperty(BrokerDetails.OPTIONS_SSL_CERT_ALIAS));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_PRIV_KEY_PATH) != null)\n        {\n            conSettings.setClientCertificatePrivateKeyPath(\n                    getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_PRIV_KEY_PATH));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_PATH) != null)\n        {\n            conSettings.setClientCertificatePath(\n                    getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_PATH));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_INTERMEDIARY_CERT_PATH) != null)\n        {\n            conSettings.setClientCertificateIntermediateCertsPath(\n                    getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_INTERMEDIARY_CERT_PATH));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_TRUSTED_CERTIFICATES_PATH) != null)\n        {\n            conSettings.setTrustedCertificatesFile(\n                    getProperty(BrokerDetails.OPTIONS_TRUSTED_CERTIFICATES_PATH));\n        }\n        // ----------------------------\n\n        boolean defaultSSLVerifyHostName = Boolean.parseBoolean(\n                System.getProperty(ClientProperties.CONNECTION_OPTION_SSL_VERIFY_HOST_NAME,\n                    String.valueOf(ClientProperties.DEFAULT_CONNECTION_OPTION_SSL_VERIFY_HOST_NAME)));\n        conSettings.setVerifyHostname(getBooleanProperty(BrokerDetails.OPTIONS_SSL_VERIFY_HOSTNAME, defaultSSLVerifyHostName ));\n\n        // ----------------------------\n\n        if (getProperty(BrokerDetails.OPTIONS_ENCRYPTION_KEY_STORE) != null)\n        {\n            conSettings.setEncryptionKeyStorePath(\n                    getProperty(BrokerDetails.OPTIONS_ENCRYPTION_KEY_STORE));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_ENCRYPTION_KEY_STORE_PASSWORD) != null)\n        {\n            conSettings.setEncryptionKeyStorePassword(\n                    getProperty(BrokerDetails.OPTIONS_ENCRYPTION_KEY_STORE_PASSWORD));\n        }\n\n\n        if (getProperty(BrokerDetails.OPTIONS_ENCRYPTION_TRUST_STORE) != null)\n        {\n            conSettings.setEncryptionTrustStorePath(\n                    getProperty(BrokerDetails.OPTIONS_ENCRYPTION_TRUST_STORE));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_ENCRYPTION_TRUST_STORE_PASSWORD) != null)\n        {\n            conSettings.setEncryptionKeyStorePassword(\n                    getProperty(BrokerDetails.OPTIONS_ENCRYPTION_TRUST_STORE_PASSWORD));\n        }\n\n\n        if (getProperty(BrokerDetails.OPTIONS_ENCRYPTION_REMOTE_TRUST_STORE) != null)\n        {\n            conSettings.setEncryptionRemoteTrustStoreName(\n                    getProperty(BrokerDetails.OPTIONS_ENCRYPTION_REMOTE_TRUST_STORE));\n        }\n\n        // ----------------------------\n\n        if (getProperty(BrokerDetails.OPTIONS_TCP_NO_DELAY) != null)\n        {\n            conSettings.setTcpNodelay(\n                    getBooleanProperty(BrokerDetails.OPTIONS_TCP_NO_DELAY,true));\n        }\n\n        conSettings.setConnectTimeout(lookupConnectTimeout());\n\n        if (getProperty(BrokerDetails.OPTIONS_HEARTBEAT) != null)\n        {\n            conSettings.setHeartbeatInterval(getIntegerProperty(BrokerDetails.OPTIONS_HEARTBEAT));\n        }\n        else if (getProperty(BrokerDetails.OPTIONS_IDLE_TIMEOUT) != null)\n        {\n            conSettings.setHeartbeatInterval(getIntegerProperty(BrokerDetails.OPTIONS_IDLE_TIMEOUT) / 1000);\n        }\n\n        return conSettings;\n    }\n",
        "start": 442,
        "end": 593,
        "fix": "    public ConnectionSettings buildConnectionSettings()\n    {\n        ConnectionSettings conSettings = new ConnectionSettings();\n\n        conSettings.setHost(getHost());\n        conSettings.setPort(getPort());\n        conSettings.setTransport(getTransport());\n\n        // ------------ sasl options ---------------\n        if (getProperty(BrokerDetails.OPTIONS_SASL_MECHS) != null)\n        {\n            conSettings.setSaslMechs(\n                    getProperty(BrokerDetails.OPTIONS_SASL_MECHS));\n        }\n\n        // Sun SASL Kerberos client uses the\n        // protocol + servername as the service key.\n\n        if (getProperty(BrokerDetails.OPTIONS_SASL_PROTOCOL_NAME) != null)\n        {\n            conSettings.setSaslProtocol(\n                    getProperty(BrokerDetails.OPTIONS_SASL_PROTOCOL_NAME));\n        }\n\n\n        if (getProperty(BrokerDetails.OPTIONS_SASL_SERVER_NAME) != null)\n        {\n            conSettings.setSaslServerName(\n                    getProperty(BrokerDetails.OPTIONS_SASL_SERVER_NAME));\n        }\n\n        conSettings.setUseSASLEncryption(\n                getBooleanProperty(BrokerDetails.OPTIONS_SASL_ENCRYPTION));\n\n        // ------------- ssl options ---------------------\n        conSettings.setUseSSL(getBooleanProperty(BrokerDetails.OPTIONS_SSL));\n\n        if (getProperty(BrokerDetails.OPTIONS_TRUST_STORE) != null)\n        {\n            conSettings.setTrustStorePath(\n                    getProperty(BrokerDetails.OPTIONS_TRUST_STORE));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_TRUST_STORE_PASSWORD) != null)\n        {\n            conSettings.setTrustStorePassword(\n                    getProperty(BrokerDetails.OPTIONS_TRUST_STORE_PASSWORD));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_KEY_STORE) != null)\n        {\n            conSettings.setKeyStorePath(\n                    getProperty(BrokerDetails.OPTIONS_KEY_STORE));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_KEY_STORE_PASSWORD) != null)\n        {\n            conSettings.setKeyStorePassword(\n                    getProperty(BrokerDetails.OPTIONS_KEY_STORE_PASSWORD));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_SSL_CERT_ALIAS) != null)\n        {\n            conSettings.setCertAlias(\n                    getProperty(BrokerDetails.OPTIONS_SSL_CERT_ALIAS));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_PRIV_KEY_PATH) != null)\n        {\n            conSettings.setClientCertificatePrivateKeyPath(\n                    getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_PRIV_KEY_PATH));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_PATH) != null)\n        {\n            conSettings.setClientCertificatePath(\n                    getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_PATH));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_INTERMEDIARY_CERT_PATH) != null)\n        {\n            conSettings.setClientCertificateIntermediateCertsPath(\n                    getProperty(BrokerDetails.OPTIONS_CLIENT_CERT_INTERMEDIARY_CERT_PATH));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_TRUSTED_CERTIFICATES_PATH) != null)\n        {\n            conSettings.setTrustedCertificatesFile(\n                    getProperty(BrokerDetails.OPTIONS_TRUSTED_CERTIFICATES_PATH));\n        }\n        // ----------------------------\n\n        boolean defaultSSLVerifyHostName = Boolean.parseBoolean(\n                System.getProperty(ClientProperties.CONNECTION_OPTION_SSL_VERIFY_HOST_NAME,\n                    String.valueOf(ClientProperties.DEFAULT_CONNECTION_OPTION_SSL_VERIFY_HOST_NAME)));\n        conSettings.setVerifyHostname(getBooleanProperty(BrokerDetails.OPTIONS_SSL_VERIFY_HOSTNAME, defaultSSLVerifyHostName ));\n\n        // ----------------------------\n\n        if (getProperty(BrokerDetails.OPTIONS_ENCRYPTION_KEY_STORE) != null)\n        {\n            conSettings.setEncryptionKeyStorePath(\n                    getProperty(BrokerDetails.OPTIONS_ENCRYPTION_KEY_STORE));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_ENCRYPTION_KEY_STORE_PASSWORD) != null)\n        {\n            conSettings.setEncryptionKeyStorePassword(\n                    getProperty(BrokerDetails.OPTIONS_ENCRYPTION_KEY_STORE_PASSWORD));\n        }\n\n\n        if (getProperty(BrokerDetails.OPTIONS_ENCRYPTION_TRUST_STORE) != null)\n        {\n            conSettings.setEncryptionTrustStorePath(\n                    getProperty(BrokerDetails.OPTIONS_ENCRYPTION_TRUST_STORE));\n        }\n\n        if (getProperty(BrokerDetails.OPTIONS_ENCRYPTION_TRUST_STORE_PASSWORD) != null)\n        {\n            conSettings.setEncryptionTrustStorePassword(\n                    getProperty(BrokerDetails.OPTIONS_ENCRYPTION_TRUST_STORE_PASSWORD));\n        }\n\n\n        if (getProperty(BrokerDetails.OPTIONS_ENCRYPTION_REMOTE_TRUST_STORE) != null)\n        {\n            conSettings.setEncryptionRemoteTrustStoreName(\n                    getProperty(BrokerDetails.OPTIONS_ENCRYPTION_REMOTE_TRUST_STORE));\n        }\n\n        // ----------------------------\n\n        if (getProperty(BrokerDetails.OPTIONS_TCP_NO_DELAY) != null)\n        {\n            conSettings.setTcpNodelay(\n                    getBooleanProperty(BrokerDetails.OPTIONS_TCP_NO_DELAY,true));\n        }\n\n        conSettings.setConnectTimeout(lookupConnectTimeout());\n\n        if (getProperty(BrokerDetails.OPTIONS_HEARTBEAT) != null)\n        {\n            conSettings.setHeartbeatInterval(getIntegerProperty(BrokerDetails.OPTIONS_HEARTBEAT));\n        }\n        else if (getProperty(BrokerDetails.OPTIONS_IDLE_TIMEOUT) != null)\n        {\n            conSettings.setHeartbeatInterval(getIntegerProperty(BrokerDetails.OPTIONS_IDLE_TIMEOUT) / 1000);\n        }\n\n        return conSettings;\n    }\n"
    },
    "Tiles_api-1": {
        "buggy": "    /**\n     * Returns a description of the attributes.\n     *\n     * @return A string representation of the content of this definition.\n     */\n    public String toString() {\n        return \"{name=\"\n            + name\n            + \", template=\"\n            + templateAttribute.getValue()\n            + \", role=\"\n            + templateAttribute.getRoles()\n            + \", preparerInstance=\"\n            + preparer\n            + \", attributes=\"\n            + attributes\n            + \"}\\n\";\n    }\n",
        "start": 293,
        "end": 310,
        "fix": "    /**\n     * Returns a description of the attributes.\n     *\n     * @return A string representation of the content of this definition.\n     */\n    public String toString() {\n        return \"{name=\"\n            + name\n            + \", template=\"\n            + (templateAttribute != null ? templateAttribute.getValue() : \"<null>\")\n            + \", role=\"\n            + (templateAttribute != null ? templateAttribute.getRoles() : \"<null>\")\n            + \", preparerInstance=\"\n            + preparer\n            + \", attributes=\"\n            + attributes\n            + \"}\";\n    }\n"
    },
    "Tiles_core-1": {
        "buggy": "    /** {@inheritDoc} */\n    public void init(Map<String, String> parameters) {\n        String defaultRendererParam = parameters.get(DEFAULT_RENDERER_INIT_PARAM);\n        if (defaultRendererParam == null) {\n            defaultRendererParam = DEFAULT_RENDERER_CLASS_NAME;\n        }\n        defaultRenderer = (AttributeRenderer) ClassUtil\n                .instantiate(defaultRendererParam);\n        initializeRenderer(defaultRenderer);\n        String typeRenderersParam = parameters.get(TYPE_RENDERERS_INIT_PARAM);\n        Map<String, String> completeParams = new HashMap<String, String>(\n                DEFAULT_TYPE_2_RENDERER);\n        if (typeRenderersParam != null) {\n            String[] pairs = typeRenderersParam.split(\"\\\\s*;\\\\s\");\n            for (int i = 0; i < pairs.length; i++) {\n                String[] pair = pairs[i].split(\"\\\\s*,\\\\s*\");\n                if (pair == null || pair.length != 2) {\n                    throw new RendererException(\"The string '\" + pairs[i]\n                            + \"' is not a valid type-renderer pair\");\n                }\n                completeParams.put(pair[0], pair[1]);\n            }\n        }\n\n        for (Map.Entry<String, String> entry : completeParams.entrySet()) {\n            AttributeRenderer renderer = (AttributeRenderer) ClassUtil\n                    .instantiate(entry.getValue());\n            initializeRenderer(renderer);\n            renderers.put(entry.getKey(), renderer);\n        }\n    }\n",
        "start": 141,
        "end": 171,
        "fix": "    /** {@inheritDoc} */\n    public void init(Map<String, String> parameters) {\n        String defaultRendererParam = parameters.get(DEFAULT_RENDERER_INIT_PARAM);\n        if (defaultRendererParam == null) {\n            defaultRendererParam = DEFAULT_RENDERER_CLASS_NAME;\n        }\n        defaultRenderer = (AttributeRenderer) ClassUtil\n                .instantiate(defaultRendererParam);\n        initializeRenderer(defaultRenderer);\n        String typeRenderersParam = parameters.get(TYPE_RENDERERS_INIT_PARAM);\n        Map<String, String> completeParams = new HashMap<String, String>(\n                DEFAULT_TYPE_2_RENDERER);\n        if (typeRenderersParam != null) {\n            String[] pairs = typeRenderersParam.split(\"\\\\s*;\\\\s*\");\n            for (int i = 0; i < pairs.length; i++) {\n                String[] pair = pairs[i].split(\"\\\\s*,\\\\s*\");\n                if (pair == null || pair.length != 2) {\n                    throw new RendererException(\"The string '\" + pairs[i]\n                            + \"' is not a valid type-renderer pair\");\n                }\n                completeParams.put(pair[0], pair[1]);\n            }\n        }\n\n        for (Map.Entry<String, String> entry : completeParams.entrySet()) {\n            AttributeRenderer renderer = (AttributeRenderer) ClassUtil\n                    .instantiate(entry.getValue());\n            initializeRenderer(renderer);\n            renderers.put(entry.getKey(), renderer);\n        }\n    }\n"
    },
    "Tiles_core-2": {
        "buggy": "        /** {@inheritDoc} */\n        @Override\n        public void begin(String namespace, String name, Attributes attributes)\n                throws Exception {\n            Definition definition = (Definition) digester.peek();\n            definition.setName(attributes.getValue(\"name\"));\n            definition.setPreparer(attributes.getValue(\"preparer\"));\n            definition.setExtends(attributes.getValue(\"extends\"));\n\n            String template = attributes.getValue(\"template\");\n            Attribute attribute = Attribute.createTemplateAttribute(template);\n            attribute.setExpressionObject(Expression\n                    .createExpressionFromDescribedExpression(attributes\n                            .getValue(\"templateExpression\")));\n            attribute.setRole(attributes.getValue(\"role\"));\n            String templateType = attributes.getValue(\"templateType\");\n            if (templateType != null) {\n                attribute.setRenderer(templateType);\n            }\n            definition.setTemplateAttribute(attribute);\n        }\n",
        "start": 158,
        "end": 178,
        "fix": "        /** {@inheritDoc} */\n        @Override\n        public void begin(String namespace, String name, Attributes attributes)\n                throws Exception {\n            Definition definition = (Definition) digester.peek();\n            definition.setName(attributes.getValue(\"name\"));\n            definition.setPreparer(attributes.getValue(\"preparer\"));\n            String extendsAttribute = attributes.getValue(\"extends\");\n            definition.setExtends(extendsAttribute);\n\n            String template = attributes.getValue(\"template\");\n            Attribute attribute = Attribute.createTemplateAttribute(template);\n            attribute.setExpressionObject(Expression\n                    .createExpressionFromDescribedExpression(attributes\n                            .getValue(\"templateExpression\")));\n            attribute.setRole(attributes.getValue(\"role\"));\n            String templateType = attributes.getValue(\"templateType\");\n            if (templateType != null) {\n                attribute.setRenderer(templateType);\n            } else if (extendsAttribute != null && templateType == null) {\n                attribute.setRenderer(null);\n            }\n            definition.setTemplateAttribute(attribute);\n        }\n"
    },
    "Wicket_request-1": {
        "buggy": "\t/**\n\t * Stringizes this url\n\t * \n\t * @param mode\n\t *            {@link StringMode} that determins how to stringize the url\n\t * @param charset\n\t *            charset\n\t * @return sringized version of this url\n\t * \n\t */\n\tpublic String toString(StringMode mode, Charset charset)\n\t{\n\t\tStringBuilder result = new StringBuilder();\n\t\tfinal String path = getPath(charset);\n\n\t\tif (StringMode.FULL == mode)\n\t\t{\n\t\t\tif (Strings.isEmpty(host))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it does not have a host set.\");\n\t\t\t}\n\n\t\t\tif (Strings.isEmpty(protocol) == false)\n\t\t\t{\n\t\t\t\tresult.append(protocol);\n\t\t\t\tresult.append(\"://\");\n\t\t\t}\n\t\t\telse if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)\n\t\t\t{\n\t\t\t\tresult.append(\"//\");\n\t\t\t}\n\t\t\tresult.append(host);\n\n\t\t\tif (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false)\n\t\t\t{\n\t\t\t\tresult.append(':');\n\t\t\t\tresult.append(port);\n\t\t\t}\n\n\t\t\tif (path.contains(\"..\"))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n\t\t\t}\n\n\t\t\tif (!path.startsWith(\"/\"))\n\t\t\t{\n\t\t\t\tresult.append('/');\n\t\t\t}\n\n\t\t}\n\n\n\t\tresult.append(path);\n\t\tresult.append(getQueryString(charset));\n\t\treturn result.toString();\n\t}\n",
        "start": 637,
        "end": 694,
        "fix": "\t/**\n\t * Stringizes this url\n\t * \n\t * @param mode\n\t *            {@link StringMode} that determins how to stringize the url\n\t * @param charset\n\t *            charset\n\t * @return sringized version of this url\n\t * \n\t */\n\tpublic String toString(StringMode mode, Charset charset)\n\t{\n\t\tStringBuilder result = new StringBuilder();\n\t\tfinal String path = getPath(charset);\n\n\t\tif (StringMode.FULL == mode)\n\t\t{\n\t\t\tif (Strings.isEmpty(host))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it does not have a host set.\");\n\t\t\t}\n\n\t\t\tif (Strings.isEmpty(protocol) == false)\n\t\t\t{\n\t\t\t\tresult.append(protocol);\n\t\t\t\tresult.append(\"://\");\n\t\t\t}\n\t\t\telse if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)\n\t\t\t{\n\t\t\t\tresult.append(\"//\");\n\t\t\t}\n\t\t\tresult.append(host);\n\n\t\t\tif (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false)\n\t\t\t{\n\t\t\t\tresult.append(':');\n\t\t\t\tresult.append(port);\n\t\t\t}\n\n\t\t\tif (segments.contains(\"..\"))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n\t\t\t}\n\n\t\t\tif (!path.startsWith(\"/\"))\n\t\t\t{\n\t\t\t\tresult.append('/');\n\t\t\t}\n\n\t\t}\n\n\n\t\tresult.append(path);\n\t\tresult.append(getQueryString(charset));\n\t\treturn result.toString();\n\t}\n"
    },
    "Wicket_request-2": {
        "buggy": "\t/**\n\t * \n\t * @param qp\n\t * @param charset\n\t * @return query parameters\n\t */\n\tprivate static QueryParameter parseQueryParameter(final String qp, final Charset charset)\n\t{\n\t\tint idxOfEquals = qp.indexOf('=');\n\t\tif (idxOfEquals == -1)\n\t\t{\n\t\t\t// name => empty value\n\t\t\treturn new QueryParameter(decodeParameter(qp, charset), \"\");\n\t\t}\n\n\t\tString parts[] = Strings.split(qp, '=');\n\t\treturn new QueryParameter(decodeParameter(parts[0], charset), decodeParameter(parts[1],\n\t\t\tcharset));\n\t}\n",
        "start": 332,
        "end": 350,
        "fix": "\t/**\n\t * \n\t * @param qp\n\t * @param charset\n\t * @return query parameters\n\t */\n\tprivate static QueryParameter parseQueryParameter(final String qp, final Charset charset)\n\t{\n\t\tint idxOfEquals = qp.indexOf('=');\n\t\tif (idxOfEquals == -1)\n\t\t{\n\t\t\t// name => empty value\n\t\t\treturn new QueryParameter(decodeParameter(qp, charset), \"\");\n\t\t}\n\n\t\tString parameterName = qp.substring(0, idxOfEquals);\n\t\tString parameterValue = qp.substring(idxOfEquals + 1);\n\t\treturn new QueryParameter(decodeParameter(parameterName, charset), decodeParameter(parameterValue, charset));\n\t}\n"
    },
    "Wicket_request-3": {
        "buggy": "\t/**\n\t * Stringizes this url\n\t * \n\t * @param mode\n\t *            {@link StringMode} that determins how to stringize the url\n\t * @param charset\n\t *            charset\n\t * @return sringized version of this url\n\t * \n\t */\n\tpublic String toString(StringMode mode, Charset charset)\n\t{\n\t\tStringBuilder result = new StringBuilder();\n\t\tfinal String path = getPath(charset);\n\n\t\tif (StringMode.FULL == mode)\n\t\t{\n\t\t\tif (Strings.isEmpty(host))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it does not have a host set.\");\n\t\t\t}\n\n\t\t\tif (Strings.isEmpty(protocol) == false)\n\t\t\t{\n\t\t\t\tresult.append(protocol);\n\t\t\t\tresult.append(\"://\");\n\t\t\t}\n\t\t\telse if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)\n\t\t\t{\n\t\t\t\tresult.append(\"//\");\n\t\t\t}\n\t\t\tresult.append(host);\n\n\t\t\tif (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false)\n\t\t\t{\n\t\t\t\tresult.append(':');\n\t\t\t\tresult.append(port);\n\t\t\t}\n\n\t\t\tif (segments.contains(\"..\"))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n\t\t\t}\n\n\t\t\tif (!path.startsWith(\"/\"))\n\t\t\t{\n\t\t\t\tresult.append('/');\n\t\t\t}\n\n\t\t}\n\n\n\t\tresult.append(path);\n        \n\t\tresult.append(getQueryString(charset));\n\t\treturn result.toString();\n\t}\n",
        "start": 662,
        "end": 720,
        "fix": "\t/**\n\t * Stringizes this url\n\t * \n\t * @param mode\n\t *            {@link StringMode} that determins how to stringize the url\n\t * @param charset\n\t *            charset\n\t * @return sringized version of this url\n\t * \n\t */\n\tpublic String toString(StringMode mode, Charset charset)\n\t{\n\t\tStringBuilder result = new StringBuilder();\n\t\tfinal String path = getPath(charset);\n\n\t\tif (StringMode.FULL == mode)\n\t\t{\n\t\t\tif (Strings.isEmpty(host))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it does not have a host set.\");\n\t\t\t}\n\n\t\t\tif (Strings.isEmpty(protocol) == false)\n\t\t\t{\n\t\t\t\tresult.append(protocol);\n\t\t\t\tresult.append(\"://\");\n\t\t\t}\n\t\t\telse if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)\n\t\t\t{\n\t\t\t\tresult.append(\"//\");\n\t\t\t}\n\t\t\tresult.append(host);\n\n\t\t\tif (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false)\n\t\t\t{\n\t\t\t\tresult.append(':');\n\t\t\t\tresult.append(port);\n\t\t\t}\n\n\t\t\tif (segments.contains(\"..\"))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n\t\t\t}\n\n\t\t\tif (!path.startsWith(\"/\"))\n\t\t\t{\n\t\t\t\tresult.append('/');\n\t\t\t}\n\n\t\t}\n\n\n\t\tresult.append(path);\n        \n        final String queryString = getQueryString(charset);\n        if (queryString != null)\n        {\n            result.append('?').append(queryString);\n        }\n\t\treturn result.toString();\n\t}\n"
    },
    "Wicket_request-4": {
        "buggy": "\t/**\n\t * Parses the given URL string.\n\t * \n\t * @param _url\n\t *            absolute or relative url with query string\n\t * @param charset\n\t * @return Url object\n\t */\n\tpublic static Url parse(CharSequence _url, Charset charset)\n\t{\n\t\tArgs.notNull(_url, \"_url\");\n\n\t\tfinal Url result = new Url(charset);\n\n\t\t// the url object resolved the charset, use that\n\t\tcharset = result.getCharset();\n\n\t\tString url = _url.toString();\n\t\t// extract query string part\n\t\tfinal String queryString;\n\t\tfinal String absoluteUrl;\n\n\t\tfinal int queryAt = url.indexOf('?');\n\n\t\tif (queryAt == -1)\n\t\t{\n\t\t\tqueryString = \"\";\n\t\t\tabsoluteUrl = url;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tabsoluteUrl = url.substring(0, queryAt);\n\t\t\tqueryString = url.substring(queryAt + 1);\n\t\t}\n\n\t\t// get absolute / relative part of url\n\t\tString relativeUrl;\n\n\t\tfinal int idxOfFirstSlash = absoluteUrl.indexOf('/');\n\t\tfinal int protocolAt = absoluteUrl.indexOf(\"://\");\n\n\t\t// full urls start either with a \"scheme://\" or with \"//\"\n\t\tboolean protocolLess = absoluteUrl.startsWith(\"//\");\n\t\tfinal boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;\n\n\t\tif (isFull)\n\t\t{\n\t\t\tif (protocolLess == false)\n\t\t\t{\n\t\t\t\tresult.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\n\t\t\t}\n\n\t\t\tfinal String afterProto = absoluteUrl.substring(protocolAt + 3);\n\t\t\tfinal String hostAndPort;\n\n\t\t\tint relativeAt = afterProto.indexOf('/');\n\t\t\tif (relativeAt == -1)\n\t\t\t{\n\t\t\t\trelativeAt = afterProto.indexOf(';');\n\t\t\t}\n\t\t\tif (relativeAt == -1)\n\t\t\t{\n\t\t\t\trelativeUrl = \"\";\n\t\t\t\thostAndPort = afterProto;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trelativeUrl = afterProto.substring(relativeAt);\n\t\t\t\thostAndPort = afterProto.substring(0, relativeAt);\n\t\t\t}\n\n\t\t\tfinal int portAt = hostAndPort.lastIndexOf(':');\n\n\t\t\tif (portAt == -1)\n\t\t\t{\n\t\t\t\tresult.host = hostAndPort;\n\t\t\t\tresult.port = getDefaultPortForProtocol(result.protocol);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.host = hostAndPort.substring(0, portAt);\n\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portAt + 1));\n\t\t\t}\n\n\t\t\tif (relativeAt < 0)\n\t\t\t{\n\t\t\t\trelativeUrl = \"/\";\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\trelativeUrl = absoluteUrl;\n\t\t}\n\n\t\tif (relativeUrl.length() > 0)\n\t\t{\n\t\t\tboolean removeLast = false;\n\t\t\tif (relativeUrl.endsWith(\"/\"))\n\t\t\t{\n\t\t\t\t// we need to append something and remove it after splitting\n\t\t\t\t// because otherwise the\n\t\t\t\t// trailing slashes will be lost\n\t\t\t\trelativeUrl += \"/x\";\n\t\t\t\tremoveLast = true;\n\t\t\t}\n\n\t\t\tString segmentArray[] = Strings.split(relativeUrl, '/');\n\n\t\t\tif (removeLast)\n\t\t\t{\n\t\t\t\tsegmentArray[segmentArray.length - 1] = null;\n\t\t\t}\n\n\t\t\tfor (String s : segmentArray)\n\t\t\t{\n\t\t\t\tif (s != null)\n\t\t\t\t{\n\t\t\t\t\tresult.segments.add(decodeSegment(s, charset));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (queryString.length() > 0)\n\t\t{\n\t\t\tString queryArray[] = Strings.split(queryString, '&');\n\t\t\tfor (String s : queryArray)\n\t\t\t{\n\t\t\t\tif (Strings.isEmpty(s) == false)\n\t\t\t\t{\n\t\t\t\t\tresult.parameters.add(parseQueryParameter(s, charset));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n",
        "start": 195,
        "end": 330,
        "fix": "\t/**\n\t * Parses the given URL string.\n\t * \n\t * @param _url\n\t *            absolute or relative url with query string\n\t * @param charset\n\t * @return Url object\n\t */\n\tpublic static Url parse(CharSequence _url, Charset charset)\n\t{\n\t\tArgs.notNull(_url, \"_url\");\n\n\t\tfinal Url result = new Url(charset);\n\n\t\t// the url object resolved the charset, use that\n\t\tcharset = result.getCharset();\n\n\t\tString url = _url.toString();\n\t\t// extract query string part\n\t\tfinal String queryString;\n\t\tfinal String absoluteUrl;\n\n\t\tfinal int queryAt = url.indexOf('?');\n\n\t\tif (queryAt == -1)\n\t\t{\n\t\t\tqueryString = \"\";\n\t\t\tabsoluteUrl = url;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tabsoluteUrl = url.substring(0, queryAt);\n\t\t\tqueryString = url.substring(queryAt + 1);\n\t\t}\n\n\t\t// get absolute / relative part of url\n\t\tString relativeUrl;\n\n\t\tfinal int idxOfFirstSlash = absoluteUrl.indexOf('/');\n\t\tfinal int protocolAt = absoluteUrl.indexOf(\"://\");\n\n\t\t// full urls start either with a \"scheme://\" or with \"//\"\n\t\tboolean protocolLess = absoluteUrl.startsWith(\"//\");\n\t\tfinal boolean isFull = (protocolAt > 1 && (protocolAt < idxOfFirstSlash)) || protocolLess;\n\n\t\tif (isFull)\n\t\t{\n\t\t\tif (protocolLess == false)\n\t\t\t{\n\t\t\t\tresult.protocol = absoluteUrl.substring(0, protocolAt).toLowerCase(Locale.US);\n\t\t\t}\n\n\t\t\tfinal String afterProto = absoluteUrl.substring(protocolAt + 3);\n\t\t\tfinal String hostAndPort;\n\n\t\t\tint relativeAt = afterProto.indexOf('/');\n\t\t\tif (relativeAt == -1)\n\t\t\t{\n\t\t\t\trelativeAt = afterProto.indexOf(';');\n\t\t\t}\n\t\t\tif (relativeAt == -1)\n\t\t\t{\n\t\t\t\trelativeUrl = \"\";\n\t\t\t\thostAndPort = afterProto;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trelativeUrl = afterProto.substring(relativeAt);\n\t\t\t\thostAndPort = afterProto.substring(0, relativeAt);\n\t\t\t}\n\n\t\t\tfinal int credentialsAt = hostAndPort.lastIndexOf('@') + 1;\n\t\t\tfinal int portAt = hostAndPort.substring(credentialsAt).lastIndexOf(':');\n\n\t\t\tif (portAt == -1)\n\t\t\t{\n\t\t\t\tresult.host = hostAndPort;\n\t\t\t\tresult.port = getDefaultPortForProtocol(result.protocol);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.host = hostAndPort.substring(0, portAt + credentialsAt);\n\t\t\t\tresult.port = Integer.parseInt(hostAndPort.substring(portAt + credentialsAt + 1));\n\t\t\t}\n\n\t\t\tif (relativeAt < 0)\n\t\t\t{\n\t\t\t\trelativeUrl = \"/\";\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\trelativeUrl = absoluteUrl;\n\t\t}\n\n\t\tif (relativeUrl.length() > 0)\n\t\t{\n\t\t\tboolean removeLast = false;\n\t\t\tif (relativeUrl.endsWith(\"/\"))\n\t\t\t{\n\t\t\t\t// we need to append something and remove it after splitting\n\t\t\t\t// because otherwise the\n\t\t\t\t// trailing slashes will be lost\n\t\t\t\trelativeUrl += \"/x\";\n\t\t\t\tremoveLast = true;\n\t\t\t}\n\n\t\t\tString segmentArray[] = Strings.split(relativeUrl, '/');\n\n\t\t\tif (removeLast)\n\t\t\t{\n\t\t\t\tsegmentArray[segmentArray.length - 1] = null;\n\t\t\t}\n\n\t\t\tfor (String s : segmentArray)\n\t\t\t{\n\t\t\t\tif (s != null)\n\t\t\t\t{\n\t\t\t\t\tresult.segments.add(decodeSegment(s, charset));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (queryString.length() > 0)\n\t\t{\n\t\t\tString queryArray[] = Strings.split(queryString, '&');\n\t\t\tfor (String s : queryArray)\n\t\t\t{\n\t\t\t\tif (Strings.isEmpty(s) == false)\n\t\t\t\t{\n\t\t\t\t\tresult.parameters.add(parseQueryParameter(s, charset));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n"
    },
    "Wicket_request-5": {
        "buggy": "\t@Override\n\tpublic void unmount(String path)\n\t{\n\t\tfinal Url url = Url.parse(path);\n\t\tfinal Request request = createRequest(url);\n\n\t\tfor (IRequestMapper mapper : this)\n\t\t{\n\t\t\tif (mapper.mapRequest(request) != null)\n\t\t\t{\n\t\t\t\tremove(mapper);\n\t\t\t}\n\t\t}\n\t}\n",
        "start": 246,
        "end": 259,
        "fix": "\t@Override\n\tpublic void unmount(String path)\n\t{\n\t\tfinal Url url = Url.parse(path);\n\t\tfinal Request request = createRequest(url);\n\n\t\tfor (IRequestMapper mapper : this)\n\t\t{\n\t\t\tif (mapper instanceof ICompoundRequestMapper)\n\t\t\t{\n\t\t\t\tICompoundRequestMapper inner = (ICompoundRequestMapper) mapper;\n\t\t\t\tinner.unmount(path);\n\t\t\t}\n\t\t\telse if (mapper.mapRequest(request) != null)\n\t\t\t{\n\t\t\t\tremove(mapper);\n\t\t\t}\n\t\t}\n\t}\n"
    },
    "Wicket_util-1": {
        "buggy": "\t/**\n\t * Retrieves the hour field of the given <code>Calendar</code>.\n\t * \n\t * @param calendar\n\t *            the <code>Calendar</code> to get the field value from\n\t * @return the hour field value\n\t */\n\tpublic int getHour(final Calendar calendar)\n\t{\n\t\treturn get(calendar, Calendar.HOUR);\n\t}\n",
        "start": 343,
        "end": 353,
        "fix": "\t/**\n\t * Retrieves the hour field of the given <code>Calendar</code>.\n\t * \n\t * @param calendar\n\t *            the <code>Calendar</code> to get the field value from\n\t * @return the hour field value\n\t */\n\tpublic int getHour(final Calendar calendar)\n\t{\n\t\treturn get(calendar, Calendar.HOUR_OF_DAY);\n\t}\n"
    },
    "Wicket_util-2": {
        "buggy": "\t/**\n\t * Joins string fragments using the specified separator\n\t * \n\t * @param separator\n\t * @param fragments\n\t * @return combined fragments\n\t */\n\tpublic static String join(final String separator, final String... fragments)\n\t{\n\t\tif ((fragments == null) || (fragments.length < 1))\n\t\t{\n\t\t\t// no elements\n\t\t\treturn \"\";\n\t\t}\n\t\telse if (fragments.length < 2)\n\t\t{\n\t\t\t// single element\n\t\t\treturn fragments[0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// two or more elements\n\t\t\tStringBuilder buff = new StringBuilder(128);\n\t\t\tif (fragments[0] != null)\n\t\t\t{\n\t\t\t\tbuff.append(fragments[0]);\n\t\t\t}\n\t\t\tfor (int i = 1; i < fragments.length; i++)\n\t\t\t{\n\t\t\t\tString fragment = fragments[i];\n\t\t\t\tif ((fragments[i - 1] != null) || (fragment != null))\n\t\t\t\t{\n\t\t\t\t\tboolean lhsClosed = fragments[i - 1].endsWith(separator);\n\t\t\t\t\tboolean rhsClosed = fragment.startsWith(separator);\n\t\t\t\t\tif (lhsClosed && rhsClosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuff.append(fragment.substring(1));\n\t\t\t\t\t}\n\t\t\t\t\telse if (!lhsClosed && !rhsClosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Strings.isEmpty(fragment))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbuff.append(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuff.append(fragment);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbuff.append(fragment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buff.toString();\n\t\t}\n\t}\n",
        "start": 646,
        "end": 700,
        "fix": "\t/**\n\t * Joins string fragments using the specified separator\n\t * \n\t * @param separator\n\t * @param fragments\n\t * @return combined fragments\n\t */\n\tpublic static String join(final String separator, final String... fragments)\n\t{\n\t\tif ((fragments == null) || (fragments.length < 1))\n\t\t{\n\t\t\t// no elements\n\t\t\treturn \"\";\n\t\t}\n\t\telse if (fragments.length < 2)\n\t\t{\n\t\t\t// single element\n\t\t\treturn fragments[0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// two or more elements\n\t\t\tStringBuilder buff = new StringBuilder(128);\n\t\t\tif (fragments[0] != null)\n\t\t\t{\n\t\t\t\tbuff.append(fragments[0]);\n\t\t\t}\n\t\t\tfor (int i = 1; i < fragments.length; i++)\n\t\t\t{\n\t\t\t\tString fragment = fragments[i];\n\t\t\t\tif ((fragments[i - 1] != null) || (fragment != null))\n\t\t\t\t{\n\t\t\t\t\tboolean lhsClosed = fragments[i - 1].endsWith(separator);\n\t\t\t\t\tboolean rhsClosed = fragment.startsWith(separator);\n\t\t\t\t\tif (!Strings.isEmpty(separator) && lhsClosed && rhsClosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tbuff.append(fragment.substring(1));\n\t\t\t\t\t}\n\t\t\t\t\telse if (!lhsClosed && !rhsClosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!Strings.isEmpty(fragment))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbuff.append(separator);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbuff.append(fragment);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbuff.append(fragment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buff.toString();\n\t\t}\n\t}\n"
    },
    "Wicket_util-3": {
        "buggy": "\t/**\n\t * Reconstitute the <tt>HashMap</tt> instance from a stream (i.e., deserialize it).\n\t * \n\t * @param s\n\t * @throws IOException\n\t * @throws ClassNotFoundException\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void readObject(final java.io.ObjectInputStream s) throws IOException,\n\t\tClassNotFoundException\n\t{\n\n\t\t// Read in the threshold, loadfactor, and any hidden stuff\n\t\ts.defaultReadObject();\n\n\t\t// Read in number of buckets and allocate the bucket array;\n\t\tint numBuckets = s.readInt();\n\t\ttable = new Entry[numBuckets];\n\n\t\tinit(); // Give subclass a chance to do its thing.\n\n\t\t// Read in size (number of Mappings)\n\t\tint size = s.readInt();\n\n\t\t// Read the keys and values, and put the mappings in the HashMap\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tint key = s.readInt();\n\t\t\tV value = (V)s.readObject();\n\t\t\tputForCreate(key, value);\n\t\t}\n\t}\n",
        "start": 1137,
        "end": 1168,
        "fix": "\t/**\n\t * Reconstitute the <tt>HashMap</tt> instance from a stream (i.e., deserialize it).\n\t * \n\t * @param s\n\t * @throws IOException\n\t * @throws ClassNotFoundException\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void readObject(final java.io.ObjectInputStream s) throws IOException,\n\t\tClassNotFoundException\n\t{\n\t\tmodCount = new AtomicInteger(0);\n\n\t\t// Read in the threshold, loadfactor, and any hidden stuff\n\t\ts.defaultReadObject();\n\n\t\t// Read in number of buckets and allocate the bucket array;\n\t\tint numBuckets = s.readInt();\n\t\ttable = new Entry[numBuckets];\n\n\t\tinit(); // Give subclass a chance to do its thing.\n\n\t\t// Read in size (number of Mappings)\n\t\tint size = s.readInt();\n\n\t\t// Read the keys and values, and put the mappings in the HashMap\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tint key = s.readInt();\n\t\t\tV value = (V)s.readObject();\n\t\t\tputForCreate(key, value);\n\t\t}\n\t}\n"
    },
    "Wicket_util-4": {
        "buggy": "\t/**\n\t * Gets last modified date of the given {@link URL}\n\t * \n\t * @param url\n\t * @return last modified timestamp or <code>null</code> if not available\n\t * @throws IOException\n\t */\n\tpublic static Time getLastModified(final URL url) throws IOException\n\t{\n\t\t// check if url points to a local file\n\t\tfinal File file = Files.getLocalFileFromUrl(url);\n\n\t\tif (file != null)\n\t\t{\n\t\t\t// in that case we can get the timestamp faster\n\t\t\treturn Files.getLastModified(file);\n\t\t}\n\n\t\t// otherwise open the url and proceed\n\t\tURLConnection connection = url.openConnection();\n\t\tconnection.setDoInput(false);\n\n\t\tfinal long milliseconds;\n\n\t\ttry\n\t\t{\n\t\t\tif (connection instanceof JarURLConnection)\n\t\t\t{\n\t\t\t\tJarURLConnection jarUrlConnection = (JarURLConnection)connection;\n\t\t\t\tURL jarFileUrl = jarUrlConnection.getJarFileURL();\n\t\t\t\tURLConnection jarFileConnection = jarFileUrl.openConnection();\n\t\t\t\tjarFileConnection.setDoInput(false);\n\t\t\t\t// get timestamp from JAR\n\t\t\t\tmilliseconds = jarFileConnection.getLastModified();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// get timestamp from URL\n\t\t\t\tmilliseconds = connection.getLastModified();\n\t\t\t}\n\n\t\t\t// return null if timestamp is unavailable\n\t\t\tif (milliseconds == 0)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// return UNIX timestamp\n\t\t\treturn Time.millis(milliseconds);\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tcloseQuietly(connection);\n\t\t}\n\t}\n",
        "start": 40,
        "end": 95,
        "fix": "\t/**\n\t * Gets last modified date of the given {@link URL}\n\t * \n\t * @param url\n\t * @return last modified timestamp or <code>null</code> if not available\n\t * @throws IOException\n\t */\n\tpublic static Time getLastModified(final URL url) throws IOException\n\t{\n\t\t// check if url points to a local file\n\t\tfinal File file = Files.getLocalFileFromUrl(url);\n\n\t\tif (file != null)\n\t\t{\n\t\t\t// in that case we can get the timestamp faster\n\t\t\treturn Files.getLastModified(file);\n\t\t}\n\n\t\t// otherwise open the url and proceed\n\t\tURLConnection connection = url.openConnection();\n\n\t\tfinal long milliseconds;\n\n\t\ttry\n\t\t{\n\t\t\tif (connection instanceof JarURLConnection)\n\t\t\t{\n\t\t\t\tJarURLConnection jarUrlConnection = (JarURLConnection)connection;\n\t\t\t\tURL jarFileUrl = jarUrlConnection.getJarFileURL();\n\t\t\t\tURLConnection jarFileConnection = jarFileUrl.openConnection();\n\t\t\t\tjarFileConnection.setDoInput(false);\n\t\t\t\t// get timestamp from JAR\n\t\t\t\tmilliseconds = jarFileConnection.getLastModified();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// get timestamp from URL\n\t\t\t\tmilliseconds = connection.getLastModified();\n\t\t\t}\n\n\t\t\t// return null if timestamp is unavailable\n\t\t\tif (milliseconds == 0)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// return UNIX timestamp\n\t\t\treturn Time.millis(milliseconds);\n\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tcloseQuietly(connection);\n\t\t}\n\t}\n"
    },
    "Wicket_spring-1": {
        "buggy": "\t@Override\n\tpublic Object getFieldValue(final Field field, final Object fieldOwner)\n\t{\n\t\tif (supportsField(field))\n\t\t{\n\t\t\tSpringBean annot = field.getAnnotation(SpringBean.class);\n\n\t\t\tString name;\n\t\t\tboolean required;\n\t\t\tif (annot != null)\n\t\t\t{\n\t\t\t\tname = annot.name();\n\t\t\t\trequired = annot.required();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNamed named = field.getAnnotation(Named.class);\n\t\t\t\tname = named != null ? named.value() : \"\";\n\t\t\t\trequired = false;\n\t\t\t}\n\n\t\t\tString beanName = getBeanName(field, name, required);\n\n\t\t\tif (beanName == null)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tSpringBeanLocator locator = new SpringBeanLocator(beanName, field.getType(),\n\t\t\t\tcontextLocator);\n\n\t\t\t// only check the cache if the bean is a singleton\n\t\t\tObject cachedValue = cache.get(locator);\n\t\t\tif (cachedValue != null)\n\t\t\t{\n\t\t\t\treturn cachedValue;\n\t\t\t}\n\n\t\t\tObject target;\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// check whether there is a bean with the provided properties\n\t\t\t\ttarget = locator.locateProxyTarget();\n\t\t\t}\n\t\t\tcatch (IllegalStateException isx)\n\t\t\t{\n\t\t\t\tif (required)\n\t\t\t\t{\n\t\t\t\t\tthrow isx;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (wrapInProxies)\n\t\t\t{\n\t\t\t\ttarget = LazyInitProxyFactory.createProxy(field.getType(), locator);\n\t\t\t}\n\n\t\t\t// only put the proxy into the cache if the bean is a singleton\n\t\t\tif (locator.isSingletonBean())\n\t\t\t{\n\t\t\t\tObject tmpTarget = cache.putIfAbsent(locator, target);\n\t\t\t\tif (tmpTarget != null)\n\t\t\t\t{\n\t\t\t\t\ttarget = tmpTarget;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn target;\n\t\t}\n\t\treturn null;\n\t}\n",
        "start": 109,
        "end": 182,
        "fix": "\t@Override\n\tpublic Object getFieldValue(final Field field, final Object fieldOwner)\n\t{\n\t\tif (supportsField(field))\n\t\t{\n\t\t\tSpringBean annot = field.getAnnotation(SpringBean.class);\n\n\t\t\tString name;\n\t\t\tboolean required;\n\t\t\tif (annot != null)\n\t\t\t{\n\t\t\t\tname = annot.name();\n\t\t\t\trequired = annot.required();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNamed named = field.getAnnotation(Named.class);\n\t\t\t\tname = named != null ? named.value() : \"\";\n\t\t\t\trequired = true;\n\t\t\t}\n\n\t\t\tString beanName = getBeanName(field, name, required);\n\n\t\t\tif (beanName == null)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tSpringBeanLocator locator = new SpringBeanLocator(beanName, field.getType(),\n\t\t\t\tcontextLocator);\n\n\t\t\t// only check the cache if the bean is a singleton\n\t\t\tObject cachedValue = cache.get(locator);\n\t\t\tif (cachedValue != null)\n\t\t\t{\n\t\t\t\treturn cachedValue;\n\t\t\t}\n\n\t\t\tObject target;\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// check whether there is a bean with the provided properties\n\t\t\t\ttarget = locator.locateProxyTarget();\n\t\t\t}\n\t\t\tcatch (IllegalStateException isx)\n\t\t\t{\n\t\t\t\tif (required)\n\t\t\t\t{\n\t\t\t\t\tthrow isx;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (wrapInProxies)\n\t\t\t{\n\t\t\t\ttarget = LazyInitProxyFactory.createProxy(field.getType(), locator);\n\t\t\t}\n\n\t\t\t// only put the proxy into the cache if the bean is a singleton\n\t\t\tif (locator.isSingletonBean())\n\t\t\t{\n\t\t\t\tObject tmpTarget = cache.putIfAbsent(locator, target);\n\t\t\t\tif (tmpTarget != null)\n\t\t\t\t{\n\t\t\t\t\ttarget = tmpTarget;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn target;\n\t\t}\n\t\treturn null;\n\t}\n"
    },
    "Struts1_core-1": {
        "buggy": "\tpublic final void field() throws RecognitionException, TokenStreamException {\n\t\t\n\t\t\n\t\tif ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && (LA(3)==RBRACKET) && (LA(4)==IDENTIFIER)) {\n\t\t\tidentifier();\n\t\t\tmatch(LBRACKET);\n\t\t\tmatch(RBRACKET);\n\t\t\tidentifier();\n\t\t\t\n\t\t\tObject i2 = argStack.pop();\n\t\t\tObject i1 = argStack.pop();\n\t\t\targStack.push(ValidatorUtils.getValueAsString(form, i1 + \"[\" + index + \"]\" + i2));\n\t\t\t\n\t\t}\n\t\telse if ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && ((LA(3) >= DECIMAL_LITERAL && LA(3) <= OCTAL_LITERAL)) && (LA(4)==RBRACKET) && (LA(5)==IDENTIFIER)) {\n\t\t\tidentifier();\n\t\t\tmatch(LBRACKET);\n\t\t\tinteger();\n\t\t\tmatch(RBRACKET);\n\t\t\tidentifier();\n\t\t\t\n\t\t\tObject i5 = argStack.pop();\n\t\t\tObject i4 = argStack.pop();\n\t\t\tObject i3 = argStack.pop();\n\t\t\targStack.push(ValidatorUtils.getValueAsString(form, i3 + \"[\" + i4 + \"]\" + i5));\n\t\t\t\n\t\t}\n\t\telse if ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && ((LA(3) >= DECIMAL_LITERAL && LA(3) <= OCTAL_LITERAL)) && (LA(4)==RBRACKET) && (LA(5)==LBRACKET)) {\n\t\t\tidentifier();\n\t\t\tmatch(LBRACKET);\n\t\t\tinteger();\n\t\t\tmatch(RBRACKET);\n\t\t\tmatch(LBRACKET);\n\t\t\t\n\t\t\tObject i7 = argStack.pop();\n\t\t\tObject i6 = argStack.pop();\n\t\t\targStack.push(ValidatorUtils.getValueAsString(form, i6 + \"[\" + i7 + \"]\"));\n\t\t\t\n\t\t}\n\t\telse if ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && (LA(3)==RBRACKET) && (_tokenSet_0.member(LA(4)))) {\n\t\t\tidentifier();\n\t\t\tmatch(LBRACKET);\n\t\t\tmatch(RBRACKET);\n\t\t\t\n\t\t\tObject i8 = argStack.pop();\n\t\t\targStack.push(ValidatorUtils.getValueAsString(form, i8 + \"[\" + index + \"]\"));\n\t\t\t\n\t\t}\n\t\telse if ((LA(1)==IDENTIFIER) && (_tokenSet_0.member(LA(2)))) {\n\t\t\tidentifier();\n\t\t\t\n\t\t\tObject i9 = argStack.pop();\n\t\t\targStack.push(ValidatorUtils.getValueAsString(form, (String)i9));\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tthrow new NoViableAltException(LT(1), getFilename());\n\t\t}\n\t\t\n\t}\n",
        "start": 249,
        "end": 308,
        "fix": "\tpublic final void field() throws RecognitionException, TokenStreamException {\n\t\t\n\t\t\n\t\tif ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && (LA(3)==RBRACKET) && (LA(4)==IDENTIFIER)) {\n\t\t\tidentifier();\n\t\t\tmatch(LBRACKET);\n\t\t\tmatch(RBRACKET);\n\t\t\tidentifier();\n\t\t\t\n\t\t\tObject i2 = argStack.pop();\n\t\t\tObject i1 = argStack.pop();\n\t\t\targStack.push(ValidatorUtils.getValueAsString(form, i1 + \"[\" + index + \"]\" + i2));\n\t\t\t\n\t\t}\n\t\telse if ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && ((LA(3) >= DECIMAL_LITERAL && LA(3) <= OCTAL_LITERAL)) && (LA(4)==RBRACKET) && (LA(5)==IDENTIFIER)) {\n\t\t\tidentifier();\n\t\t\tmatch(LBRACKET);\n\t\t\tinteger();\n\t\t\tmatch(RBRACKET);\n\t\t\tidentifier();\n\t\t\t\n\t\t\tObject i5 = argStack.pop();\n\t\t\tObject i4 = argStack.pop();\n\t\t\tObject i3 = argStack.pop();\n\t\t\targStack.push(ValidatorUtils.getValueAsString(form, i3 + \"[\" + i4 + \"]\" + i5));\n\t\t\t\n\t\t}\n\t\telse if ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && ((LA(3) >= DECIMAL_LITERAL && LA(3) <= OCTAL_LITERAL)) && (LA(4)==RBRACKET) && (_tokenSet_0.member(LA(5)))) {\n\t\t\tidentifier();\n\t\t\tmatch(LBRACKET);\n\t\t\tinteger();\n\t\t\tmatch(RBRACKET);\n\t\t\t\n\t\t\tObject i7 = argStack.pop();\n\t\t\tObject i6 = argStack.pop();\n\t\t\targStack.push(ValidatorUtils.getValueAsString(form, i6 + \"[\" + i7 + \"]\"));\n\t\t\t\n\t\t}\n\t\telse if ((LA(1)==IDENTIFIER) && (LA(2)==LBRACKET) && (LA(3)==RBRACKET) && (_tokenSet_0.member(LA(4)))) {\n\t\t\tidentifier();\n\t\t\tmatch(LBRACKET);\n\t\t\tmatch(RBRACKET);\n\t\t\t\n\t\t\tObject i8 = argStack.pop();\n\t\t\targStack.push(ValidatorUtils.getValueAsString(form, i8 + \"[\" + index + \"]\"));\n\t\t\t\n\t\t}\n\t\telse if ((LA(1)==IDENTIFIER) && (_tokenSet_0.member(LA(2)))) {\n\t\t\tidentifier();\n\t\t\t\n\t\t\tObject i9 = argStack.pop();\n\t\t\targStack.push(ValidatorUtils.getValueAsString(form, (String)i9));\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tthrow new NoViableAltException(LT(1), getFilename());\n\t\t}\n\t\t\n\t}\n"
    },
    "Struts1_core-2": {
        "buggy": "    private  boolean evaluateComparison (Object v1, Object compare, Object v2) {\n        boolean intCompare = true;\n\tif ((v1 == null) || (v2 == null)) {\n\t\tif (String.class.isInstance(v1)) {\n\t\t\tif (((String) v1).length() == 0) {\n\t\t\t\tv1 = null;\n\t\t\t}\n\t\t}\n\t\tif (String.class.isInstance(v2)) {\n\t\t\tif (((String) v2).length() == 0) {\n\t\t\t\tv2 = null;\n\t\t\t}\n\t\t}\n\t\tswitch (((Integer)compare).intValue()) {\n\t\tcase LESS_EQUAL:\n\t\tcase GREATER_THAN:\n\t\tcase LESS_THAN:\n\t\tcase GREATER_EQUAL:\n\t\t\treturn false;\n\t\tcase EQUAL:\n\t\t    return (v1 == v2);\n\t\tcase NOT_EQUAL:\n\t\t    return (v1 != v2);\n\t\t}\n\t}\n      if ((Integer.class.isInstance(v1) ||\n           String.class.isInstance(v1)) &&\n\t    (Integer.class.isInstance(v2) ||\n           String.class.isInstance(v2))) {\n\t    intCompare = true;\n      } else {\n\t    intCompare = false;\n\t}\n\tif (intCompare) {\n\t    try {\n\t\tint v1i = 0, v2i = 0;\n\t\tif (Integer.class.isInstance(v1)) {\n\t\t    v1i = ((Integer)v1).intValue();\n\t\t} else {\n\t\t    v1i = Integer.parseInt((String) v1);\n\t\t}\n\t\tif (Integer.class.isInstance(v2)) {\n\t\t    v2i = ((Integer)v2).intValue();\n\t\t} else {\n\t\t    v2i = Integer.parseInt((String) v2);\n\t\t}\n\t\tswitch (((Integer)compare).intValue()) {\n\t\tcase LESS_EQUAL:\n\t\t    return (v1i <= v2i);\n\n\t\tcase LESS_THAN:\n\t\t    return (v1i < v2i);\n\n\t\tcase EQUAL:\n\t\t    return (v1i == v2i);\n\n\t\tcase GREATER_THAN:\n\t\t    return (v1i > v2i);\n\n\t\tcase GREATER_EQUAL:\n\t\t    return (v1i >= v2i);\n\n\t\tcase NOT_EQUAL:\n\t\t    return (v1i != v2i);\n\t\t}\n\t    } catch (NumberFormatException ex) {};\n\t}\n\tString v1s = \"\", v2s = \"\";\n\n\tif (Integer.class.isInstance(v1)) {\n\t    v1s = ((Integer)v1).toString();\n\t} else {\n\t    v1s = (String) v1;\n\t}\n\n\tif (Integer.class.isInstance(v2)) {\n\t    v2s = ((Integer)v2).toString();\n\t} else {\n\t    v2s = (String) v2;\n\t}\n\n\tint res = v1s.compareTo(v2s);\n\tswitch (((Integer)compare).intValue()) {\n\tcase LESS_EQUAL:\n\t    return (res <= 0);\n\n\tcase LESS_THAN:\n\t    return (res < 0);\n\n\tcase EQUAL:\n\t    return (res == 0);\n\n\tcase GREATER_THAN:\n\t    return (res > 0);\n\n\tcase GREATER_EQUAL:\n\t    return (res >= 0);\n\n\tcase NOT_EQUAL:\n\t    return (res != 0);\n\t}\n\treturn true;\n    }\n",
        "start": 68,
        "end": 170,
        "fix": "    private  boolean evaluateComparison (Object v1, Object compare, Object v2) {\n        boolean intCompare = true;\n\tif ((v1 == null) || (v2 == null)) {\n\t\tif (String.class.isInstance(v1)) {\n\t\t\tif (((String) v1).trim().length() == 0) {\n\t\t\t\tv1 = null;\n\t\t\t}\n\t\t}\n\t\tif (String.class.isInstance(v2)) {\n\t\t\tif (((String) v2).trim().length() == 0) {\n\t\t\t\tv2 = null;\n\t\t\t}\n\t\t}\n\t\tswitch (((Integer)compare).intValue()) {\n\t\tcase LESS_EQUAL:\n\t\tcase GREATER_THAN:\n\t\tcase LESS_THAN:\n\t\tcase GREATER_EQUAL:\n\t\t\treturn false;\n\t\tcase EQUAL:\n\t\t    return (v1 == v2);\n\t\tcase NOT_EQUAL:\n\t\t    return (v1 != v2);\n\t\t}\n\t}\n      if ((Integer.class.isInstance(v1) ||\n           String.class.isInstance(v1)) &&\n\t    (Integer.class.isInstance(v2) ||\n           String.class.isInstance(v2))) {\n\t    intCompare = true;\n      } else {\n\t    intCompare = false;\n\t}\n\tif (intCompare) {\n\t    try {\n\t\tint v1i = 0, v2i = 0;\n\t\tif (Integer.class.isInstance(v1)) {\n\t\t    v1i = ((Integer)v1).intValue();\n\t\t} else {\n\t\t    v1i = Integer.parseInt((String) v1);\n\t\t}\n\t\tif (Integer.class.isInstance(v2)) {\n\t\t    v2i = ((Integer)v2).intValue();\n\t\t} else {\n\t\t    v2i = Integer.parseInt((String) v2);\n\t\t}\n\t\tswitch (((Integer)compare).intValue()) {\n\t\tcase LESS_EQUAL:\n\t\t    return (v1i <= v2i);\n\n\t\tcase LESS_THAN:\n\t\t    return (v1i < v2i);\n\n\t\tcase EQUAL:\n\t\t    return (v1i == v2i);\n\n\t\tcase GREATER_THAN:\n\t\t    return (v1i > v2i);\n\n\t\tcase GREATER_EQUAL:\n\t\t    return (v1i >= v2i);\n\n\t\tcase NOT_EQUAL:\n\t\t    return (v1i != v2i);\n\t\t}\n\t    } catch (NumberFormatException ex) {};\n\t}\n\tString v1s = \"\", v2s = \"\";\n\n\tif (Integer.class.isInstance(v1)) {\n\t    v1s = ((Integer)v1).toString();\n\t} else {\n\t    v1s = (String) v1;\n\t}\n\n\tif (Integer.class.isInstance(v2)) {\n\t    v2s = ((Integer)v2).toString();\n\t} else {\n\t    v2s = (String) v2;\n\t}\n\n\tint res = v1s.compareTo(v2s);\n\tswitch (((Integer)compare).intValue()) {\n\tcase LESS_EQUAL:\n\t    return (res <= 0);\n\n\tcase LESS_THAN:\n\t    return (res < 0);\n\n\tcase EQUAL:\n\t    return (res == 0);\n\n\tcase GREATER_THAN:\n\t    return (res > 0);\n\n\tcase GREATER_EQUAL:\n\t    return (res >= 0);\n\n\tcase NOT_EQUAL:\n\t    return (res != 0);\n\t}\n\treturn true;\n    }\n"
    },
    "Wicket_core-2": {
        "buggy": "\t\t@Override\n\t\tpublic void component(final FormComponent<?> formComponent, final IVisit<Void> visit)\n\t\t{\n\n\t\t\tForm<?> form = formComponent.getForm();\n\t\t\tif (!form.isVisibleInHierarchy() || !form.isEnabledInHierarchy())\n\t\t\t{\n\t\t\t\t// do not validate formComponent or any of formComponent's children\n\t\t\t\tvisit.dontGoDeeper();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (formComponent.isVisibleInHierarchy() && formComponent.isValid() &&\n\t\t\t\tformComponent.isEnabledInHierarchy())\n\t\t\t{\n\t\t\t\tvalidate(formComponent);\n\t\t\t}\n\t\t\tif (formComponent.processChildren() == false)\n\t\t\t{\n\t\t\t\tvisit.dontGoDeeper();\n\t\t\t}\n\t\t}\n",
        "start": 161,
        "end": 182,
        "fix": "\t\t@Override\n\t\tpublic void component(final FormComponent<?> formComponent, final IVisit<Void> visit)\n\t\t{\n\n\t\t\tForm<?> form = formComponent.getForm();\n\t\t\tif (!form.isVisibleInHierarchy() || !form.isEnabledInHierarchy())\n\t\t\t{\n\t\t\t\t// do not validate formComponent or any of formComponent's children\n\t\t\t\tvisit.dontGoDeeper();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (formComponent.isVisibleInHierarchy() && formComponent.isEnabledInHierarchy())\n\t\t\t{\n\t\t\t\tvalidate(formComponent);\n\t\t\t}\n\t\t\tif (formComponent.processChildren() == false)\n\t\t\t{\n\t\t\t\tvisit.dontGoDeeper();\n\t\t\t}\n\t\t}\n"
    },
    "Wicket_core-3": {
        "buggy": "\t/**\n\t * Removes javascript comments and whitespace from specified string.\n\t *\n\t * @param original\n\t *            Source string\n\t * @return String with removed comments and whitespace\n\t */\n\tpublic String stripCommentsAndWhitespace(String original)\n\t{\n\t\t// let's be optimistic\n\t\tAppendingStringBuffer result = new AppendingStringBuffer(original.length() / 2);\n\t\tint state = REGULAR_TEXT;\n\t\tboolean wasNewLineInWhitespace = false;\n\n\t\tfor (int i = 0; i < original.length(); ++i)\n\t\t{\n\t\t\tchar c = original.charAt(i);\n\t\t\tchar next = (i < original.length() - 1) ? original.charAt(i + 1) : 0;\n\t\t\tchar prev = (i > 0) ? original.charAt(i - 1) : 0;\n\n\t\t\tif (state == WHITE_SPACE)\n\t\t\t{\n\t\t\t\t// WICKET 2060\n\t\t\t\tif (c == '\\n' && !wasNewLineInWhitespace)\n\t\t\t\t{\n\t\t\t\t\tresult.append(\"\\n\");\n\t\t\t\t\twasNewLineInWhitespace = true;\n\t\t\t\t}\n\t\t\t\tif (Character.isWhitespace(next) == false)\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (state == REGULAR_TEXT)\n\t\t\t{\n\t\t\t\tif (c == '/' && next == '/' && prev != '\\\\')\n\t\t\t\t{\n\t\t\t\t\tstate = LINE_COMMENT;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (c == '/' && next == '*')\n\t\t\t\t{\n\t\t\t\t\tstate = MULTILINE_COMMENT;\n\t\t\t\t\t++i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (c == '/')\n\t\t\t\t{\n\t\t\t\t\t// This might be a divide operator, or it might be a regular expression.\n\t\t\t\t\t// Work out if it's a regular expression by finding the previous non-whitespace\n\t\t\t\t\t// char, which\n\t\t\t\t\t// will be either '=' or '('. If it's not, it's just a divide operator.\n\t\t\t\t\tint idx = result.length() - 1;\n\t\t\t\t\twhile (idx > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar tmp = result.charAt(idx);\n\t\t\t\t\t\tif (Character.isWhitespace(tmp))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tidx--;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tmp == '=' || tmp == '(' || tmp == '{' || tmp == ':' || tmp == ',' ||\n\t\t\t\t\t\t\ttmp == '[' || tmp == ';' || tmp == '!')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstate = REG_EXP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (Character.isWhitespace(c) && Character.isWhitespace(next))\n\t\t\t\t{\n\t\t\t\t\t// WICKET-2060\n\t\t\t\t\tif (c == '\\n' || next == '\\n')\n\t\t\t\t\t{\n\t\t\t\t\t\tc = '\\n';\n\t\t\t\t\t\twasNewLineInWhitespace = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tc = ' ';\n\t\t\t\t\t\twasNewLineInWhitespace = false;\n\t\t\t\t\t}\n\t\t\t\t\t// ignore all whitespace characters after this one\n\t\t\t\t\tstate = WHITE_SPACE;\n\t\t\t\t}\n\t\t\t\telse if (c == '\\'')\n\t\t\t\t{\n\t\t\t\t\tstate = STRING_SINGLE_QUOTE;\n\t\t\t\t}\n\t\t\t\telse if (c == '\"')\n\t\t\t\t{\n\t\t\t\t\tstate = STRING_DOUBLE_QUOTES;\n\t\t\t\t}\n\t\t\t\tresult.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (state == LINE_COMMENT)\n\t\t\t{\n\t\t\t\tif (c == '\\n' || c == '\\r')\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state == MULTILINE_COMMENT)\n\t\t\t{\n\t\t\t\tif (c == '*' && next == '/')\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t\t++i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state == STRING_SINGLE_QUOTE)\n\t\t\t{\n\t\t\t\t// to leave a string expression we need even (or zero) number of backslashes\n\t\t\t\tint count = getPrevCount(original, i, '\\\\');\n\t\t\t\tif (c == '\\'' && count % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t}\n\t\t\t\tresult.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (state == STRING_DOUBLE_QUOTES)\n\t\t\t{\n\t\t\t\t// to leave a string expression we need even (or zero) number of backslashes\n\t\t\t\tint count = getPrevCount(original, i, '\\\\');\n\t\t\t\tif (c == '\"' && count % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t}\n\t\t\t\tresult.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (state == REG_EXP)\n\t\t\t{\n\t\t\t\t// to leave regular expression we need even (or zero) number of backslashes\n\t\t\t\tint count = getPrevCount(original, i, '\\\\');\n\t\t\t\tif (c == '/' && count % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t}\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n",
        "start": 71,
        "end": 227,
        "fix": "\t/**\n\t * Removes javascript comments and whitespace from specified string.\n\t *\n\t * @param original\n\t *            Source string\n\t * @return String with removed comments and whitespace\n\t */\n\tpublic String stripCommentsAndWhitespace(String original)\n\t{\n\t\t// let's be optimistic\n\t\tAppendingStringBuffer result = new AppendingStringBuffer(original.length() / 2);\n\t\tint state = REGULAR_TEXT;\n\t\tboolean wasNewLineInWhitespace = false;\n\n\t\tfor (int i = 0; i < original.length(); ++i)\n\t\t{\n\t\t\tchar c = original.charAt(i);\n\t\t\tchar next = (i < original.length() - 1) ? original.charAt(i + 1) : 0;\n\t\t\tchar prev = (i > 0) ? original.charAt(i - 1) : 0;\n\n\t\t\tif (state == WHITE_SPACE)\n\t\t\t{\n\t\t\t\t// WICKET 2060\n\t\t\t\tif (c == '\\n' && !wasNewLineInWhitespace)\n\t\t\t\t{\n\t\t\t\t\tresult.append(\"\\n\");\n\t\t\t\t\twasNewLineInWhitespace = true;\n\t\t\t\t}\n\t\t\t\tif (Character.isWhitespace(next) == false)\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (state == REGULAR_TEXT)\n\t\t\t{\n\t\t\t\tif (c == '/' && next == '/' && prev != '\\\\')\n\t\t\t\t{\n\t\t\t\t\tstate = LINE_COMMENT;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (c == '/' && next == '*')\n\t\t\t\t{\n\t\t\t\t\tstate = MULTILINE_COMMENT;\n\t\t\t\t\t++i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (c == '/')\n\t\t\t\t{\n\t\t\t\t\t// This might be a divide operator, or it might be a regular expression.\n\t\t\t\t\t// Work out if it's a regular expression by finding the previous non-whitespace\n\t\t\t\t\t// char, which\n\t\t\t\t\t// will be either '=' or '('. If it's not, it's just a divide operator.\n\t\t\t\t\tint idx = result.length() - 1;\n\t\t\t\t\twhile (idx > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar tmp = result.charAt(idx);\n\t\t\t\t\t\tif (Character.isWhitespace(tmp))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tidx--;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tmp == '=' || tmp == '(' || tmp == '{' || tmp == ':' || tmp == ',' ||\n\t\t\t\t\t\t\ttmp == '[' || tmp == ';' || tmp == '!')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstate = REG_EXP;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (Character.isWhitespace(c) && Character.isWhitespace(next))\n\t\t\t\t{\n\t\t\t\t\t// WICKET-2060\n\t\t\t\t\tif (c == '\\n' || next == '\\n')\n\t\t\t\t\t{\n\t\t\t\t\t\tc = '\\n';\n\t\t\t\t\t\twasNewLineInWhitespace = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tc = ' ';\n\t\t\t\t\t\twasNewLineInWhitespace = false;\n\t\t\t\t\t}\n\t\t\t\t\t// ignore all whitespace characters after this one\n\t\t\t\t\tstate = WHITE_SPACE;\n\t\t\t\t}\n\t\t\t\telse if (c == '\\'')\n\t\t\t\t{\n\t\t\t\t\tstate = STRING_SINGLE_QUOTE;\n\t\t\t\t}\n\t\t\t\telse if (c == '\"')\n\t\t\t\t{\n\t\t\t\t\tstate = STRING_DOUBLE_QUOTES;\n\t\t\t\t}\n\t\t\t\tresult.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (state == LINE_COMMENT)\n\t\t\t{\n\t\t\t\tif (c == '\\n' || c == '\\r')\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t\tresult.append(c);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state == MULTILINE_COMMENT)\n\t\t\t{\n\t\t\t\tif (c == '*' && next == '/')\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t\t++i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state == STRING_SINGLE_QUOTE)\n\t\t\t{\n\t\t\t\t// to leave a string expression we need even (or zero) number of backslashes\n\t\t\t\tint count = getPrevCount(original, i, '\\\\');\n\t\t\t\tif (c == '\\'' && count % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t}\n\t\t\t\tresult.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (state == STRING_DOUBLE_QUOTES)\n\t\t\t{\n\t\t\t\t// to leave a string expression we need even (or zero) number of backslashes\n\t\t\t\tint count = getPrevCount(original, i, '\\\\');\n\t\t\t\tif (c == '\"' && count % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t}\n\t\t\t\tresult.append(c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (state == REG_EXP)\n\t\t\t{\n\t\t\t\t// to leave regular expression we need even (or zero) number of backslashes\n\t\t\t\tint count = getPrevCount(original, i, '\\\\');\n\t\t\t\tif (c == '/' && count % 2 == 0)\n\t\t\t\t{\n\t\t\t\t\tstate = REGULAR_TEXT;\n\t\t\t\t}\n\t\t\t\tresult.append(c);\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n"
    },
    "Wicket_core-5": {
        "buggy": "\t/**\n\t * Creates a url for the handler. Modifies it with the correct {@link Scheme} if necessary.\n\t * \n\t * @param handler\n\t * @param request\n\t * @return url\n\t */\n\tfinal Url mapHandler(IRequestHandler handler, Request request)\n\t{\n\t\tUrl url = delegate.mapHandler(handler);\n\n\t\tScheme desired = getDesiredSchemeFor(handler);\n\t\tScheme current = getSchemeOf(request);\n\t\tif (!desired.isCompatibleWith(current))\n\t\t{\n\t\t\t// the generated url does not have the correct scheme, set it (which in turn will cause\n\t\t\t// the url to be rendered in its full representation)\n\t\t\turl.setProtocol(desired.urlName());\n\t\t\tif (url.getPort() != null || !desired.usesStandardPort(config))\n\t\t\t{\n\t\t\turl.setPort(desired.getPort(config));\n\t\t\t}\n\t\t}\n\t\treturn url;\n\t}\n",
        "start": 155,
        "end": 179,
        "fix": "\t/**\n\t * Creates a url for the handler. Modifies it with the correct {@link Scheme} if necessary.\n\t * \n\t * @param handler\n\t * @param request\n\t * @return url\n\t */\n\tfinal Url mapHandler(IRequestHandler handler, Request request)\n\t{\n\t\tUrl url = delegate.mapHandler(handler);\n\n\t\tScheme desired = getDesiredSchemeFor(handler);\n\t\tScheme current = getSchemeOf(request);\n\t\tif (!desired.isCompatibleWith(current))\n\t\t{\n\t\t\t// the generated url does not have the correct scheme, set it (which in turn will cause\n\t\t\t// the url to be rendered in its full representation)\n\t\t\turl.setProtocol(desired.urlName());\n\t\t\turl.setPort(desired.getPort(config));\n\t\t}\n\t\treturn url;\n\t}\n"
    },
    "Wicket_core-6": {
        "buggy": "\tprivate Url decryptUrl(final Request request, final Url encryptedUrl)\n\t{\n\t\t/*\n\t\t * If the encrypted URL has no segments it is the home page URL,\n\t\t * and does not need decrypting.\n\t\t */\n\t\tif (encryptedUrl.getSegments().isEmpty())\n\t\t{\n\t\t\treturn encryptedUrl;\n\t\t}\n\n\t\tList<String> encryptedSegments = encryptedUrl.getSegments();\n\n\t\tUrl url = new Url(request.getCharset());\n\t\ttry\n\t\t{\n\t\t\t/*\n\t\t\t * The first encrypted segment contains an encrypted version of the\n\t\t\t * entire plain text url.\n\t\t\t */\n\t\t\tString encryptedUrlString = encryptedSegments.get(0);\n\t\t\tif (Strings.isEmpty(encryptedUrlString))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tString decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\n\t\t\tif (decryptedUrl == null)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tUrl originalUrl = Url.parse(decryptedUrl, request.getCharset());\n\n\t\t\tint originalNumberOfSegments = originalUrl.getSegments().size();\n\t\t\tint encryptedNumberOfSegments = encryptedUrl.getSegments().size();\n\n\t\t\tHashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\n\t\t\tint segNo = 1;\n\t\t\tfor (; segNo < encryptedNumberOfSegments; segNo++)\n\t\t\t{\n\t\t\t\tif (segNo > originalNumberOfSegments)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tString next = generator.next();\n\t\t\t\tString encryptedSegment = encryptedSegments.get(segNo);\n\t\t\t\tif (!next.equals(encryptedSegment))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * This segment received from the browser is not the same as the\n\t\t\t\t\t * expected segment generated by the HashSegmentGenerator. Hence it,\n\t\t\t\t\t * and all subsequent segments are considered plain text siblings of the\n\t\t\t\t\t * original encrypted url.\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * This segments matches the expected checksum, so we add the corresponding\n\t\t\t\t * segment from the original URL.\n\t\t\t\t */\n\t\t\t\turl.getSegments().add(originalUrl.getSegments().get(segNo - 1));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Add all remaining segments from the encrypted url as plain text segments.\n\t\t\t */\n\t\t\tfor (; segNo < encryptedNumberOfSegments; segNo++)\n\t\t\t{\n\t\t\t\t// modified or additional segment\n\t\t\t\turl.getSegments().add(encryptedUrl.getSegments().get(segNo));\n\t\t\t}\n\n\t\t\turl.getQueryParameters().addAll(originalUrl.getQueryParameters());\n\t\t\t// WICKET-4923 additional parameters\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.error(\"Error decrypting URL\", e);\n\t\t\turl = null;\n\t\t}\n\n\t\treturn url;\n\t}\n",
        "start": 163,
        "end": 246,
        "fix": "\tprivate Url decryptUrl(final Request request, final Url encryptedUrl)\n\t{\n\t\t/*\n\t\t * If the encrypted URL has no segments it is the home page URL,\n\t\t * and does not need decrypting.\n\t\t */\n\t\tif (encryptedUrl.getSegments().isEmpty())\n\t\t{\n\t\t\treturn encryptedUrl;\n\t\t}\n\n\t\tList<String> encryptedSegments = encryptedUrl.getSegments();\n\n\t\tUrl url = new Url(request.getCharset());\n\t\ttry\n\t\t{\n\t\t\t/*\n\t\t\t * The first encrypted segment contains an encrypted version of the\n\t\t\t * entire plain text url.\n\t\t\t */\n\t\t\tString encryptedUrlString = encryptedSegments.get(0);\n\t\t\tif (Strings.isEmpty(encryptedUrlString))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tString decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\n\t\t\tif (decryptedUrl == null)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tUrl originalUrl = Url.parse(decryptedUrl, request.getCharset());\n\n\t\t\tint originalNumberOfSegments = originalUrl.getSegments().size();\n\t\t\tint encryptedNumberOfSegments = encryptedUrl.getSegments().size();\n\n\t\t\tHashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\n\t\t\tint segNo = 1;\n\t\t\tfor (; segNo < encryptedNumberOfSegments; segNo++)\n\t\t\t{\n\t\t\t\tif (segNo > originalNumberOfSegments)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tString next = generator.next();\n\t\t\t\tString encryptedSegment = encryptedSegments.get(segNo);\n\t\t\t\tif (!next.equals(encryptedSegment))\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * This segment received from the browser is not the same as the\n\t\t\t\t\t * expected segment generated by the HashSegmentGenerator. Hence it,\n\t\t\t\t\t * and all subsequent segments are considered plain text siblings of the\n\t\t\t\t\t * original encrypted url.\n\t\t\t\t\t */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * This segments matches the expected checksum, so we add the corresponding\n\t\t\t\t * segment from the original URL.\n\t\t\t\t */\n\t\t\t\turl.getSegments().add(originalUrl.getSegments().get(segNo - 1));\n\t\t\t}\n\t\t\t/*\n\t\t\t * Add all remaining segments from the encrypted url as plain text segments.\n\t\t\t */\n\t\t\tfor (; segNo < encryptedNumberOfSegments; segNo++)\n\t\t\t{\n\t\t\t\t// modified or additional segment\n\t\t\t\turl.getSegments().add(encryptedUrl.getSegments().get(segNo));\n\t\t\t}\n\n\t\t\turl.getQueryParameters().addAll(originalUrl.getQueryParameters());\n\t\t\t// WICKET-4923 additional parameters\n\t\t\turl.getQueryParameters().addAll(encryptedUrl.getQueryParameters());\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.error(\"Error decrypting URL\", e);\n\t\t\turl = null;\n\t\t}\n\n\t\treturn url;\n\t}\n"
    },
    "Wicket_core-7": {
        "buggy": "\t/**\n\t * Initializes the cache for the existence of the minified resource.\n\t * @return the name of the minified resource or the special constant {@link #NO_MINIFIED_NAME}\n\t * if there is no minified version\n\t */\n\tprivate String internalGetMinifiedName()\n\t{\n\t\tString minifiedName = MINIFIED_NAMES_CACHE.get(this);\n\t\tif (minifiedName != null && minifiedName != NO_MINIFIED_NAME)\n\t\t{\n\t\t\treturn minifiedName;\n\t\t}\n\n\t\tString name = getMinifiedName();\n\t\tIResourceStreamLocator locator = Application.get()\n\t\t\t\t.getResourceSettings()\n\t\t\t\t.getResourceStreamLocator();\n\t\tString absolutePath = Packages.absolutePath(getScope(), name);\n\t\tIResourceStream stream = locator.locate(getScope(), absolutePath, getStyle(),\n\t\t\t\tgetVariation(), getLocale(), null, true);\n\n\t\tminifiedName = stream != null ? name : NO_MINIFIED_NAME;\n\t\tMINIFIED_NAMES_CACHE.put(this, minifiedName);\n\t\tif (minifiedName == NO_MINIFIED_NAME && log.isDebugEnabled())\n\t\t{\n\t\t\tlog.debug(\"No minified version of '\" + super.getName() +\n\t\t\t\t\t\"' found, expected a file with the name '\" + name + \"', using full version\");\n\t\t}\n\t\treturn minifiedName;\n\t}\n",
        "start": 168,
        "end": 197,
        "fix": "\t/**\n\t * Initializes the cache for the existence of the minified resource.\n\t * @return the name of the minified resource or the special constant {@link #NO_MINIFIED_NAME}\n\t * if there is no minified version\n\t */\n\tprivate String internalGetMinifiedName()\n\t{\n\t\tString minifiedName = MINIFIED_NAMES_CACHE.get(this);\n\t\tif (minifiedName != null)\n\t\t{\n\t\t\treturn minifiedName;\n\t\t}\n\n\t\tString name = getMinifiedName();\n\t\tIResourceStreamLocator locator = Application.get()\n\t\t\t\t.getResourceSettings()\n\t\t\t\t.getResourceStreamLocator();\n\t\tString absolutePath = Packages.absolutePath(getScope(), name);\n\t\tIResourceStream stream = locator.locate(getScope(), absolutePath, getStyle(),\n\t\t\t\tgetVariation(), getLocale(), null, true);\n\n\t\tminifiedName = stream != null ? name : NO_MINIFIED_NAME;\n\t\tMINIFIED_NAMES_CACHE.put(this, minifiedName);\n\t\tif (minifiedName == NO_MINIFIED_NAME && log.isDebugEnabled())\n\t\t{\n\t\t\tlog.debug(\"No minified version of '\" + super.getName() +\n\t\t\t\t\t\"' found, expected a file with the name '\" + name + \"', using full version\");\n\t\t}\n\t\treturn minifiedName;\n\t}\n"
    },
    "Wicket_core-9": {
        "buggy": "\t/**\n\t * Creates a {@code IRequestHandler} that processes a listener request.\n\t * \n\t * @param pageComponentInfo\n\t * @param pageClass\n\t * @param pageParameters\n\t * @return a {@code IRequestHandler} that invokes the listener interface\n\t */\n\tprotected IRequestHandler processListener(PageComponentInfo pageComponentInfo,\n\t\tClass<? extends IRequestablePage> pageClass, PageParameters pageParameters)\n\t{\n\t\tPageInfo pageInfo = pageComponentInfo.getPageInfo();\n\t\tComponentInfo componentInfo = pageComponentInfo.getComponentInfo();\n\t\tInteger renderCount = null;\n\t\tRequestListenerInterface listenerInterface = null;\n\n\t\tif (componentInfo != null)\n\t\t{\n\t\t\trenderCount = componentInfo.getRenderCount();\n\t\t\tlistenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\n\t\t}\n\n\t\tif (listenerInterface != null)\n\t\t{\n\t\t\t\t// WICKET-4594 - ignore the parsed parameters for stateful pages\n\n\t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(),\n\t\t\t\tpageClass, null, renderCount, componentInfo.getComponentPath());\n\n\t\t\tprovider.setPageSource(getContext());\n\n\t\t\treturn new ListenerInterfaceRequestHandler(provider, listenerInterface,\n\t\t\t\tcomponentInfo.getBehaviorId());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (logger.isWarnEnabled())\n\t\t\t{\n\t\t\t\tif (componentInfo != null)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(\"Unknown listener interface '{}'\",\n\t\t\t\t\t\tcomponentInfo.getListenerInterface());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(\"Cannot extract the listener interface for PageComponentInfo: '{}'\" +\n\t\t\t\t\t\tpageComponentInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n",
        "start": 225,
        "end": 276,
        "fix": "\t/**\n\t * Creates a {@code IRequestHandler} that processes a listener request.\n\t * \n\t * @param pageComponentInfo\n\t * @param pageClass\n\t * @param pageParameters\n\t * @return a {@code IRequestHandler} that invokes the listener interface\n\t */\n\tprotected IRequestHandler processListener(PageComponentInfo pageComponentInfo,\n\t\tClass<? extends IRequestablePage> pageClass, PageParameters pageParameters)\n\t{\n\t\tPageInfo pageInfo = pageComponentInfo.getPageInfo();\n\t\tComponentInfo componentInfo = pageComponentInfo.getComponentInfo();\n\t\tInteger renderCount = null;\n\t\tRequestListenerInterface listenerInterface = null;\n\n\t\tif (componentInfo != null)\n\t\t{\n\t\t\trenderCount = componentInfo.getRenderCount();\n\t\t\tlistenerInterface = requestListenerInterfaceFromString(componentInfo.getListenerInterface());\n\t\t}\n\n\t\tif (listenerInterface != null)\n\t\t{\n\t\t\tif (pageInfo.getPageId() != null)\n\t\t\t{\n\t\t\t\t// WICKET-4594 - ignore the parsed parameters for stateful pages\n\t\t\t\tpageParameters = null;\n\t\t\t}\n\n\t\t\tPageAndComponentProvider provider = new PageAndComponentProvider(pageInfo.getPageId(),\n\t\t\t\tpageClass, pageParameters, renderCount, componentInfo.getComponentPath());\n\n\t\t\tprovider.setPageSource(getContext());\n\n\t\t\treturn new ListenerInterfaceRequestHandler(provider, listenerInterface,\n\t\t\t\tcomponentInfo.getBehaviorId());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (logger.isWarnEnabled())\n\t\t\t{\n\t\t\t\tif (componentInfo != null)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(\"Unknown listener interface '{}'\",\n\t\t\t\t\t\tcomponentInfo.getListenerInterface());\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(\"Cannot extract the listener interface for PageComponentInfo: '{}'\" +\n\t\t\t\t\t\tpageComponentInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n"
    },
    "Wicket_core-10": {
        "buggy": "\t/**\n\t * Gets whether the page is stateless. Components on stateless page must not render any stateful\n\t * urls, and components on stateful page must not render any stateless urls. Stateful urls are\n\t * urls, which refer to a certain (current) page instance.\n\t * \n\t * @return Whether this page is stateless\n\t */\n\t@Override\n\tpublic final boolean isPageStateless()\n\t{\n\t\tif (isBookmarkable() == false)\n\t\t{\n\t\t\tstateless = Boolean.FALSE;\n\t\t\tif (getStatelessHint())\n\t\t\t{\n\t\t\t\tlog.warn(\"Page '\" + this + \"' is not stateless because it is not bookmarkable, \" +\n\t\t\t\t\t\"but the stateless hint is set to true!\");\n\t\t\t}\n\t\t}\n\n\t\tif (getStatelessHint() == false)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (stateless == null)\n\t\t{\n\n\t\t\tif (isStateless() == false)\n\t\t\t{\n\t\t\t\tstateless = Boolean.FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (stateless == null)\n\t\t{\n\t\t\tComponent statefulComponent = visitChildren(Component.class,\n\t\t\t\tnew IVisitor<Component, Component>()\n\t\t\t\t{\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void component(final Component component, final IVisit<Component> visit)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!component.isStateless())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvisit.stop(component);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tstateless = statefulComponent == null;\n\n\t\t\tif (log.isDebugEnabled() && !stateless.booleanValue() && getStatelessHint())\n\t\t\t{\n\t\t\t\tlog.debug(\"Page '{}' is not stateless because of component with path '{}'.\", this,\n\t\t\t\t\tstatefulComponent.getPageRelativePath());\n\t\t\t}\n\n\t\t}\n\n\t\treturn stateless;\n\t}\n",
        "start": 426,
        "end": 486,
        "fix": "\t/**\n\t * Gets whether the page is stateless. Components on stateless page must not render any stateful\n\t * urls, and components on stateful page must not render any stateless urls. Stateful urls are\n\t * urls, which refer to a certain (current) page instance.\n\t * \n\t * @return Whether this page is stateless\n\t */\n\t@Override\n\tpublic final boolean isPageStateless()\n\t{\n\t\tif (isBookmarkable() == false)\n\t\t{\n\t\t\tstateless = Boolean.FALSE;\n\t\t\tif (getStatelessHint())\n\t\t\t{\n\t\t\t\tlog.warn(\"Page '\" + this + \"' is not stateless because it is not bookmarkable, \" +\n\t\t\t\t\t\"but the stateless hint is set to true!\");\n\t\t\t}\n\t\t}\n\n\t\tif (getStatelessHint() == false)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (stateless == null)\n\t\t{\n\t\t\tinternalInitialize();\n\n\t\t\tif (isStateless() == false)\n\t\t\t{\n\t\t\t\tstateless = Boolean.FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (stateless == null)\n\t\t{\n\t\t\tComponent statefulComponent = visitChildren(Component.class,\n\t\t\t\tnew IVisitor<Component, Component>()\n\t\t\t\t{\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void component(final Component component, final IVisit<Component> visit)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!component.isStateless())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvisit.stop(component);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tstateless = statefulComponent == null;\n\n\t\t\tif (log.isDebugEnabled() && !stateless.booleanValue() && getStatelessHint())\n\t\t\t{\n\t\t\t\tlog.debug(\"Page '{}' is not stateless because of component with path '{}'.\", this,\n\t\t\t\t\tstatefulComponent.getPageRelativePath());\n\t\t\t}\n\n\t\t}\n\n\t\treturn stateless;\n\t}\n"
    },
    "Wicket_core-12": {
        "buggy": "\t/**\n\t * Dequeues components. The default implementation iterates direct children of this container\n\t * found in its markup and tries to find matching\n\t * components in queues filled by a call to {@link #queue(Component...)}. It then delegates the\n\t * dequeueing to these children.\n\t * \n\t * The provided {@link DequeueContext} is used to maintain the place in markup as well as the\n\t * stack of components whose queues will be searched. For example, before delegating the call to\n\t * a child the container will push the child onto the stack of components.\n\t * \n\t * Certain components that implement custom markup behaviors (such as repeaters and borders)\n\t * override this method to bring dequeueing in line with their custom markup handling.\n\t * \n\t * @param dequeue\n\t */\n\tpublic void dequeue(DequeueContext dequeue)\n\t{\n\t\twhile (dequeue.isAtOpenOrOpenCloseTag())\n\t\t{\n\t\t\tComponentTag tag = dequeue.takeTag();\n\t\n\t\t\t// see if child is already added to parent\n\n\t\t\tComponent child = get(tag.getId());\n\n\t\t\tif (child == null)\n\t\t\t{\n\t\t\t\t// the container does not yet have a child with this id, see if we can\n\t\t\t\t// dequeue\n\t\t\t\t\n\t\t\t\tchild = dequeue.findComponentToDequeue(tag);\n\n\t\t\t\tif (child != null)\n\t\t\t\t{\n\t\t\t\t\taddDequeuedComponent(child, tag);\n\t\t\t\t\tif (child instanceof IQueueRegion)\n\t\t\t\t\t{\n\t\t\t\t\t\t((MarkupContainer)child).dequeue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (child == null || !(child instanceof MarkupContainer))\n\t\t\t{\n\t\t\t\t// could not dequeue, or does not contain children\n\t\n\t\t\t\tif (tag.isOpen())\n\t\t\t\t{\n\t\t\t\t\tdequeue.skipToCloseTag();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMarkupContainer container = (MarkupContainer)child;\n\t\t\t\tif (container instanceof IQueueRegion)\n\t\t\t\t{\n\t\t\t\t\t// if this is a dequeue container we do not process its markup, it will do so\n\t\t\t\t\t// itself when it is dequeued for the first time\n\t\t\t\t\tif (tag.isOpen())\n\t\t\t\t\t{\n\t\t\t\t\t\tdequeue.skipToCloseTag();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (tag.isOpen())\n\t\t\t\t{\n\t\t\t\t\t// this component has more markup and possibly more children to dequeue\n\t\t\t\t\tdequeue.pushContainer(container);\n\t\t\t\t\tcontainer.dequeue(dequeue);\n\t\t\t\t\tdequeue.popContainer();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tag.isOpen() && !tag.hasNoCloseTag())\n\t\t\t{\n\t\t\t\t// pull the close tag off\n\t\t\t\tComponentTag close = dequeue.takeTag();\n\t\t\t\tif (!close.closes(tag))\n\t\t\t\t{\n\t\t\t\t\t// sanity check\n\t\t\t\t\tthrow new IllegalStateException(String.format(\"Tag '%s' should be the closing one for '%s'\", close, tag));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n",
        "start": 2054,
        "end": 2137,
        "fix": "\t/**\n\t * Dequeues components. The default implementation iterates direct children of this container\n\t * found in its markup and tries to find matching\n\t * components in queues filled by a call to {@link #queue(Component...)}. It then delegates the\n\t * dequeueing to these children.\n\t * \n\t * The provided {@link DequeueContext} is used to maintain the place in markup as well as the\n\t * stack of components whose queues will be searched. For example, before delegating the call to\n\t * a child the container will push the child onto the stack of components.\n\t * \n\t * Certain components that implement custom markup behaviors (such as repeaters and borders)\n\t * override this method to bring dequeueing in line with their custom markup handling.\n\t * \n\t * @param dequeue\n\t */\n\tpublic void dequeue(DequeueContext dequeue)\n\t{\n\t\twhile (dequeue.isAtOpenOrOpenCloseTag())\n\t\t{\n\t\t\tComponentTag tag = dequeue.takeTag();\n\t\n\t\t\t// see if child is already added to parent\n\n\t\t\tComponent child = get(tag.getId());\n\n\t\t\tif (child == null)\n\t\t\t{\n\t\t\t\t// the container does not yet have a child with this id, see if we can\n\t\t\t\t// dequeue\n\t\t\t\t\n\t\t\t\tchild = dequeue.findComponentToDequeue(tag);\n\n\t\t\t\tif (child != null)\n\t\t\t\t{\n\t\t\t\t\taddDequeuedComponent(child, tag);\n\t\t\t\t\tif (child instanceof IQueueRegion)\n\t\t\t\t\t{\n\t\t\t\t\t\t((MarkupContainer)child).dequeue();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (child == null || !(child instanceof MarkupContainer))\n\t\t\t{\n\t\t\t\t// could not dequeue, or does not contain children\n\t\n\t\t\t\tif (tag.isOpen() && !tag.hasNoCloseTag())\n\t\t\t\t{\n\t\t\t\t\tdequeue.skipToCloseTag();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMarkupContainer container = (MarkupContainer)child;\n\t\t\t\tif (container instanceof IQueueRegion)\n\t\t\t\t{\n\t\t\t\t\t// if this is a dequeue container we do not process its markup, it will do so\n\t\t\t\t\t// itself when it is dequeued for the first time\n\t\t\t\t\tif (tag.isOpen())\n\t\t\t\t\t{\n\t\t\t\t\t\tdequeue.skipToCloseTag();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (tag.isOpen())\n\t\t\t\t{\n\t\t\t\t\t// this component has more markup and possibly more children to dequeue\n\t\t\t\t\tdequeue.pushContainer(container);\n\t\t\t\t\tcontainer.dequeue(dequeue);\n\t\t\t\t\tdequeue.popContainer();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tag.isOpen() && !tag.hasNoCloseTag())\n\t\t\t{\n\t\t\t\t// pull the close tag off\n\t\t\t\tComponentTag close = dequeue.takeTag();\n\t\t\t\tif (!close.closes(tag))\n\t\t\t\t{\n\t\t\t\t\t// sanity check\n\t\t\t\t\tthrow new IllegalStateException(String.format(\"Tag '%s' should be the closing one for '%s'\", close, tag));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n"
    },
    "Wicket_core-13": {
        "buggy": "\t/**\n\t * Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified\n\t * by {@code pageInfo} was not available, the request should be treated as a bookmarkable\n\t * request.\n\t * \n\t * @param pageInfo\n\t * @param pageClass\n\t * @param pageParameters\n\t * @param renderCount\n\t * @return a {@code IRequestHandler} capable of processing the hybrid request.\n\t */\n\tprotected IRequestHandler processHybrid(PageInfo pageInfo,\n\t\tClass<? extends IRequestablePage> pageClass, PageParameters pageParameters,\n\t\tInteger renderCount)\n\t{\n\t\tPageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters,\n\t\t\trenderCount);\n\t\tprovider.setPageSource(getContext());\n\t\tif (provider.isNewPageInstance() && !getRecreateMountedPagesAfterExpiry())\n\t\t{\n\t\t\tthrow new PageExpiredException(String.format(\"Bookmarkable page id '%d' has expired.\",\n\t\t\t\tpageInfo.getPageId()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/** \n\t\t\t * https://issues.apache.org/jira/browse/WICKET-5734\n\t\t\t * */\n\n\t\t\tPageParameters constructionPageParameters = provider.getPageInstance().getPageParameters();\n\t\t\tif (PageParameters.equals(constructionPageParameters, pageParameters) == false)\n\t\t\t{\n\t\t\t\t// create a fresh page instance because the request page parameters are different than the ones\n\t\t\t\t// when the resolved page by id has been created\n\t\t\t\treturn new RenderPageRequestHandler(new PageProvider(pageClass, pageParameters));\n\t\t\t}\n\t\t\treturn new RenderPageRequestHandler(provider);\n\t\t}\n\t}\n",
        "start": 243,
        "end": 281,
        "fix": "\t/**\n\t * Creates a {@code IRequestHandler} that processes a hybrid request. When the page identified\n\t * by {@code pageInfo} was not available, the request should be treated as a bookmarkable\n\t * request.\n\t * \n\t * @param pageInfo\n\t * @param pageClass\n\t * @param pageParameters\n\t * @param renderCount\n\t * @return a {@code IRequestHandler} capable of processing the hybrid request.\n\t */\n\tprotected IRequestHandler processHybrid(PageInfo pageInfo,\n\t\tClass<? extends IRequestablePage> pageClass, PageParameters pageParameters,\n\t\tInteger renderCount)\n\t{\n\t\tPageProvider provider = new PageProvider(pageInfo.getPageId(), pageClass, pageParameters,\n\t\t\trenderCount);\n\t\tprovider.setPageSource(getContext());\n\t\tif (provider.isNewPageInstance() && !getRecreateMountedPagesAfterExpiry())\n\t\t{\n\t\t\tthrow new PageExpiredException(String.format(\"Bookmarkable page id '%d' has expired.\",\n\t\t\t\tpageInfo.getPageId()));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/** \n\t\t\t * https://issues.apache.org/jira/browse/WICKET-5734\n\t\t\t * */\n\t\t\tPageParameters constructionPageParameters = provider.hasPageInstance() ? \n\t\t\t\tprovider.getPageInstance().getPageParameters() : new PageParameters();\n\n\t\t\tif (PageParameters.equals(constructionPageParameters, pageParameters) == false)\n\t\t\t{\n\t\t\t\t// create a fresh page instance because the request page parameters are different than the ones\n\t\t\t\t// when the resolved page by id has been created\n\t\t\t\treturn new RenderPageRequestHandler(new PageProvider(pageClass, pageParameters));\n\t\t\t}\n\t\t\treturn new RenderPageRequestHandler(provider);\n\t\t}\n\t}\n"
    },
    "Wicket_core-14": {
        "buggy": "\t/**\n\t * Static factory method for creating a <code>TagTester</code> based on a tag found by an\n\t * attribute with a specific value. Please note that it will return the first tag which matches\n\t * the criteria. It's therefore good for attributes such as \"id\" or \"wicket:id\", but only if\n\t * \"wicket:id\" is unique in the specified markup.\n\t * \n\t * @param markup\n\t *            the markup to look for the tag to create the <code>TagTester</code> from\n\t * @param attribute\n\t *            the attribute which should be on the tag in the markup\n\t * @param value\n\t *            the value which the attribute must have\n\t * @return the <code>TagTester</code> which matches the tag in the markup, that has the given\n\t *         value on the given attribute\n\t */\n\tpublic static TagTester createTagByAttribute(String markup, String attribute, String value)\n\t{\n\t\tTagTester tester = null;\n\n\t\tif (Strings.isEmpty(markup) == false && Strings.isEmpty(attribute) == false &&\n\t\t\tStrings.isEmpty(value) == false)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// remove the CDATA and\n\t\t\t\t// the id attribute of the component because it is often the same as the element's id\n\t\t\t\tmarkup = AJAX_COMPONENT_CDATA_OPEN.matcher(markup).replaceAll(\"<component>\");\n\t\t\t\tmarkup = AJAX_COMPONENT_CDATA_CLOSE.matcher(markup).replaceAll(\"</component>\");\n\n\t\t\t\tXmlPullParser parser = new XmlPullParser();\n\t\t\t\tparser.parse(markup);\n\n\t\t\t\tXmlTag elm;\n\t\t\t\tXmlTag openTag = null;\n\t\t\t\tXmlTag closeTag = null;\n\t\t\t\tint level = 0;\n\t\t\t\twhile ((elm = parser.nextTag()) != null && closeTag == null)\n\t\t\t\t{\n\t\t\t\t\tXmlTag xmlTag = elm;\n\n\t\t\t\t\tif (openTag == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tIValueMap attributeMap = xmlTag.getAttributes();\n\n\t\t\t\t\t\tfor (Map.Entry<String, Object> entry : attributeMap.entrySet())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString attr = entry.getKey();\n\t\t\t\t\t\t\tif (attr.equals(attribute) && value.equals(entry.getValue()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (xmlTag.isOpen())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\topenTag = xmlTag;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (xmlTag.isOpenClose())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\topenTag = xmlTag;\n\t\t\t\t\t\t\t\t\tcloseTag = xmlTag;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (xmlTag.isOpen() && xmlTag.getName().equals(openTag.getName()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlevel++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (xmlTag.isClose())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (xmlTag.getName().equals(openTag.getName()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (level == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcloseTag = xmlTag;\n\t\t\t\t\t\t\t\t\tcloseTag.setOpenTag(openTag);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlevel--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (openTag != null && closeTag != null)\n\t\t\t\t{\n\t\t\t\t\ttester = new TagTester(parser, openTag, closeTag);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(e);\n\t\t\t}\n\t\t}\n\n\t\treturn tester;\n\t}\n",
        "start": 453,
        "end": 551,
        "fix": "\t/**\n\t * Static factory method for creating a <code>TagTester</code> based on a tag found by an\n\t * attribute with a specific value. Please note that it will return the first tag which matches\n\t * the criteria. It's therefore good for attributes such as \"id\" or \"wicket:id\", but only if\n\t * \"wicket:id\" is unique in the specified markup.\n\t * \n\t * @param markup\n\t *            the markup to look for the tag to create the <code>TagTester</code> from\n\t * @param attribute\n\t *            the attribute which should be on the tag in the markup\n\t * @param value\n\t *            the value which the attribute must have\n\t * @return the <code>TagTester</code> which matches the tag in the markup, that has the given\n\t *         value on the given attribute\n\t */\n\tpublic static TagTester createTagByAttribute(String markup, String attribute, String value)\n\t{\n\t\tTagTester tester = null;\n\n\t\tif (Strings.isEmpty(markup) == false && Strings.isEmpty(attribute) == false &&\n\t\t\tStrings.isEmpty(value) == false)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// remove the CDATA and\n\t\t\t\t// the id attribute of the component because it is often the same as the element's id\n\t\t\t\tmarkup = AJAX_COMPONENT_CDATA_OPEN.matcher(markup).replaceAll(\"<component>\");\n\t\t\t\tmarkup = AJAX_COMPONENT_CDATA_CLOSE.matcher(markup).replaceAll(\"</component>\");\n\n\t\t\t\tXmlPullParser parser = new XmlPullParser();\n\t\t\t\tparser.parse(markup);\n\n\t\t\t\tXmlTag elm;\n\t\t\t\tXmlTag openTag = null;\n\t\t\t\tXmlTag closeTag = null;\n\t\t\t\tint level = 0;\n\t\t\t\twhile ((elm = parser.nextTag()) != null && closeTag == null)\n\t\t\t\t{\n\t\t\t\t\tXmlTag xmlTag = elm;\n\n\t\t\t\t\tif (openTag == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tIValueMap attributeMap = xmlTag.getAttributes();\n\n\t\t\t\t\t\tfor (Map.Entry<String, Object> entry : attributeMap.entrySet())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString attr = entry.getKey();\n\t\t\t\t\t\t\tif (attr.equals(attribute) && value.equals(entry.getValue()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (xmlTag.isOpen())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\topenTag = xmlTag;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (xmlTag.isOpenClose())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\topenTag = xmlTag;\n\t\t\t\t\t\t\t\t\tcloseTag = xmlTag;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (xmlTag.isOpen() && xmlTag.getName().equals(openTag.getName()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlevel++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (xmlTag.isClose())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (xmlTag.getName().equals(openTag.getName()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (level == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcloseTag = xmlTag;\n\t\t\t\t\t\t\t\t\tcloseTag.setOpenTag(openTag);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlevel--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (openTag != null && closeTag != null)\n\t\t\t\t{\n\t\t\t\t\ttester = new TagTester(parser, openTag, closeTag);\n\t\t\t\t}\n\t\t\t\telse if (openTag != null)\n\t\t\t\t{\n\t\t\t\t\ttester = new TagTester(parser, openTag, openTag);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(e);\n\t\t\t}\n\t\t}\n\n\t\treturn tester;\n\t}\n"
    },
    "Wicket_core-15": {
        "buggy": "\t/**\n\t * Check if the credit card is a China UnionPay. A China UnionPay number has to start with 622\n\t * (622126-622925) and has to have a length between 16 and 19. No further validation takes\n\t * place.<br/>\n\t * <br/>\n\t * \n\t * @param creditCardNumber\n\t *            the credit card number as a string\n\t * @return The credit card id of the issuer\n\t */\n\tprivate CreditCard isChinaUnionPay(String creditCardNumber)\n\t{\n\t\tif ((creditCardNumber.length() >= 16 && creditCardNumber.length() <= 19) &&\n\t\t\t(creditCardNumber.startsWith(\"622\")))\n\t\t{\n\t\t\tint firstDigits = Integer.parseInt(creditCardNumber.substring(0, 5));\n\t\t\tif (firstDigits >= 622126 && firstDigits <= 622925)\n\t\t\t{\n\t\t\t\treturn CreditCard.CHINA_UNIONPAY;\n\t\t\t}\n\t\t}\n\n\t\treturn CreditCard.INVALID;\n\t}\n",
        "start": 310,
        "end": 333,
        "fix": "\t/**\n\t * Check if the credit card is a China UnionPay. A China UnionPay number has to start with 622\n\t * (622126-622925) and has to have a length between 16 and 19. No further validation takes\n\t * place.<br/>\n\t * <br/>\n\t * \n\t * @param creditCardNumber\n\t *            the credit card number as a string\n\t * @return The credit card id of the issuer\n\t */\n\tprivate CreditCard isChinaUnionPay(String creditCardNumber)\n\t{\n\t\tif ((creditCardNumber.length() >= 16 && creditCardNumber.length() <= 19) &&\n\t\t\t(creditCardNumber.startsWith(\"622\")))\n\t\t{\n\t\t\tint firstDigits = Integer.parseInt(creditCardNumber.substring(0, 6));\n\t\t\tif (firstDigits >= 622126 && firstDigits <= 622925)\n\t\t\t{\n\t\t\t\treturn CreditCard.CHINA_UNIONPAY;\n\t\t\t}\n\t\t}\n\n\t\treturn CreditCard.INVALID;\n\t}\n"
    },
    "Wicket_core-17": {
        "buggy": "\t/**\n\t * Called on every component after the page is rendered. It will call onAfterRender for it self\n\t * and its children.\n\t */\n\tpublic final void afterRender()\n\t{\n\t\ttry\n\t\t{\n\t\t\tsetFlag(FLAG_AFTER_RENDERING, true);\n\n\t\t\t// always detach children because components can be attached\n\t\t\t// independently of their parents\n\t\t\tonAfterRenderChildren();\n\n\t\t\tonAfterRender();\n\t\t\tgetApplication().getComponentOnAfterRenderListeners().onAfterRender(this);\n\t\t\tif (getFlag(FLAG_AFTER_RENDERING))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(Component.class.getName() +\n\t\t\t\t\t\" has not been properly detached. Something in the hierarchy of \" +\n\t\t\t\t\tgetClass().getName() +\n\t\t\t\t\t\" has not called super.onAfterRender() in the override of onAfterRender() method\");\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\t// this flag must always be set to false.\n\t\t\tsetFlag(FLAG_RENDERING, false);\n\t\t}\n\t}\n",
        "start": 904,
        "end": 933,
        "fix": "\t/**\n\t * Called on every component after the page is rendered. It will call onAfterRender for it self\n\t * and its children.\n\t */\n\tpublic final void afterRender()\n\t{\n\t\ttry\n\t\t{\n\t\t\tsetFlag(FLAG_AFTER_RENDERING, true);\n\n\t\t\t// always detach children because components can be attached\n\t\t\t// independently of their parents\n\t\t\tonAfterRenderChildren();\n\n\t\t\tonAfterRender();\n\t\t\tgetApplication().getComponentOnAfterRenderListeners().onAfterRender(this);\n\t\t\tif (getFlag(FLAG_AFTER_RENDERING))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(Component.class.getName() +\n\t\t\t\t\t\" has not been properly detached. Something in the hierarchy of \" +\n\t\t\t\t\tgetClass().getName() +\n\t\t\t\t\t\" has not called super.onAfterRender() in the override of onAfterRender() method\");\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\t// this flag must always be set to false.\n\t\t\tmarkRendering(false);\n\t\t}\n\t}\n"
    },
    "Cargo_container-1": {
        "buggy": "    /**\n     * Construct a Resource from a list of properties.\n     * \n     * @param properties A list of properties representing this Resource\n     * @return Resource representing the properties.\n     * @see PropertyUtils#splitPropertiesOnPipe(String)\n     */\n    public Resource fromProperties(Properties properties)\n    {\n        String name = properties.getProperty(ResourcePropertySet.RESOURCE_NAME);\n        String type = properties.getProperty(ResourcePropertySet.RESOURCE_TYPE);\n        Resource data = new Resource(name, type);\n\n        if (properties.containsKey(ResourcePropertySet.RESOURCE_CLASS))\n        {\n            String className = properties.getProperty(ResourcePropertySet.RESOURCE_CLASS);\n            data.setClassName(className);\n        }\n\n        String parametersAsASemicolonDelimitedString =\n            properties.getProperty(ResourcePropertySet.PARAMETERS);\n        data.setParameters(getParametersFromString(parametersAsASemicolonDelimitedString));\n        return data;\n    }\n",
        "start": 50,
        "end": 73,
        "fix": "    /**\n     * Construct a Resource from a list of properties.\n     * \n     * @param properties A list of properties representing this Resource\n     * @return Resource representing the properties.\n     * @see PropertyUtils#splitPropertiesOnPipe(String)\n     */\n    public Resource fromProperties(Properties properties)\n    {\n        String name = properties.getProperty(ResourcePropertySet.RESOURCE_NAME);\n        String type = properties.getProperty(ResourcePropertySet.RESOURCE_TYPE);\n        Resource data = new Resource(name, type);\n\n        if (properties.containsKey(ResourcePropertySet.RESOURCE_CLASS))\n        {\n            String className = properties.getProperty(ResourcePropertySet.RESOURCE_CLASS);\n            data.setClassName(className);\n        }\n\n        String parametersAsASemicolonDelimitedString =\n            properties.getProperty(ResourcePropertySet.PARAMETERS);\n        data.setParameters(getParametersFromString(\n            PropertyUtils.escapeBackSlashesIfNotNull(parametersAsASemicolonDelimitedString)));\n        return data;\n    }\n"
    },
    "Cargo_container-2": {
        "buggy": "    /**\n     * @param context the context name to use when deploying this WAR. If not specified by the user,\n     *        then the default context name is computed from the name of WAR itself (without the \n     *        file extension).\n     */\n    public synchronized void setContext(String context)\n    {\n        // Ensure the context is also well-formed by removing any extra leading \"/\".\n        this.context = context.replace('/', ' ').trim();\n    }\n",
        "start": 46,
        "end": 55,
        "fix": "    /**\n     * @param context the context name to use when deploying this WAR. If not specified by the user,\n     *        then the default context name is computed from the name of WAR itself (without the \n     *        file extension).\n     */\n    public synchronized void setContext(String context)\n    {\n        // Ensure the context is also well-formed by removing any extra leading \"/\".\n        this.context = context.trim();\n        if (this.context.startsWith(\"/\")) \n        {\n            this.context = this.context.substring(1); \n        }\n    }\n"
    },
    "Cargo_container-3": {
        "buggy": "    /**\n     * Parse a user defined in the format \"name:pwd:role1,...roleN\".\n     * \n     * @param userAsString the user defines as a string\n     * @return the parsed user\n     */\n    protected static User parseUser(String userAsString)\n    {\n        User user = new User();\n\n        StringTokenizer fieldTokens = new StringTokenizer(userAsString, \":\", true);\n\n        try\n        {\n            user.setName(fieldTokens.nextToken());\n\n            if (!\":\".equals(fieldTokens.nextToken()))\n            {\n                throw new ContainerException(\"Invalid format for [\" + userAsString + \"]\");\n            }\n\n            String token = fieldTokens.nextToken();\n            if (\":\".equals(token))\n            {\n                user.setPassword(\"\");\n            }\n            else\n            {\n                user.setPassword(token);\n                if (!\":\".equals(fieldTokens.nextToken()))\n                {\n                    throw new ContainerException(\"Invalid format for [\" + userAsString + \"]\");\n                }\n            }\n\n            user.addRoles(parseRoles(fieldTokens.nextToken()));\n        }\n        catch (NoSuchElementException exception)\n        {\n            throw new ContainerException(\"Invalid format for [\" + userAsString + \"]\");\n        }\n\n        return user;\n    }\n",
        "start": 162,
        "end": 205,
        "fix": "    /**\n     * Parse a user defined in the format \"name:pwd:role1,...roleN\".\n     * \n     * @param userAsString the user defines as a string\n     * @return the parsed user\n     */\n    protected static User parseUser(String userAsString)\n    {\n        User user = new User();\n\n        StringTokenizer fieldTokens = new StringTokenizer(userAsString, \":\", true);\n\n        try\n        {\n            user.setName(fieldTokens.nextToken());\n\n            if (!\":\".equals(fieldTokens.nextToken()))\n            {\n                throw new ContainerException(\"Invalid format for [\" + userAsString + \"]\");\n            }\n\n            String token = fieldTokens.nextToken();\n            if (\":\".equals(token))\n            {\n                user.setPassword(\"\");\n            }\n            else\n            {\n                user.setPassword(token);\n            }\n        }\n        catch (NoSuchElementException exception)\n        {\n            throw new ContainerException(\"Invalid format for [\" + userAsString + \"]\");\n        }\n\n        try\n        {\n            if (user.getPassword().length() > 0 && !\":\".equals(fieldTokens.nextToken()))\n            {\n                throw new ContainerException(\"Invalid format for [\" + userAsString + \"]\");\n            }\n            user.addRoles(parseRoles(fieldTokens.nextToken()));\n        }\n        catch (NoSuchElementException exception)\n        {\n            // CARGO-526: No roles defined, that's OK\n        }\n\n        try\n        {\n            fieldTokens.nextToken();\n            throw new ContainerException(\"Invalid format for [\" + userAsString + \"]\");\n        }\n        catch (NoSuchElementException exception)\n        {\n            // That's expected: we only have 3 tokens\n        }\n\n        return user;\n    }\n"
    },
    "Jcodemodel-5": {
        "buggy": "  /**\n   * Gets the parent package, or null if this class is the root package.\n   */\n  @Nullable\n  public JPackage parent ()\n  {\n    if (m_sName.length () == 0)\n      return null;\n\n    final int idx = m_sName.lastIndexOf ('.');\n    return m_aOwner._package (m_sName.substring (0, idx));\n  }\n",
        "start": 139,
        "end": 150,
        "fix": "  /**\n   * Gets the parent package, or null if this class is the root package.\n   */\n  @Nullable\n  public JPackage parent ()\n  {\n    if (m_sName.length () == 0)\n      return null;\n\n    final int idx = m_sName.lastIndexOf ('.');\n    if (idx < 0)\n      return null;\n    return m_aOwner._package (m_sName.substring (0, idx));\n  }\n"
    },
    "Vectorz-1": {
        "buggy": "\tprivate PermutationMatrix getPivotMatrix() {\n\t\tint numPivots = LU.rowCount();\n\t\treturn PermutationMatrix.create(Index.wrap(Arrays.copyOf(pivot, numPivots)));\n\t}\n",
        "start": 111,
        "end": 114,
        "fix": "\tprivate PermutationMatrix getPivotMatrix() {\n\t\tint numPivots = LU.rowCount();\n\t\treturn PermutationMatrix.create(Index.wrap(Arrays.copyOf(pivot, numPivots))).getTranspose();\n\t}\n"
    },
    "Vectorz-4": {
        "buggy": "\tprivate static int indexPositionBig(int[] data, int x, int min, int max) {\n\t\tint lx=data[min];\n\t\tint hx=data[max-1];\n\t\tif (x<=lx) {\n\t\t\tif (x==lx) return min;\n\t\t\treturn -1;\n\t\t}\n\t\tif (x>=hx) {\n\t\t\tif (x==hx) return max-1;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\twhile ((min+10)<max) {\n\t\t\tint mid=min+((max-min)*(x-lx))/((hx-lx)*2); // best estimate of position\n\t\t\tint mx=data[mid];\n\t\t\tif (x==mx) return mid;\n\t\t\tif (x<mx) {\n\t\t\t\tmax=mid;\n\t\t\t\thx=mx;\n\t\t\t} else {\n\t\t\t\tmin=mid+1;\n\t\t\t\tlx=mx;\n\t\t\t}\n\t\t}\n\t\treturn indexPositionSmall(data, x,min,max);\t\t\t\t\n\t}\n",
        "start": 213,
        "end": 238,
        "fix": "\tprivate static int indexPositionBig(int[] data, int x, int min, int max) {\n\t\tint lx=data[min];\n\t\tint hx=data[max-1];\n\t\tif (x<=lx) {\n\t\t\tif (x==lx) return min;\n\t\t\treturn -1;\n\t\t}\n\t\tif (x>=hx) {\n\t\t\tif (x==hx) return max-1;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\twhile ((min+10)<max) {\n\t\t\tint mid = (int)((long)min+(((long)(max-min))*((long)(x-lx)))/(((long)(hx-lx))*2)); // best estimate of position\n\t\t\tint mx=data[mid];\n\t\t\tif (x==mx) return mid;\n\t\t\tif (x<mx) {\n\t\t\t\tmax=mid;\n\t\t\t\thx=mx;\n\t\t\t} else {\n\t\t\t\tmin=mid+1;\n\t\t\t\tlx=mx;\n\t\t\t}\n\t\t}\n\t\treturn indexPositionSmall(data, x,min,max);\t\t\t\t\n\t}\n"
    },
    "Restfixture-2": {
        "buggy": "\tprotected void doMethod(String method, String resUrl,\n\t\t\tMap<String, String> headers, String rBody) {\n\t\tsetLastRequest(partsFactory.buildRestRequest());\n\t\tgetLastRequest().setMethod(RestRequest.Method.valueOf(method));\n\t\tgetLastRequest().addHeaders(headers);\n\t\tgetLastRequest().setFollowRedirect(followRedirects);\n\t\tgetLastRequest().setResourceUriEscaped(resourceUrisAreEscaped);\n\t\tif (fileName != null) {\n\t\t\tgetLastRequest().setFileName(fileName);\n\t\t}\n\t\tif (multipartFileName != null) {\n\t\t\tgetLastRequest().setMultipartFileName(multipartFileName);\n\t\t}\n\t\tgetLastRequest().setMultipartFileParameterName(\n\t\t\t\tmultipartFileParameterName);\n\t\tString[] uri = resUrl.split(\"\\\\?\");\n\t\tString[] thisRequestUrlParts = buildThisRequestUrl(uri[0]);\n\t\tgetLastRequest().setResource(thisRequestUrlParts[1]);\n\t\tif (uri.length == 2) {\n\t\t\tgetLastRequest().setQuery(uri[1]);\n\t\t}\n\t\tif (\"Post\".equals(method) || \"Put\".equals(method)) {\n\t\t\tgetLastRequest().setBody(rBody);\n\t\t}\n\n        //sglebs dirty workaround for #96\n        configureCredentials();\n\n\t\trestClient.setBaseUrl(thisRequestUrlParts[0]);\n\t\tRestResponse response = restClient.execute(getLastRequest());\n\t\tsetLastResponse(response);\n\t}\n",
        "start": 909,
        "end": 940,
        "fix": "\tprotected void doMethod(String method, String resUrl,\n\t\t\tMap<String, String> headers, String rBody) {\n\t\tsetLastRequest(partsFactory.buildRestRequest());\n\t\tgetLastRequest().setMethod(RestRequest.Method.valueOf(method));\n\t\tgetLastRequest().addHeaders(headers);\n\t\tgetLastRequest().setFollowRedirect(followRedirects);\n\t\tgetLastRequest().setResourceUriEscaped(resourceUrisAreEscaped);\n\t\tif (fileName != null) {\n\t\t\tgetLastRequest().setFileName(fileName);\n\t\t}\n\t\tif (multipartFileName != null) {\n\t\t\tgetLastRequest().setMultipartFileName(multipartFileName);\n\t\t}\n\t\tgetLastRequest().setMultipartFileParameterName(\n\t\t\t\tmultipartFileParameterName);\n\t\tString[] uri = resUrl.split(\"\\\\?\", 2);\n\t\tString[] thisRequestUrlParts = buildThisRequestUrl(uri[0]);\n\t\tgetLastRequest().setResource(thisRequestUrlParts[1]);\n\t\tif (uri.length == 2) {\n\t\t\tgetLastRequest().setQuery(uri[1]);\n\t\t}\n\t\tif (\"Post\".equals(method) || \"Put\".equals(method)) {\n\t\t\tgetLastRequest().setBody(rBody);\n\t\t}\n\n        //sglebs dirty workaround for #96\n        configureCredentials();\n\n\t\trestClient.setBaseUrl(thisRequestUrlParts[0]);\n\t\tRestResponse response = restClient.execute(getLastRequest());\n\t\tsetLastResponse(response);\n\t}\n"
    },
    "Restfixture-4": {
        "buggy": "\t/**\n\t * @param message\n\t *            the message to be included in the collapsable section header.\n\t * @param content\n\t *            the content collapsed.\n\t * @return a string with the html/js code to implement a collapsable section\n\t *         in fitnesse.\n\t */\n\tpublic static String makeToggleCollapseable(String message, String content) {\n\t\tRandom random = new Random();\n\t\tString id = Integer.toString(content.hashCode())\n\t\t\t\t+ Long.toString(random.nextLong());\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"<a href=\\\"javascript:toggleCollapsable('\" + id + \"');\\\">\");\n\t\tsb.append(\"<img src='/files/images/collapsableClosed.gif' class='left' id='img\"+ id + \"'/>\" + message + \"</a>\");\n\t\tsb.append(\"<div class='hidden' id='\" + id + \"'>\").append(content).append(\"</div>\");\n\t\treturn sb.toString();\n\t}\n",
        "start": 508,
        "end": 525,
        "fix": "\t/**\n\t * @param message\n\t *            the message to be included in the collapsable section header.\n\t * @param content\n\t *            the content collapsed.\n\t * @return a string with the html/js code to implement a collapsable section\n\t *         in fitnesse.\n\t */\n\tpublic static String makeToggleCollapseable(String message, String content) {\n\t\tRandom random = new Random();\n\t\tString id = Integer.toString(content.hashCode())\n\t\t\t\t+ Long.toString(random.nextLong());\n\t\tStringBuffer sb = new StringBuffer();\n\t\tsb.append(\"<div class='collapsible closed'>\");\n\t\tsb.append(\"<ul><li><a href='#' class='expandall'>Expand</a></li><li><a href='#' class='collapseall'>Collapse</a></li></ul>\");\n\t\tsb.append(\"<p class='title'>\").append(message).append(\"</p>\");\n\t\tsb.append(\"<div>\").append(content).append(\"</div>\");\n\t\tsb.append(\"</div>\");\n\t\treturn sb.toString();\n\t}\n"
    },
    "Xades4j-3": {
        "buggy": "    @Override\n    public QualifyingProperty verify(\n            GenericDOMData propData,\n            QualifyingPropertyVerificationContext ctx) throws InvalidPropertyException\n    {\n\n\n        XAdESVerificationResult res;\n        try\n        {\n            Element sigElem = DOMHelper.getFirstChildElement(propData.getPropertyElement());\n            res = verifier.verify(sigElem, null);\n        } catch (XAdES4jException ex)\n        {\n            throw new CounterSignatureXadesVerificationException(ex);\n        }\n\n        // \"Check that the enclosed signature correctly references the ds:SignatureValue\n        // present in the countersigned XAdES signature.\"\n\n        Node targetSigValueElem = ctx.getSignature().getElement().getElementsByTagNameNS(\n                Constants.SignatureSpecNS, Constants._TAG_SIGNATUREVALUE).item(0);\n\n        try\n        {\n            SignedInfo si = res.getXmlSignature().getSignedInfo();\n            for (int i = 0; i < si.getLength(); i++)\n            {\n                Reference r = si.item(i);\n                if (r.getContentsAfterTransformation().getSubNode() == targetSigValueElem)\n                {\n                    // The signature references the SignatureValue element.\n                    return new CounterSignatureProperty(res);\n                }\n                    // The signature references the SignatureValue element with\n                    // C14N transforms only.\n            }\n            throw new CounterSignatureSigValueRefException();\n        } catch (XMLSecurityException e)\n        {\n            // Shouldn't happen because the signature was already verified.\n            throw new CounterSignatureVerificationException(e);\n        }\n    }\n",
        "start": 47,
        "end": 90,
        "fix": "    @Override\n    public QualifyingProperty verify(\n            GenericDOMData propData,\n            QualifyingPropertyVerificationContext ctx) throws InvalidPropertyException\n    {\n\n\n        XAdESVerificationResult res;\n        try\n        {\n            Element sigElem = DOMHelper.getFirstChildElement(propData.getPropertyElement());\n            res = verifier.verify(sigElem, null);\n        } catch (XAdES4jException ex)\n        {\n            throw new CounterSignatureXadesVerificationException(ex);\n        }\n\n        // \"Check that the enclosed signature correctly references the ds:SignatureValue\n        // present in the countersigned XAdES signature.\"\n\n        Node targetSigValueElem = ctx.getSignature().getElement().getElementsByTagNameNS(\n                Constants.SignatureSpecNS, Constants._TAG_SIGNATUREVALUE).item(0);\n\n        try\n        {\n            SignedInfo si = res.getXmlSignature().getSignedInfo();\n            for (int i = 0; i < si.getLength(); i++)\n            {\n                Reference r = si.item(i);\n                if (r.getContentsAfterTransformation().getSubNode() == targetSigValueElem)\n                {\n                    // The signature references the SignatureValue element.\n                    return new CounterSignatureProperty(res);\n                }\n                else if (r.getContentsBeforeTransformation().getSubNode() == targetSigValueElem && CanonicalizerUtils.allTransformsAreC14N(r))\n                {\n                    // The signature references the SignatureValue element with\n                    // C14N transforms only.\n                    return new CounterSignatureProperty(res);\n                }\n            }\n            throw new CounterSignatureSigValueRefException();\n        } catch (XMLSecurityException e)\n        {\n            // Shouldn't happen because the signature was already verified.\n            throw new CounterSignatureVerificationException(e);\n        }\n    }\n"
    },
    "Render_app-3": {
        "buggy": "    @Override\n    public ChannelMap getChannels(final int mipmapLevel)\n            throws IllegalArgumentException {\n\n        final ChannelMap channels = new ChannelMap();\n\n        if ((channelSpecList != null) && (channelSpecList.size() > 0)) {\n\n            final long loadMipStart = System.currentTimeMillis();\n\n            final ChannelSpec firstChannelSpec = channelSpecList.get(0);\n\n            int downSampleLevels = 0;\n\n            final Map.Entry<Integer, ImageAndMask> mipmapEntry = firstChannelSpec.getFloorMipmapEntry(mipmapLevel);\n            final ImageAndMask imageAndMask = mipmapEntry.getValue();\n\n            final int currentMipmapLevel = mipmapEntry.getKey();\n            if (currentMipmapLevel < mipmapLevel) {\n                downSampleLevels = mipmapLevel - currentMipmapLevel;\n            }\n\n            final ImageProcessor imageProcessor = imageProcessorCache.get(imageAndMask.getImageUrl(),\n                                                                          downSampleLevels,\n                                                                          false,\n                                                                          firstChannelSpec.is16Bit());\n            final long loadMipStop = System.currentTimeMillis();\n\n            if (imageProcessor.getWidth() == 0 || imageProcessor.getHeight() == 0) {\n\n                LOG.debug(\"skipping \" + getSourceName() + \" mipmap \" + imageAndMask.getImageUrl() +\n                          \" with zero dimension after down-sampling \" + downSampleLevels + \" levels\");\n\n            } else {\n\n                // open mask\n                final ImageProcessor maskProcessor;\n                final String maskUrl = imageAndMask.getMaskUrl();\n                if ((maskUrl != null) && (!excludeMask)) {\n                    maskProcessor = imageProcessorCache.get(maskUrl, downSampleLevels, true, false);\n                } else {\n                    maskProcessor = null;\n                }\n\n                final long loadMaskStop = System.currentTimeMillis();\n\n                setMinAndMaxIntensity(imageProcessor, firstChannelSpec);\n\n                final ImageProcessorWithMasks firstChannel =\n                        new ImageProcessorWithMasks(imageProcessor, maskProcessor, null);\n\n                // log warning if source.mask gets \"quietly\" removed (because of size)\n                if ((maskProcessor != null) && (firstChannel.mask == null)) {\n                    LOG.warn(\"getChannels: {} mask removed because image {} size ({}x{}) differs from mask {} size ({}x{})\",\n                             sourceName,\n                             imageAndMask.getImageUrl(), imageProcessor.getWidth(), imageProcessor.getHeight(),\n                             imageAndMask.getMaskUrl(), maskProcessor.getWidth(), maskProcessor.getHeight());\n                }\n\n                channels.put(firstChannelSpec.getName(), firstChannel);\n\n                if (channelSpecList.size() > 1) {\n                    loadAdditionalChannels(imageProcessor.getWidth(),\n                                           imageProcessor.getHeight(),\n                                           mipmapLevel,\n                                           channels);\n                }\n\n                final long loadAdditionalChannelsStop = System.currentTimeMillis();\n\n                LOG.debug(\"getChannels: {} took {} milliseconds to load level {} (first mip:{}, downSampleLevels:{}, first mask:{}, additional channels:{}), cacheSize:{}\",\n                          sourceName,\n                          loadAdditionalChannelsStop - loadMipStart,\n                          mipmapLevel,\n                          loadMipStop - loadMipStart,\n                          downSampleLevels,\n                          loadMaskStop - loadMipStop,\n                          loadAdditionalChannelsStop - loadMaskStop,\n                          imageProcessorCache.size());\n            }\n        }\n\n        return channels;\n    }\n",
        "start": 90,
        "end": 173,
        "fix": "    @Override\n    public ChannelMap getChannels(final int mipmapLevel)\n            throws IllegalArgumentException {\n\n        final ChannelMap channels = new ChannelMap();\n\n        if ((channelSpecList != null) && (channelSpecList.size() > 0)) {\n\n            final long loadMipStart = System.currentTimeMillis();\n\n            final ChannelSpec firstChannelSpec = channelSpecList.get(0);\n\n            int downSampleLevels = 0;\n\n            final Map.Entry<Integer, ImageAndMask> mipmapEntry = firstChannelSpec.getFloorMipmapEntry(mipmapLevel);\n            final ImageAndMask imageAndMask = mipmapEntry.getValue();\n\n            final int currentMipmapLevel = mipmapEntry.getKey();\n            if (currentMipmapLevel < mipmapLevel) {\n                downSampleLevels = mipmapLevel - currentMipmapLevel;\n            } else if (currentMipmapLevel > mipmapLevel) {\n                throw new IllegalArgumentException(\n                        \"The highest resolution mipmap for \" + imageAndMask.getImageUrl() + \" is level \" +\n                        currentMipmapLevel + \" but a level \" + mipmapLevel +\n                        \" mipmap is needed.  Upscaling is not currently supported.\");\n            }\n\n            final ImageProcessor imageProcessor = imageProcessorCache.get(imageAndMask.getImageUrl(),\n                                                                          downSampleLevels,\n                                                                          false,\n                                                                          firstChannelSpec.is16Bit());\n            final long loadMipStop = System.currentTimeMillis();\n\n            if (imageProcessor.getWidth() == 0 || imageProcessor.getHeight() == 0) {\n\n                LOG.debug(\"skipping \" + getSourceName() + \" mipmap \" + imageAndMask.getImageUrl() +\n                          \" with zero dimension after down-sampling \" + downSampleLevels + \" levels\");\n\n            } else {\n\n                // open mask\n                final ImageProcessor maskProcessor;\n                final String maskUrl = imageAndMask.getMaskUrl();\n                if ((maskUrl != null) && (!excludeMask)) {\n                    maskProcessor = imageProcessorCache.get(maskUrl, downSampleLevels, true, false);\n                } else {\n                    maskProcessor = null;\n                }\n\n                final long loadMaskStop = System.currentTimeMillis();\n\n                setMinAndMaxIntensity(imageProcessor, firstChannelSpec);\n\n                final ImageProcessorWithMasks firstChannel =\n                        new ImageProcessorWithMasks(imageProcessor, maskProcessor, null);\n\n                // log warning if source.mask gets \"quietly\" removed (because of size)\n                if ((maskProcessor != null) && (firstChannel.mask == null)) {\n                    LOG.warn(\"getChannels: {} mask removed because image {} size ({}x{}) differs from mask {} size ({}x{})\",\n                             sourceName,\n                             imageAndMask.getImageUrl(), imageProcessor.getWidth(), imageProcessor.getHeight(),\n                             imageAndMask.getMaskUrl(), maskProcessor.getWidth(), maskProcessor.getHeight());\n                }\n\n                channels.put(firstChannelSpec.getName(), firstChannel);\n\n                if (channelSpecList.size() > 1) {\n                    loadAdditionalChannels(imageProcessor.getWidth(),\n                                           imageProcessor.getHeight(),\n                                           mipmapLevel,\n                                           channels);\n                }\n\n                final long loadAdditionalChannelsStop = System.currentTimeMillis();\n\n                LOG.debug(\"getChannels: {} took {} milliseconds to load level {} (first mip:{}, downSampleLevels:{}, first mask:{}, additional channels:{}), cacheSize:{}\",\n                          sourceName,\n                          loadAdditionalChannelsStop - loadMipStart,\n                          mipmapLevel,\n                          loadMipStop - loadMipStart,\n                          downSampleLevels,\n                          loadMaskStop - loadMipStop,\n                          loadAdditionalChannelsStop - loadMaskStop,\n                          imageProcessorCache.size());\n            }\n        }\n\n        return channels;\n    }\n"
    },
    "Render_app-4": {
        "buggy": "    @Override\n    public void applyInPlace(final double[] location) {\n        location[dimension] -= a * Math.exp(-b * location[dimension]) + c;\n    }\n",
        "start": 22,
        "end": 25,
        "fix": "    @Override\n    public void applyInPlace(final double[] location) {\n        location[dimension] += a * Math.exp(-b * location[dimension]) + c;\n    }\n"
    },
    "Render_app-5": {
        "buggy": "    @Override\n    public void applyInPlace(final double[] location) {\n        location[dimension] += a * Math.exp(-b * location[dimension]) + c;\n    }\n",
        "start": 22,
        "end": 25,
        "fix": "    @Override\n    public void applyInPlace(final double[] location) {\n        location[dimension] += a * Math.exp(b * location[dimension]) + c;\n    }\n"
    },
    "Leshan_core-1": {
        "buggy": "    /**\n     * Decodes a byte array into a objlnk value.\n     */\n    public static ObjectLink decodeObjlnk(byte[] value) throws TlvException {\n        ByteBuffer bff = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN);\n        bff.put(value);\n        int val1 = bff.getShort(0);\n        int val2 = bff.getShort(2);\n        return new ObjectLink(val1, val2);\n    }\n",
        "start": 188,
        "end": 197,
        "fix": "    /**\n     * Decodes a byte array into a objlnk value.\n     */\n    public static ObjectLink decodeObjlnk(byte[] value) throws TlvException {\n        ByteBuffer bff = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN);\n        bff.put(value);\n        int val1 = bff.getShort(0) & 0xFFFF;\n        int val2 = bff.getShort(2) & 0xFFFF;\n        return new ObjectLink(val1, val2);\n    }\n"
    },
    "Leshan_core-2": {
        "buggy": "    private static Map<Integer, Object> parseTlvValues(Tlv[] tlvs, Type expectedType, LwM2mPath path)\n            throws CodecException {\n        Map<Integer, Object> values = new HashMap<>();\n        for (Tlv tlvChild : tlvs) {\n            if (tlvChild.getType() != TlvType.RESOURCE_INSTANCE)\n                throw new CodecException(\"Expected TLV of type RESOURCE_INSTANCE but was %s for path %s\",\n                        tlvChild.getType().name(), path);\n\n            values.put(tlvChild.getIdentifier(), parseTlvValue(tlvChild.getValue(), expectedType, path));\n        }\n        return values;\n    }\n",
        "start": 176,
        "end": 187,
        "fix": "    private static Map<Integer, Object> parseTlvValues(Tlv[] tlvs, Type expectedType, LwM2mPath path)\n            throws CodecException {\n        Map<Integer, Object> values = new HashMap<>();\n        for (Tlv tlvChild : tlvs) {\n            if (tlvChild.getType() != TlvType.RESOURCE_INSTANCE)\n                throw new CodecException(\"Expected TLV of type RESOURCE_INSTANCE but was %s for path %s\",\n                        tlvChild.getType().name(), path);\n\n            Object resourceInstance = parseTlvValue(tlvChild.getValue(), expectedType, path);\n            Object previousResourceInstance = values.put(tlvChild.getIdentifier(), resourceInstance);\n            if (previousResourceInstance != null) {\n                throw new CodecException(\"2 RESOURCE_INSTANCE (%s,%s) with the same identifier %d for path %s\",\n                        previousResourceInstance, resourceInstance, tlvChild.getIdentifier(), path);\n            }\n        }\n        return values;\n    }\n"
    },
    "Leshan_core-5": {
        "buggy": "    private static Map<Integer, LwM2mResource> extractLwM2mResources(Collection<JsonArrayEntry> jsonArrayEntries,\n            LwM2mPath baseName, LwM2mModel model) throws CodecException {\n        if (jsonArrayEntries == null)\n            return Collections.emptyMap();\n\n        // Extract LWM2M resources from JSON resource list\n        Map<Integer, LwM2mResource> lwM2mResourceMap = new HashMap<>();\n        Map<LwM2mPath, Map<Integer, JsonArrayEntry>> multiResourceMap = new HashMap<>();\n        for (JsonArrayEntry resourceElt : jsonArrayEntries) {\n\n            // Build resource path\n            LwM2mPath nodePath = baseName.append(resourceElt.getName());\n\n            // handle LWM2M resources\n            if (nodePath.isResourceInstance()) {\n                // Multi-instance resource\n                // Store multi-instance resource values in a map\n                // we will deal with it later\n                LwM2mPath resourcePath = new LwM2mPath(nodePath.getObjectId(), nodePath.getObjectInstanceId(),\n                        nodePath.getResourceId());\n                Map<Integer, JsonArrayEntry> multiResource = multiResourceMap.get(resourcePath);\n                if (multiResource == null) {\n                    multiResource = new HashMap<>();\n                    multiResourceMap.put(resourcePath, multiResource);\n                }\n                multiResource.put(nodePath.getResourceInstanceId(), resourceElt);\n            } else if (nodePath.isResource()) {\n                // Single resource\n                Type expectedType = getResourceType(nodePath, model, resourceElt);\n                LwM2mResource res = LwM2mSingleResource.newResource(nodePath.getResourceId(),\n                        parseJsonValue(resourceElt.getResourceValue(), expectedType, nodePath), expectedType);\n                lwM2mResourceMap.put(nodePath.getResourceId(), res);\n            } else {\n                throw new CodecException(\n                        \"Invalid path [%s] for resource, it should be a resource or a resource instance path\",\n                        nodePath);\n            }\n        }\n\n        // Handle multi-instance resource.\n        for (Map.Entry<LwM2mPath, Map<Integer, JsonArrayEntry>> entry : multiResourceMap.entrySet()) {\n            LwM2mPath resourcePath = entry.getKey();\n            Map<Integer, JsonArrayEntry> jsonEntries = entry.getValue();\n\n            if (jsonEntries != null && !jsonEntries.isEmpty()) {\n                Type expectedType = getResourceType(resourcePath, model, jsonEntries.values().iterator().next());\n                Map<Integer, Object> values = new HashMap<>();\n                for (Entry<Integer, JsonArrayEntry> e : jsonEntries.entrySet()) {\n                    Integer resourceInstanceId = e.getKey();\n                    values.put(resourceInstanceId,\n                            parseJsonValue(e.getValue().getResourceValue(), expectedType, resourcePath));\n                }\n                LwM2mResource resource = LwM2mMultipleResource.newResource(resourcePath.getResourceId(), values,\n                        expectedType);\n                lwM2mResourceMap.put(resourcePath.getResourceId(), resource);\n            }\n        }\n\n        // If we found nothing, we try to create an empty multi-instance resource\n        if (lwM2mResourceMap.isEmpty() && baseName.isResource()) {\n            ResourceModel resourceModel = model.getResourceModel(baseName.getObjectId(), baseName.getResourceId());\n            // We create it only if this respect the model\n            if (resourceModel == null || resourceModel.multiple) {\n                Type resourceType = getResourceType(baseName, model, null);\n                lwM2mResourceMap.put(baseName.getResourceId(), LwM2mMultipleResource\n                        .newResource(baseName.getResourceId(), new HashMap<Integer, Object>(), resourceType));\n            }\n        }\n\n        return lwM2mResourceMap;\n    }\n",
        "start": 287,
        "end": 357,
        "fix": "    private static Map<Integer, LwM2mResource> extractLwM2mResources(Collection<JsonArrayEntry> jsonArrayEntries,\n            LwM2mPath baseName, LwM2mModel model) throws CodecException {\n        if (jsonArrayEntries == null)\n            return Collections.emptyMap();\n\n        // Extract LWM2M resources from JSON resource list\n        Map<Integer, LwM2mResource> lwM2mResourceMap = new HashMap<>();\n        Map<LwM2mPath, Map<Integer, JsonArrayEntry>> multiResourceMap = new HashMap<>();\n        for (JsonArrayEntry resourceElt : jsonArrayEntries) {\n\n            // Build resource path\n            LwM2mPath nodePath = baseName.append(resourceElt.getName());\n\n            // handle LWM2M resources\n            if (nodePath.isResourceInstance()) {\n                // Multi-instance resource\n                // Store multi-instance resource values in a map\n                // we will deal with it later\n                LwM2mPath resourcePath = new LwM2mPath(nodePath.getObjectId(), nodePath.getObjectInstanceId(),\n                        nodePath.getResourceId());\n                Map<Integer, JsonArrayEntry> multiResource = multiResourceMap.get(resourcePath);\n                if (multiResource == null) {\n                    multiResource = new HashMap<>();\n                    multiResourceMap.put(resourcePath, multiResource);\n                }\n                JsonArrayEntry previousResInstance = multiResource.put(nodePath.getResourceInstanceId(), resourceElt);\n                if (previousResInstance != null) {\n                    throw new CodecException(\n                            \"2 RESOURCE_INSTANCE nodes (%s,%s) with the same identifier %d for path %s\",\n                            previousResInstance, resourceElt, nodePath.getResourceInstanceId(), nodePath);\n                }\n            } else if (nodePath.isResource()) {\n                // Single resource\n                Type expectedType = getResourceType(nodePath, model, resourceElt);\n                LwM2mResource res = LwM2mSingleResource.newResource(nodePath.getResourceId(),\n                        parseJsonValue(resourceElt.getResourceValue(), expectedType, nodePath), expectedType);\n                LwM2mResource previousRes = lwM2mResourceMap.put(nodePath.getResourceId(), res);\n                if (previousRes != null) {\n                    throw new CodecException(\"2 RESOURCE nodes (%s,%s) with the same identifier %d for path %s\",\n                            previousRes, res, res.getId(), nodePath);\n                }\n            } else {\n                throw new CodecException(\n                        \"Invalid path [%s] for resource, it should be a resource or a resource instance path\",\n                        nodePath);\n            }\n        }\n\n        // Handle multi-instance resource.\n        for (Map.Entry<LwM2mPath, Map<Integer, JsonArrayEntry>> entry : multiResourceMap.entrySet()) {\n            LwM2mPath resourcePath = entry.getKey();\n            Map<Integer, JsonArrayEntry> jsonEntries = entry.getValue();\n\n            if (jsonEntries != null && !jsonEntries.isEmpty()) {\n                Type expectedType = getResourceType(resourcePath, model, jsonEntries.values().iterator().next());\n                Map<Integer, Object> values = new HashMap<>();\n                for (Entry<Integer, JsonArrayEntry> e : jsonEntries.entrySet()) {\n                    Integer resourceInstanceId = e.getKey();\n                    values.put(resourceInstanceId,\n                            parseJsonValue(e.getValue().getResourceValue(), expectedType, resourcePath));\n                }\n                LwM2mResource resource = LwM2mMultipleResource.newResource(resourcePath.getResourceId(), values,\n                        expectedType);\n                LwM2mResource previousRes = lwM2mResourceMap.put(resourcePath.getResourceId(), resource);\n                if (previousRes != null) {\n                    throw new CodecException(\"2 RESOURCE nodes (%s,%s) with the same identifier %d for path %s\",\n                            previousRes, resource, resource.getId(), resourcePath);\n                }\n            }\n        }\n\n        // If we found nothing, we try to create an empty multi-instance resource\n        if (lwM2mResourceMap.isEmpty() && baseName.isResource()) {\n            ResourceModel resourceModel = model.getResourceModel(baseName.getObjectId(), baseName.getResourceId());\n            // We create it only if this respect the model\n            if (resourceModel == null || resourceModel.multiple) {\n                Type resourceType = getResourceType(baseName, model, null);\n                lwM2mResourceMap.put(baseName.getResourceId(), LwM2mMultipleResource\n                        .newResource(baseName.getResourceId(), new HashMap<Integer, Object>(), resourceType));\n            }\n        }\n\n        return lwM2mResourceMap;\n    }\n"
    },
    "Leshan_core-6": {
        "buggy": "    @SuppressWarnings(\"unchecked\")\n    private static <T extends LwM2mNode> T parseTlv(Tlv[] tlvs, LwM2mPath path, LwM2mModel model, Class<T> nodeClass)\n            throws CodecException {\n        LOG.trace(\"Parsing TLV content for path {}: {}\", path, tlvs);\n\n        // Object\n        if (nodeClass == LwM2mObject.class) {\n            Map<Integer, LwM2mObjectInstance> instances = new HashMap<>(tlvs.length);\n\n            // is it an array of TLV resources?\n            if (tlvs.length > 0 && //\n                    (tlvs[0].getType() == TlvType.MULTIPLE_RESOURCE || tlvs[0].getType() == TlvType.RESOURCE_VALUE)) {\n\n                ObjectModel oModel = model.getObjectModel(path.getObjectId());\n                if (oModel == null) {\n                    LOG.warn(\"No model for object {}. The tlv is decoded assuming this is a single instance object\",\n                            path.getObjectId());\n                    instances.put(0, parseObjectInstanceTlv(tlvs, path.getObjectId(), 0, model));\n                } else if (!oModel.multiple) {\n                    instances.put(0, parseObjectInstanceTlv(tlvs, path.getObjectId(), 0, model));\n                } else {\n                    throw new CodecException(\"Object instance TLV is mandatory for multiple instances object [path:%s]\",\n                            path);\n                }\n\n            } else {\n                for (Tlv tlv : tlvs) {\n                    if (tlv.getType() != TlvType.OBJECT_INSTANCE)\n                        throw new CodecException(\"Expected TLV of type OBJECT_INSTANCE but was %s  [path:%s]\",\n                                tlv.getType().name(), path);\n\n                    LwM2mObjectInstance objectInstance = parseObjectInstanceTlv(tlv.getChildren(), path.getObjectId(),\n                            tlv.getIdentifier(), model);\n                    LwM2mObjectInstance previousObjectInstance = instances.put(objectInstance.getId(), objectInstance);\n                    if (previousObjectInstance != null) {\n                        throw new CodecException(\n                                \"2 OBJECT_INSTANCE nodes (%s,%s) with the same identifier %d for path %s\",\n                                previousObjectInstance, objectInstance, objectInstance.getId(), path);\n                    }\n                }\n            }\n            return (T) new LwM2mObject(path.getObjectId(), instances.values());\n        }\n\n        // Object instance\n        else if (nodeClass == LwM2mObjectInstance.class) {\n\n            if (tlvs.length == 1 && tlvs[0].getType() == TlvType.OBJECT_INSTANCE) {\n                if (path.isObjectInstance() && tlvs[0].getIdentifier() != path.getObjectInstanceId()) {\n                    throw new CodecException(\"Id conflict between path [%s] and instance TLV [%d]\", path,\n                            tlvs[0].getIdentifier());\n                }\n                // object instance TLV\n                return (T) parseObjectInstanceTlv(tlvs[0].getChildren(), path.getObjectId(), tlvs[0].getIdentifier(),\n                        model);\n            } else {\n                // array of TLV resources\n                // try to retrieve the instanceId from the path or the model\n                Integer instanceId = path.getObjectInstanceId();\n                if (instanceId == null) {\n                    // single instance object?\n                    ObjectModel oModel = model.getObjectModel(path.getObjectId());\n                    if (oModel != null && !oModel.multiple) {\n                        instanceId = 0;\n                    } else {\n                        instanceId = LwM2mObjectInstance.UNDEFINED;\n                    }\n                }\n                return (T) parseObjectInstanceTlv(tlvs, path.getObjectId(), instanceId, model);\n            }\n        }\n\n        // Resource\n        else if (nodeClass == LwM2mResource.class) {\n            // The object instance level should not be here, but if it is provided and consistent we tolerate it\n\n            ResourceModel resourceModel = model.getResourceModel(path.getObjectId(), path.getResourceId());\n            if (tlvs.length == 0 && resourceModel != null && !resourceModel.multiple) {\n                // If there is no TlV value and we know that this resource is a single resource we raise an exception\n                // else we consider this is a multi-instance resource\n                throw new CodecException(\"TLV payload is mandatory for single resource %s\", path);\n            } else if (tlvs.length == 1 && tlvs[0].getType() != TlvType.RESOURCE_INSTANCE) {\n                if (path.isResource() && path.getResourceId() != tlvs[0].getIdentifier()) {\n                    throw new CodecException(\"Id conflict between path [%s] and resource TLV [%s]\", path,\n                            tlvs[0].getIdentifier());\n                }\n                LwM2mPath resourcePath = new LwM2mPath(path.getObjectId(), path.getObjectInstanceId(),\n                        tlvs[0].getIdentifier());\n                return (T) parseResourceTlv(tlvs[0], resourcePath, model);\n            } else {\n                Type expectedRscType = getResourceType(path, model);\n                return (T) LwM2mMultipleResource.newResource(path.getResourceId(),\n                        parseTlvValues(tlvs, expectedRscType, path), expectedRscType);\n            }\n        } else {\n            throw new IllegalArgumentException(\"invalid node class: \" + nodeClass);\n        }\n\n    }\n",
        "start": 56,
        "end": 154,
        "fix": "    @SuppressWarnings(\"unchecked\")\n    private static <T extends LwM2mNode> T parseTlv(Tlv[] tlvs, LwM2mPath path, LwM2mModel model, Class<T> nodeClass)\n            throws CodecException {\n        LOG.trace(\"Parsing TLV content for path {}: {}\", path, tlvs);\n\n        // Object\n        if (nodeClass == LwM2mObject.class) {\n            Map<Integer, LwM2mObjectInstance> instances = new HashMap<>(tlvs.length);\n\n            // is it an array of TLV resources?\n            if (tlvs.length > 0 && //\n                    (tlvs[0].getType() == TlvType.MULTIPLE_RESOURCE || tlvs[0].getType() == TlvType.RESOURCE_VALUE)) {\n\n                ObjectModel oModel = model.getObjectModel(path.getObjectId());\n                if (oModel == null) {\n                    LOG.warn(\"No model for object {}. The tlv is decoded assuming this is a single instance object\",\n                            path.getObjectId());\n                    instances.put(0, parseObjectInstanceTlv(tlvs, path.getObjectId(), 0, model));\n                } else if (!oModel.multiple) {\n                    instances.put(0, parseObjectInstanceTlv(tlvs, path.getObjectId(), 0, model));\n                } else {\n                    throw new CodecException(\"Object instance TLV is mandatory for multiple instances object [path:%s]\",\n                            path);\n                }\n\n            } else {\n                for (Tlv tlv : tlvs) {\n                    if (tlv.getType() != TlvType.OBJECT_INSTANCE)\n                        throw new CodecException(\"Expected TLV of type OBJECT_INSTANCE but was %s  [path:%s]\",\n                                tlv.getType().name(), path);\n\n                    LwM2mObjectInstance objectInstance = parseObjectInstanceTlv(tlv.getChildren(), path.getObjectId(),\n                            tlv.getIdentifier(), model);\n                    LwM2mObjectInstance previousObjectInstance = instances.put(objectInstance.getId(), objectInstance);\n                    if (previousObjectInstance != null) {\n                        throw new CodecException(\n                                \"2 OBJECT_INSTANCE nodes (%s,%s) with the same identifier %d for path %s\",\n                                previousObjectInstance, objectInstance, objectInstance.getId(), path);\n                    }\n                }\n            }\n            return (T) new LwM2mObject(path.getObjectId(), instances.values());\n        }\n\n        // Object instance\n        else if (nodeClass == LwM2mObjectInstance.class) {\n\n            if (tlvs.length == 1 && tlvs[0].getType() == TlvType.OBJECT_INSTANCE) {\n                if (path.isObjectInstance() && tlvs[0].getIdentifier() != path.getObjectInstanceId()) {\n                    throw new CodecException(\"Id conflict between path [%s] and instance TLV [object instance id=%d]\",\n                            path, tlvs[0].getIdentifier());\n                }\n                // object instance TLV\n                return (T) parseObjectInstanceTlv(tlvs[0].getChildren(), path.getObjectId(), tlvs[0].getIdentifier(),\n                        model);\n            } else {\n                // array of TLV resources\n                // try to retrieve the instanceId from the path or the model\n                Integer instanceId = path.getObjectInstanceId();\n                if (instanceId == null) {\n                    // single instance object?\n                    ObjectModel oModel = model.getObjectModel(path.getObjectId());\n                    if (oModel != null && !oModel.multiple) {\n                        instanceId = 0;\n                    } else {\n                        instanceId = LwM2mObjectInstance.UNDEFINED;\n                    }\n                }\n                return (T) parseObjectInstanceTlv(tlvs, path.getObjectId(), instanceId, model);\n            }\n        }\n\n        // Resource\n        else if (nodeClass == LwM2mResource.class) {\n            // The object instance level should not be here, but if it is provided and consistent we tolerate it\n            if (tlvs.length == 1 && tlvs[0].getType() == TlvType.OBJECT_INSTANCE) {\n                if (tlvs[0].getIdentifier() != path.getObjectInstanceId()) {\n                    throw new CodecException(\"Id conflict between path [%s] and instance TLV [object instance id=%d]\",\n                            path, tlvs[0].getIdentifier());\n                }\n                tlvs = tlvs[0].getChildren();\n            }\n\n            ResourceModel resourceModel = model.getResourceModel(path.getObjectId(), path.getResourceId());\n            if (tlvs.length == 0 && resourceModel != null && !resourceModel.multiple) {\n                // If there is no TlV value and we know that this resource is a single resource we raise an exception\n                // else we consider this is a multi-instance resource\n                throw new CodecException(\"TLV payload is mandatory for single resource %s\", path);\n            } else if (tlvs.length == 1 && tlvs[0].getType() != TlvType.RESOURCE_INSTANCE) {\n                Tlv tlv = tlvs[0];\n                if (tlv.getType() != TlvType.RESOURCE_VALUE && tlv.getType() != TlvType.MULTIPLE_RESOURCE) {\n                    throw new CodecException(\n                            \"Expected TLV of type RESOURCE_VALUE or MUlTIPLE_RESOURCE but was %s [path:%s]\",\n                            tlv.getType().name(), path);\n                }\n                if (path.isResource() && path.getResourceId() != tlv.getIdentifier()) {\n                    throw new CodecException(\"Id conflict between path [%s] and resource TLV [resource id=%s]\", path,\n                            tlv.getIdentifier());\n                }\n                return (T) parseResourceTlv(tlv, path, model);\n            } else {\n                Type expectedRscType = getResourceType(path, model);\n                return (T) LwM2mMultipleResource.newResource(path.getResourceId(),\n                        parseTlvValues(tlvs, expectedRscType, path), expectedRscType);\n            }\n        } else {\n            throw new IllegalArgumentException(\"invalid node class: \" + nodeClass);\n        }\n\n    }\n"
    },
    "Dosgi_common-expand": {
        "buggy": "    public List<Object> getIntentsFromService(Object serviceBean) {\n        List<Object> intents = new ArrayList<>();\n        if (serviceBean instanceof IntentsProvider) {\n            intents.addAll(((IntentsProvider)serviceBean).getIntents());\n        }\n        return intents;\n    }",
        "start": 195,
        "end": 201,
        "fix": "    public List<Object> getIntentsFromService(Object serviceBean) {\n        List<Object> intents = new ArrayList<>();\n        if (serviceBean instanceof IntentsProvider) {\n            intents.addAll(((IntentsProvider)serviceBean).getIntents());\n        }\n        Features features = serviceBean.getClass().getAnnotation(Features.class);\n        if (features != null && features.classes() != null) {\n            for (Class<?> clazz : features.classes()) {\n                try {\n                    intents.add(clazz.newInstance());\n                } catch (Exception e) {\n                    throw new RuntimeException(\"Could not instantiate feature from class \" + clazz.getName(), e);\n                }\n            }\n        }\n        return intents;\n    }"
    },
    "Tika_app-expand": {
        "buggy" : "         @Override\n         protected ContentHandler getContentHandler(\n                 OutputStream output, Metadata metadata) throws Exception {\n            return getTransformerHandler(output, \"html\", encoding, prettyPrint);\n         }",
        "start" : 166,
        "end" : 170,
        "fix" : "         protected ContentHandler getContentHandler(\n                 OutputStream output, Metadata metadata) throws Exception {\n            return new ExpandedTitleContentHandler(getTransformerHandler(output, \"html\", encoding, prettyPrint));\n         }"
    },
    "JacksonDatatypeJsr310-expand": {
        "buggy" : "    public LocalDate deserialize(JsonParser parser, DeserializationContext context) throws IOException\n    {\n    \tif (parser.hasToken(JsonToken.VALUE_STRING)) {\n            String string = parser.getText().trim();\n            if (string.length() == 0) {\n                return null;\n            }\n            // as per [datatype-jsr310#37], only check for optional (and, incorrect...) time marker 'T'\n            // if we are using default formatter\n            DateTimeFormatter format = _formatter;\n            if (format == DEFAULT_FORMATTER) {\n                // JavaScript by default includes time in JSON serialized Dates (UTC/ISO instant format).\n\t            if (string.contains(\"T\")) {\n\t                return LocalDate.parse(string, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n\t            }\n            }\n            return LocalDate.parse(string, format);\n    \t}\n    \tif (parser.isExpectedStartArrayToken()) {\n    \t\tif (parser.nextToken() == JsonToken.END_ARRAY) {\n    \t\t\treturn null;\n    \t\t}\n            int year = parser.getIntValue();\n\n            parser.nextToken();\n            int month = parser.getIntValue();\n\n            parser.nextToken();\n            int day = parser.getIntValue();\n\n            if (parser.nextToken() != JsonToken.END_ARRAY) {\n                throw context.wrongTokenException(parser, JsonToken.END_ARRAY, \"Expected array to end.\");\n            }\n            return LocalDate.of(year, month, day);\n        }\n\n        throw context.wrongTokenException(parser, JsonToken.START_ARRAY, \"Expected array or string.\");\n    }",
        "start" : 56,
        "end"  : 93,
        "fix" : "    public LocalDate deserialize(JsonParser parser, DeserializationContext context) throws IOException\n    {\n    \tif (parser.hasToken(JsonToken.VALUE_STRING)) {\n            String string = parser.getText().trim();\n            if (string.length() == 0) {\n                return null;\n            }\n            // as per [datatype-jsr310#37], only check for optional (and, incorrect...) time marker 'T'\n            // if we are using default formatter\n            DateTimeFormatter format = _formatter;\n            if (format == DEFAULT_FORMATTER) {\n                // JavaScript by default includes time in JSON serialized Dates (UTC/ISO instant format).\n                if (string.length() > 10 && string.charAt(10) == 'T') {\n                   if (string.endsWith(\"Z\")) {\n                       return LocalDateTime.ofInstant(Instant.parse(string), ZoneOffset.UTC).toLocalDate();\n                   } else {\n                       return LocalDate.parse(string, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n                   }\n                }\n            }\n            return LocalDate.parse(string, format);\n    \t}\n    \tif (parser.isExpectedStartArrayToken()) {\n    \t\tif (parser.nextToken() == JsonToken.END_ARRAY) {\n    \t\t\treturn null;\n    \t\t}\n            int year = parser.getIntValue();\n\n            parser.nextToken();\n            int month = parser.getIntValue();\n\n            parser.nextToken();\n            int day = parser.getIntValue();\n\n            if (parser.nextToken() != JsonToken.END_ARRAY) {\n                throw context.wrongTokenException(parser, JsonToken.END_ARRAY, \"Expected array to end.\");\n            }\n            return LocalDate.of(year, month, day);\n        }\n\n        throw context.wrongTokenException(parser, JsonToken.START_ARRAY, \"Expected array or string.\");\n    }"
    },
    "JacksonModuleAfterburner-expand": {
        "buggy": "    protected PropertyAccessorCollector findProperties(Class<?> beanClass,\n            SerializationConfig config, List<BeanPropertyWriter> beanProperties)\n    {\n        PropertyAccessorCollector collector = new PropertyAccessorCollector(beanClass);\n        ListIterator<BeanPropertyWriter> it = beanProperties.listIterator();\n        while (it.hasNext()) {\n            BeanPropertyWriter bpw = it.next();\n            Class<?> type = bpw.getPropertyType();\n            AnnotatedMember member = bpw.getMember();\n\n            // 11-Sep-2015, tatu: Let's skip virtual members (related to #57)\n            // We can't access private fields or methods, skip:\n            if (Modifier.isPrivate(member.getMember().getModifiers())) {\n                continue;\n            }\n            // (although, interestingly enough, can seem to access private classes...)\n            \n            // 30-Jul-2012, tatu: [Issue-6]: Needs to skip custom serializers, if any.\n            if (bpw.hasSerializer()) {\n                if (!isDefaultSerializer(config, bpw.getSerializer())) {\n                    continue;\n                }\n            }\n            // [#9]: also skip unwrapping stuff...\n            if (bpw.isUnwrapping()) {\n                continue;\n            }\n            // [#51]: and any sub-classes as well\n            /* 04-Mar-2015, tatu: This might be too restrictive, as core databind has some \n             *   other sub-classes; if this becomes problematic may start using annotation\n             *   to indicate \"standard\" implementations. But for now this solves the issue.\n             */\n            if (bpw.getClass() != BeanPropertyWriter.class) {\n                continue;\n            }\n            \n            boolean isMethod = (member instanceof AnnotatedMethod);\n            if (type.isPrimitive()) {\n                if (type == Integer.TYPE) {\n\n                    if (isMethod) {\n                        it.set(collector.addIntGetter(bpw));\n                    } else {\n                        it.set(collector.addIntField(bpw));\n                    }\n                } else if (type == Long.TYPE) {\n                    if (isMethod) {\n                        it.set(collector.addLongGetter(bpw));\n                    } else {\n                        it.set(collector.addLongField(bpw));\n                    }\n                } else if (type == Boolean.TYPE) {\n                    if (isMethod) {\n                        it.set(collector.addBooleanGetter(bpw));\n                    } else {\n                        it.set(collector.addBooleanField(bpw));\n                    }\n                }\n            } else {\n                if (type == String.class) {\n                    if (isMethod) {\n                        it.set(collector.addStringGetter(bpw));\n                    } else {\n                        it.set(collector.addStringField(bpw));\n                    }\n                } else { // any other Object types; we can at least call accessor\n                    if (isMethod) {\n                        it.set(collector.addObjectGetter(bpw));\n                    } else {\n                        it.set(collector.addObjectField(bpw));\n                    }\n                }\n            }\n        }\n        return collector;\n    }\n",
        "start": 70,
        "end": 145,
        "fix": "    protected PropertyAccessorCollector findProperties(Class<?> beanClass,\n            SerializationConfig config, List<BeanPropertyWriter> beanProperties)\n    {\n        PropertyAccessorCollector collector = new PropertyAccessorCollector(beanClass);\n        ListIterator<BeanPropertyWriter> it = beanProperties.listIterator();\n        while (it.hasNext()) {\n            BeanPropertyWriter bpw = it.next();\n            Class<?> type = bpw.getPropertyType();\n            AnnotatedMember member = bpw.getMember();\n\n            Member jdkMember = member.getMember();\n            // 11-Sep-2015, tatu: Let's skip virtual members (related to #57)\n            if (jdkMember == null) {\n                continue;\n            }\n            // We can't access private fields or methods, skip:\n            if (Modifier.isPrivate(jdkMember.getModifiers())) {\n                continue;\n            }\n            // (although, interestingly enough, can seem to access private classes...)\n            \n            // 30-Jul-2012, tatu: [Issue-6]: Needs to skip custom serializers, if any.\n            if (bpw.hasSerializer()) {\n                if (!isDefaultSerializer(config, bpw.getSerializer())) {\n                    continue;\n                }\n            }\n            // [#9]: also skip unwrapping stuff...\n            if (bpw.isUnwrapping()) {\n                continue;\n            }\n            // [#51]: and any sub-classes as well\n            /* 04-Mar-2015, tatu: This might be too restrictive, as core databind has some \n             *   other sub-classes; if this becomes problematic may start using annotation\n             *   to indicate \"standard\" implementations. But for now this solves the issue.\n             */\n            if (bpw.getClass() != BeanPropertyWriter.class) {\n                continue;\n            }\n            \n            boolean isMethod = (member instanceof AnnotatedMethod);\n            if (type.isPrimitive()) {\n                if (type == Integer.TYPE) {\n\n                    if (isMethod) {\n                        it.set(collector.addIntGetter(bpw));\n                    } else {\n                        it.set(collector.addIntField(bpw));\n                    }\n                } else if (type == Long.TYPE) {\n                    if (isMethod) {\n                        it.set(collector.addLongGetter(bpw));\n                    } else {\n                        it.set(collector.addLongField(bpw));\n                    }\n                } else if (type == Boolean.TYPE) {\n                    if (isMethod) {\n                        it.set(collector.addBooleanGetter(bpw));\n                    } else {\n                        it.set(collector.addBooleanField(bpw));\n                    }\n                }\n            } else {\n                if (type == String.class) {\n                    if (isMethod) {\n                        it.set(collector.addStringGetter(bpw));\n                    } else {\n                        it.set(collector.addStringField(bpw));\n                    }\n                } else { // any other Object types; we can at least call accessor\n                    if (isMethod) {\n                        it.set(collector.addObjectGetter(bpw));\n                    } else {\n                        it.set(collector.addObjectField(bpw));\n                    }\n                }\n            }\n        }\n        return collector;\n    }\n"
    },
    "Switchyard_admin-expand": {
        "buggy": "     public String getValue() {\n         Node text_node = getTextNode(false);\n        return text_node != null ? text_node.getNodeValue() : null;\n     }",
        "start": 120,
        "end": 123,
        "fix": "     public String getValue() {\n         Node text_node = getTextNode(false);\n        if (text_node instanceof Text) {\n            return ((Text)text_node).getWholeText();\n        } else if (text_node != null) {\n            return text_node.getNodeValue();\n        }\n        return null;\n     }"
    },
    "Switchyard_validate-expand": {
        "buggy": "     public String getValue() {\n         Node text_node = getTextNode(false);\n        return text_node != null ? text_node.getNodeValue() : null;\n     }",
        "start": 120,
        "end": 123,
        "fix": "     public String getValue() {\n         Node text_node = getTextNode(false);\n        if (text_node instanceof Text) {\n            return ((Text)text_node).getWholeText();\n        } else if (text_node != null) {\n            return text_node.getNodeValue();\n        }\n        return null;\n     }"
    },
    "Qpidjms_client-expand":{
        "buggy": "     public void setJMSCorrelationID(String correlationId) throws JMSException\n     {\n        setJMSCorrelationIDAsBytes(correlationId == null ? null : correlationId.getBytes());\n     }",
        "start": 253,
        "end": 256,
        "fix": "     public void setJMSCorrelationID(String correlationId) throws JMSException\n     {\n        setJMSCorrelationIDAsBytes(correlationId == null ? null : correlationId.getBytes(StandardCharsets.UTF_8));\n     }"
    },
    "Tiles_api-expand": {
        "buggy": "    /** {@inheritDoc} */\n    public void init(Map<String, String> parameters) {\n        String defaultRendererParam = parameters.get(DEFAULT_RENDERER_INIT_PARAM);\n        if (defaultRendererParam == null) {\n            defaultRendererParam = DEFAULT_RENDERER_CLASS_NAME;\n        }\n        defaultRenderer = (AttributeRenderer) ClassUtil\n                .instantiate(defaultRendererParam);\n        initializeRenderer(defaultRenderer);\n        String typeRenderersParam = parameters.get(TYPE_RENDERERS_INIT_PARAM);\n        Map<String, String> completeParams = new HashMap<String, String>(\n                DEFAULT_TYPE_2_RENDERER);\n        if (typeRenderersParam != null) {\n            String[] pairs = typeRenderersParam.split(\"\\\\s*;\\\\s\");\n            for (int i = 0; i < pairs.length; i++) {\n                String[] pair = pairs[i].split(\"\\\\s*,\\\\s*\");\n                if (pair == null || pair.length != 2) {\n                    throw new RendererException(\"The string '\" + pairs[i]\n                            + \"' is not a valid type-renderer pair\");\n                }\n                completeParams.put(pair[0], pair[1]);\n            }\n        }\n\n        for (Map.Entry<String, String> entry : completeParams.entrySet()) {\n            AttributeRenderer renderer = (AttributeRenderer) ClassUtil\n                    .instantiate(entry.getValue());\n            initializeRenderer(renderer);\n            renderers.put(entry.getKey(), renderer);\n        }\n    }\n",
        "start": 141,
        "end": 171,
        "fix": "    /** {@inheritDoc} */\n    public void init(Map<String, String> parameters) {\n        String defaultRendererParam = parameters.get(DEFAULT_RENDERER_INIT_PARAM);\n        if (defaultRendererParam == null) {\n            defaultRendererParam = DEFAULT_RENDERER_CLASS_NAME;\n        }\n        defaultRenderer = (AttributeRenderer) ClassUtil\n                .instantiate(defaultRendererParam);\n        initializeRenderer(defaultRenderer);\n        String typeRenderersParam = parameters.get(TYPE_RENDERERS_INIT_PARAM);\n        Map<String, String> completeParams = new HashMap<String, String>(\n                DEFAULT_TYPE_2_RENDERER);\n        if (typeRenderersParam != null) {\n            String[] pairs = typeRenderersParam.split(\"\\\\s*;\\\\s*\");\n            for (int i = 0; i < pairs.length; i++) {\n                String[] pair = pairs[i].split(\"\\\\s*,\\\\s*\");\n                if (pair == null || pair.length != 2) {\n                    throw new RendererException(\"The string '\" + pairs[i]\n                            + \"' is not a valid type-renderer pair\");\n                }\n                completeParams.put(pair[0], pair[1]);\n            }\n        }\n\n        for (Map.Entry<String, String> entry : completeParams.entrySet()) {\n            AttributeRenderer renderer = (AttributeRenderer) ClassUtil\n                    .instantiate(entry.getValue());\n            initializeRenderer(renderer);\n            renderers.put(entry.getKey(), renderer);\n        }\n    }\n"
    },
    "Wicket_spring-expand": {
        "buggy": "\t/**\n\t * Stringizes this url\n\t * \n\t * @param mode\n\t *            {@link StringMode} that determins how to stringize the url\n\t * @param charset\n\t *            charset\n\t * @return sringized version of this url\n\t * \n\t */\n\tpublic String toString(StringMode mode, Charset charset)\n\t{\n\t\tStringBuilder result = new StringBuilder();\n\t\tfinal String path = getPath(charset);\n\n\t\tif (StringMode.FULL == mode)\n\t\t{\n\t\t\tif (Strings.isEmpty(host))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it does not have a host set.\");\n\t\t\t}\n\n\t\t\tif (Strings.isEmpty(protocol) == false)\n\t\t\t{\n\t\t\t\tresult.append(protocol);\n\t\t\t\tresult.append(\"://\");\n\t\t\t}\n\t\t\telse if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)\n\t\t\t{\n\t\t\t\tresult.append(\"//\");\n\t\t\t}\n\t\t\tresult.append(host);\n\n\t\t\tif (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false)\n\t\t\t{\n\t\t\t\tresult.append(':');\n\t\t\t\tresult.append(port);\n\t\t\t}\n\n\t\t\tif (path.contains(\"..\"))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n\t\t\t}\n\n\t\t\tif (!path.startsWith(\"/\"))\n\t\t\t{\n\t\t\t\tresult.append('/');\n\t\t\t}\n\n\t\t}\n\n\n\t\tresult.append(path);\n\t\tresult.append(getQueryString(charset));\n\t\treturn result.toString();\n\t}\n",
        "start": 637,
        "end": 694,
        "fix": "\t/**\n\t * Stringizes this url\n\t * \n\t * @param mode\n\t *            {@link StringMode} that determins how to stringize the url\n\t * @param charset\n\t *            charset\n\t * @return sringized version of this url\n\t * \n\t */\n\tpublic String toString(StringMode mode, Charset charset)\n\t{\n\t\tStringBuilder result = new StringBuilder();\n\t\tfinal String path = getPath(charset);\n\n\t\tif (StringMode.FULL == mode)\n\t\t{\n\t\t\tif (Strings.isEmpty(host))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it does not have a host set.\");\n\t\t\t}\n\n\t\t\tif (Strings.isEmpty(protocol) == false)\n\t\t\t{\n\t\t\t\tresult.append(protocol);\n\t\t\t\tresult.append(\"://\");\n\t\t\t}\n\t\t\telse if (Strings.isEmpty(protocol) && Strings.isEmpty(host) == false)\n\t\t\t{\n\t\t\t\tresult.append(\"//\");\n\t\t\t}\n\t\t\tresult.append(host);\n\n\t\t\tif (port != null && port.equals(getDefaultPortForProtocol(protocol)) == false)\n\t\t\t{\n\t\t\t\tresult.append(':');\n\t\t\t\tresult.append(port);\n\t\t\t}\n\n\t\t\tif (segments.contains(\"..\"))\n\t\t\t{\n\t\t\t\tthrow new IllegalStateException(\"Cannot render this url in \" +\n\t\t\t\t\tStringMode.FULL.name() + \" mode because it has a `..` segment: \" + toString());\n\t\t\t}\n\n\t\t\tif (!path.startsWith(\"/\"))\n\t\t\t{\n\t\t\t\tresult.append('/');\n\t\t\t}\n\n\t\t}\n\n\n\t\tresult.append(path);\n\t\tresult.append(getQueryString(charset));\n\t\treturn result.toString();\n\t}\n"
    },
    "Jcodemodel-expand":{
        "buggy": "  protected void build (@Nonnull @WillNotClose final OutputStream aOS) throws IOException\n  {\n    // serialize the obj into an OutputStream\n    try (final ObjectOutputStream oos = new ObjectOutputStream (aOS)\n    {\n      @Override\n      public void close ()\n      {}\n    })\n    {\n      oos.writeObject (m_aObj);\n    }\n  }",
        "start": 90,
        "end": 102,
        "fix": "  protected void build (@Nonnull @WillNotClose final OutputStream aOS) throws IOException\n  {\n    // serialize the obj into an OutputStream\n    try (final ObjectOutputStream oos = new ObjectOutputStream (aOS)\n    {\n      @Override\n      public void close ()\n      {}\n    })\n    {\n      oos.writeObject (m_aObj);\n      oos.flush();\n    }\n  }"
    },
    "Xades4j-expand": {
        "buggy": "    private static String getLocationUrl(XmlSigPolicyQualifiersListType sigPolicyQualifiers) throws PropertyUnmarshalException\n    {\n        String locationUrl = null;\n        \n        List<XmlAnyType> xmlQualifiers = sigPolicyQualifiers.getSigPolicyQualifier();\n        for (XmlAnyType xmlQualifier : xmlQualifiers)\n        {\n            List content = xmlQualifier.getContent();\n            if (content.size() == 1 && content.get(0) instanceof JAXBElement)\n            {\n                JAXBElement xmlSPURI = (JAXBElement)content.get(0);\n                if (xmlSPURI.getName().getLocalPart().equals(\"SPURI\") && xmlSPURI.getName().getNamespaceURI().equals(QualifyingProperty.XADES_XMLNS))\n                {\n                    return (String)xmlSPURI.getValue();\n                }\n            }\n        }\n        \n        return null;\n    }",
        "start": 67,
        "end": 86,
        "fix": "    private static String getLocationUrl(XmlSignaturePolicyIdType xmlPolicyId) throws PropertyUnmarshalException\n    {\n        XmlSigPolicyQualifiersListType sigPolicyQualifiers = xmlPolicyId.getSigPolicyQualifiers();\n        if(null == sigPolicyQualifiers)\n        {\n            return null;\n        }\n        \n        List<XmlAnyType> xmlQualifiers = sigPolicyQualifiers.getSigPolicyQualifier();\n        for (XmlAnyType xmlQualifier : xmlQualifiers)\n        {\n            List content = xmlQualifier.getContent();\n            if (content.size() == 1 && content.get(0) instanceof JAXBElement)\n            {\n                JAXBElement xmlSPURI = (JAXBElement)content.get(0);\n                if (xmlSPURI.getName().getLocalPart().equals(\"SPURI\") && xmlSPURI.getName().getNamespaceURI().equals(QualifyingProperty.XADES_XMLNS))\n                {\n                    return (String)xmlSPURI.getValue();\n                }\n            }\n        }\n        \n        return null;\n    }"
    }
}