Repair : closure_66
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/0.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/0.java
Tested:0 patches
Compile failed:0 patches
Compilation rate:NaN

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/1.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/1.java
Current actions:
INSERT:
3:if(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n){
return ;
}
TO:
1

Following are 1th generated patches:
Validating 200 patches...
Current actions:
INSERT:
8:if(leftType.isString()){
ensureTyped(t,n,STRING_TYPE);
return ;
}
TO:
4

Following are 2th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 16typeable=false;

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 28break;

DELETE:
Original line: 29case Token.REF_SPECIAL :

INSERT:
41:if(leftType.isString()&&leftType.matchesNumberContext()){
ensureTyped(t,n,NUMBER_TYPE);
return ;
}
TO:
4

DELETE:
Original line: 42if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}

INSERT:
45:if(leftType.isString()&&leftType.matchesBooleanContext()){
ensureTyped(t,n,STRING_TYPE);
return ;
}
TO:
4

DELETE:
Original line: 54break;

INSERT:
55:return ;
TO:
4

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 84break;

INSERT:
90:}

TO:
15

DELETE:
Original line: 94case Token.BITNOT :

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

INSERT:
100:ensureTyped(t,n,NUMBER_TYPE);
TO:
15

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 109{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

INSERT:
113:return ;
TO:
15

INSERT:
120:ensureTyped(t,n,NUMBER_TYPE);
TO:
15

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 127leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 144validator.expectNumber(t,n,leftType,"left side of numeric comparison");

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 170case Token.INSTANCEOF :

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 182break;

DELETE:
Original line: 189case Token.ASSIGN_BITXOR :

DELETE:
Original line: 194case Token.LSH :

DELETE:
Original line: 201case Token.BITAND :

DELETE:
Original line: 207case Token.DELPROP :

DELETE:
Original line: 220{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 244typeable=false;

DELETE:
Original line: 257ensureTyped(t,n);

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

Tested:201 patches
Compile failed:200 patches
Compilation rate:0.004975124378109453
PNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/2.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/2.java
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:Node left=n.getFirstChild();
TO:
1

DELETE:
Original line: 5Node left,right;

UPDATE
FROM:
4:JSType leftType,rightType;
TO:
5:JSType leftType=getJSType(left);

INSERT:
6:JSType rightType=getJSType(right);
TO:
4

INSERT:
7:validator.expectLValue(t,n,left,leftType);
TO:
4

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
8:JSType rightValueType=validator.expectAssignableType(t,right,rightType,leftType,"right side of assignment",false);
TO:
4

INSERT:
9:n.setJSType(rightValueType);
TO:
4

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 1th generated patches:
Validating 200 patches...
Tested:202 patches
Compile failed:201 patches
Compilation rate:0.0049504950495049506
N
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/3.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/3.java
Current actions:
INSERT:
5:if(typeNode==null){
return true;
}
TO:
1

Following are 1th generated patches:
Validating 200 patches...
Current actions:
INSERT:
9:if(!type.isExplicitAnyType()&&!type.isUnknownType()){
ensureTyped(t,n,type);
}
TO:
1

Following are 2th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:String name=n.getString();
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

INSERT:
4:Node typeNode=findTypeNode(name,n);
TO:
1

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
8:JSType type=getJSType(typeNode);
TO:
1

INSERT:
10:ensureTyped(t,n,type);
TO:
1

INSERT:
12:return false;
TO:
1

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 3th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 34break;

DELETE:
Original line: 157validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 218break;

Following are 4th generated patches:
Validating 4 patches...
Current actions:
DELETE:
Original line: 4JSType leftType,rightType;

INSERT:
6:return true;
TO:
1

INSERT:
12:return false;
TO:
1

DELETE:
Original line: 15else{
typeable=false;
}

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 28break;

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 43ensureTyped(t,n,STRING_TYPE);

DELETE:
Original line: 45break;

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 48break;

DELETE:
Original line: 61typeable=false;

DELETE:
Original line: 64visitVar(t,n);

DELETE:
Original line: 65typeable=false;

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 74break;

DELETE:
Original line: 77typeable=false;

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 92ensureTyped(t,n,STRING_TYPE);

DELETE:
Original line: 103left=n.getFirstChild();

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 105ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 112JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 119report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());

DELETE:
Original line: 122break;

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 129JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 131if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}

DELETE:
Original line: 134ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 135break;

DELETE:
Original line: 138case Token.LE :

DELETE:
Original line: 144validator.expectNumber(t,n,leftType,"left side of numeric comparison");

DELETE:
Original line: 153validator.expectString(t,n,leftType,message);

DELETE:
Original line: 156validator.expectString(t,n,rightType,message);

DELETE:
Original line: 157validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));

DELETE:
Original line: 160break;

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 169break;

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 183case Token.ASSIGN_LSH :

DELETE:
Original line: 184case Token.ASSIGN_RSH :

DELETE:
Original line: 185case Token.ASSIGN_URSH :

DELETE:
Original line: 189case Token.ASSIGN_BITXOR :

DELETE:
Original line: 190case Token.ASSIGN_BITAND :

DELETE:
Original line: 191case Token.ASSIGN_SUB :

DELETE:
Original line: 197case Token.DIV :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 216validator.expectSwitchMatchesCase(t,n,switchType,caseType);

DELETE:
Original line: 221Node child=n.getFirstChild();

DELETE:
Original line: 225break;

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 240case Token.DEFAULT :

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 255case Token.OR :

DELETE:
Original line: 259else{
if((n.getType()==Token.OBJECTLIT)&&(parent.getJSType() instanceof EnumType)){
ensureTyped(t,n,parent.getJSType());
}
else{
ensureTyped(t,n);
}
}

DELETE:
Original line: 267if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}

DELETE:
Original line: 273default :

Tested:206 patches
Compile failed:203 patches
Compilation rate:0.014563106796116505
PPNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/4.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/4.java
Tested:206 patches
Compile failed:203 patches
Compilation rate:0.014563106796116505

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/5.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/5.java
Current actions:
DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 28break;

DELETE:
Original line: 86ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 105ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 135break;

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 230case Token.LABEL :

DELETE:
Original line: 245break;

Following are 1th generated patches:
Validating 13 patches...
Current actions:
DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 12if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}

DELETE:
Original line: 18break;

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 40break;

DELETE:
Original line: 43ensureTyped(t,n,STRING_TYPE);

DELETE:
Original line: 50ensureTyped(t,n,ARRAY_TYPE);

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 76visitReturn(t,n);

DELETE:
Original line: 87break;

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 97report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());

DELETE:
Original line: 103left=n.getFirstChild();

DELETE:
Original line: 106break;

DELETE:
Original line: 108case Token.NE :

DELETE:
Original line: 112JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 115if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}

DELETE:
Original line: 128rightType=getJSType(n.getLastChild());

DELETE:
Original line: 129JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 149if(leftType.matchesNumberContext()&&rightType.matchesNumberContext()){
}

DELETE:
Original line: 176validator.expectActualObject(t,right,rightType,"instanceof requires an object");

DELETE:
Original line: 183case Token.ASSIGN_LSH :

DELETE:
Original line: 187case Token.ASSIGN_MOD :

DELETE:
Original line: 190case Token.ASSIGN_BITAND :

DELETE:
Original line: 192case Token.ASSIGN_ADD :

DELETE:
Original line: 198case Token.MOD :

DELETE:
Original line: 202case Token.SUB :

DELETE:
Original line: 205visitBinaryOperator(n.getType(),t,n);

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 215JSType caseType=getJSType(n.getFirstChild());

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 227case Token.FUNCTION :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 237case Token.EXPR_RESULT :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 243case Token.THROW :

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 252case Token.AND :

DELETE:
Original line: 256if(n.getJSType()!=null){
ensureTyped(t,n);
}

DELETE:
Original line: 269visitObjLitKey(t,key,n);

DELETE:
Original line: 273default :

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

Following are 2th generated patches:
Validating 47 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 15else{
typeable=false;
}

DELETE:
Original line: 34break;

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 56visitGetProp(t,n,parent);

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 87break;

DELETE:
Original line: 94case Token.BITNOT :

DELETE:
Original line: 95childType=getJSType(n.getFirstChild());

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 113JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 114TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);

DELETE:
Original line: 130JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 132report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());

DELETE:
Original line: 149if(leftType.matchesNumberContext()&&rightType.matchesNumberContext()){
}

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 171left=n.getFirstChild();

DELETE:
Original line: 182break;

DELETE:
Original line: 183case Token.ASSIGN_LSH :

DELETE:
Original line: 184case Token.ASSIGN_RSH :

DELETE:
Original line: 185case Token.ASSIGN_URSH :

DELETE:
Original line: 187case Token.ASSIGN_MOD :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 203case Token.ADD :

DELETE:
Original line: 206break;

DELETE:
Original line: 211ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 213case Token.CASE :

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 219case Token.WITH :

DELETE:
Original line: 231case Token.LABEL_NAME :

DELETE:
Original line: 242case Token.DEBUGGER :

DELETE:
Original line: 247case Token.FOR :

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 251break;

DELETE:
Original line: 263else{
ensureTyped(t,n);
}

DELETE:
Original line: 275ensureTyped(t,n);

DELETE:
Original line: 276break;

Following are 3th generated patches:
Validating 42 patches...
Current actions:
DELETE:
Original line: 9typeable=visitName(t,n,parent);

DELETE:
Original line: 13ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 18break;

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 46case Token.GET :

DELETE:
Original line: 49case Token.ARRAYLIT :

DELETE:
Original line: 54break;

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 77typeable=false;

DELETE:
Original line: 78break;

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 93break;

DELETE:
Original line: 95childType=getJSType(n.getFirstChild());

DELETE:
Original line: 97report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 109{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 122break;

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 132report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());

DELETE:
Original line: 135break;

DELETE:
Original line: 146if(leftType.isNumber()){
validator.expectNumber(t,n,rightType,"right side of numeric comparison");
}

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 168ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 169break;

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 181typeable=false;

DELETE:
Original line: 184case Token.ASSIGN_RSH :

DELETE:
Original line: 191case Token.ASSIGN_SUB :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 203case Token.ADD :

DELETE:
Original line: 209report(t,n,BAD_DELETE);

DELETE:
Original line: 212break;

DELETE:
Original line: 216validator.expectSwitchMatchesCase(t,n,switchType,caseType);

DELETE:
Original line: 219case Token.WITH :

DELETE:
Original line: 220{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 233case Token.BREAK :

DELETE:
Original line: 242case Token.DEBUGGER :

DELETE:
Original line: 247case Token.FOR :

DELETE:
Original line: 255case Token.OR :

DELETE:
Original line: 259else{
if((n.getType()==Token.OBJECTLIT)&&(parent.getJSType() instanceof EnumType)){
ensureTyped(t,n,parent.getJSType());
}
else{
ensureTyped(t,n);
}
}

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

Following are 4th generated patches:
Validating 47 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:return (n.getType()==Token.NAME)||(n.getType()==Token.GETPROP);
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 8case Token.NAME :

DELETE:
Original line: 9typeable=visitName(t,n,parent);

DELETE:
Original line: 10break;

DELETE:
Original line: 11case Token.LP :

DELETE:
Original line: 12if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}

DELETE:
Original line: 21break;

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 25break;

DELETE:
Original line: 26case Token.THIS :

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 28break;

DELETE:
Original line: 29case Token.REF_SPECIAL :

DELETE:
Original line: 30ensureTyped(t,n);

DELETE:
Original line: 31break;

DELETE:
Original line: 35case Token.NULL :

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 37break;

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 40break;

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 42if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}

DELETE:
Original line: 45break;

DELETE:
Original line: 46case Token.GET :

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 48break;

DELETE:
Original line: 49case Token.ARRAYLIT :

DELETE:
Original line: 50ensureTyped(t,n,ARRAY_TYPE);

DELETE:
Original line: 51break;

DELETE:
Original line: 52case Token.REGEXP :

DELETE:
Original line: 54break;

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 56visitGetProp(t,n,parent);

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 58break;

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 61typeable=false;

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 64visitVar(t,n);

DELETE:
Original line: 66break;

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 69typeable=true;

DELETE:
Original line: 70break;

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 72visitCall(t,n);

DELETE:
Original line: 73typeable=!NodeUtil.isExpressionNode(parent);

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 76visitReturn(t,n);

DELETE:
Original line: 77typeable=false;

DELETE:
Original line: 78break;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 82validator.expectNumber(t,left,getJSType(left),"increment/decrement");

DELETE:
Original line: 83ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 84break;

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 87break;

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 91case Token.TYPEOF :

DELETE:
Original line: 92ensureTyped(t,n,STRING_TYPE);

DELETE:
Original line: 93break;

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 99ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 100break;

DELETE:
Original line: 102case Token.NEG :

DELETE:
Original line: 103left=n.getFirstChild();

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 107case Token.EQ :

DELETE:
Original line: 108case Token.NE :

DELETE:
Original line: 109{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 110leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 112JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 115if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}

DELETE:
Original line: 121ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 122break;

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 128rightType=getJSType(n.getLastChild());

DELETE:
Original line: 130JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 131if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}

DELETE:
Original line: 134ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 138case Token.LE :

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 141leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 143if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}

DELETE:
Original line: 159ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 161case Token.IN :

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 164leftType=getJSType(left);

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 166validator.expectObject(t,n,rightType,"'in' requires an object");

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 168ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 170case Token.INSTANCEOF :

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 176validator.expectActualObject(t,right,rightType,"instanceof requires an object");

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 182break;

DELETE:
Original line: 183case Token.ASSIGN_LSH :

DELETE:
Original line: 184case Token.ASSIGN_RSH :

DELETE:
Original line: 185case Token.ASSIGN_URSH :

DELETE:
Original line: 186case Token.ASSIGN_DIV :

DELETE:
Original line: 187case Token.ASSIGN_MOD :

DELETE:
Original line: 188case Token.ASSIGN_BITOR :

DELETE:
Original line: 189case Token.ASSIGN_BITXOR :

DELETE:
Original line: 190case Token.ASSIGN_BITAND :

DELETE:
Original line: 192case Token.ASSIGN_ADD :

DELETE:
Original line: 193case Token.ASSIGN_MUL :

DELETE:
Original line: 195case Token.RSH :

DELETE:
Original line: 196case Token.URSH :

DELETE:
Original line: 197case Token.DIV :

DELETE:
Original line: 198case Token.MOD :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 201case Token.BITAND :

DELETE:
Original line: 202case Token.SUB :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 207case Token.DELPROP :

DELETE:
Original line: 208if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}

DELETE:
Original line: 211ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 212break;

DELETE:
Original line: 213case Token.CASE :

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 215JSType caseType=getJSType(n.getFirstChild());

DELETE:
Original line: 216validator.expectSwitchMatchesCase(t,n,switchType,caseType);

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 218break;

DELETE:
Original line: 220{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}

DELETE:
Original line: 221Node child=n.getFirstChild();

DELETE:
Original line: 222childType=getJSType(child);

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 228visitFunction(t,n);

DELETE:
Original line: 229break;

DELETE:
Original line: 230case Token.LABEL :

DELETE:
Original line: 231case Token.LABEL_NAME :

DELETE:
Original line: 232case Token.SWITCH :

DELETE:
Original line: 233case Token.BREAK :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 236case Token.SCRIPT :

DELETE:
Original line: 237case Token.EXPR_RESULT :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 240case Token.DEFAULT :

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 242case Token.DEBUGGER :

DELETE:
Original line: 245break;

DELETE:
Original line: 247case Token.FOR :

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 249case Token.WHILE :

DELETE:
Original line: 251break;

DELETE:
Original line: 252case Token.AND :

DELETE:
Original line: 253case Token.HOOK :

DELETE:
Original line: 254case Token.OBJECTLIT :

DELETE:
Original line: 255case Token.OR :

DELETE:
Original line: 259else{
if((n.getType()==Token.OBJECTLIT)&&(parent.getJSType() instanceof EnumType)){
ensureTyped(t,n,parent.getJSType());
}
else{
ensureTyped(t,n);
}
}

DELETE:
Original line: 267if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}

DELETE:
Original line: 273default :

DELETE:
Original line: 274report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));

DELETE:
Original line: 275ensureTyped(t,n);

DELETE:
Original line: 276break;

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Tested:210 patches
Compile failed:207 patches
Compilation rate:0.014285714285714285
NNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/6.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/6.java
Tested:210 patches
Compile failed:207 patches
Compilation rate:0.014285714285714285

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/7.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/7.java
Current actions:
INSERT:
20:if(isReference(left)){
visitAssignToReference(t,n);
}
TO:
193

Following are 1th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:Node left=n.getFirstChild();
TO:
1

INSERT:
4:Node right=n.getLastChild();
TO:
1

DELETE:
Original line: 8case Token.NAME :

DELETE:
Original line: 15else{
typeable=false;
}

INSERT:
19:case Token.ASSIGN :
TO:
193

DELETE:
Original line: 21break;

DELETE:
Original line: 23case Token.FALSE :

INSERT:
24:report(t,n,BAD_ASSIGN);
TO:
263

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

INSERT:
25:}

TO:
263

DELETE:
Original line: 26case Token.THIS :

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 29case Token.REF_SPECIAL :

DELETE:
Original line: 32case Token.GET_REF :

DELETE:
Original line: 33ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 35case Token.NULL :

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 37break;

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 43ensureTyped(t,n,STRING_TYPE);

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 51break;

DELETE:
Original line: 52case Token.REGEXP :

DELETE:
Original line: 53ensureTyped(t,n,REGEXP_TYPE);

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 58break;

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 61typeable=false;

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 65typeable=false;

DELETE:
Original line: 66break;

DELETE:
Original line: 67case Token.NEW :

DELETE:
Original line: 70break;

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 77typeable=false;

DELETE:
Original line: 78break;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 82validator.expectNumber(t,left,getJSType(left),"increment/decrement");

DELETE:
Original line: 83ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 84break;

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 94case Token.BITNOT :

DELETE:
Original line: 99ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 100break;

DELETE:
Original line: 103left=n.getFirstChild();

DELETE:
Original line: 110leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 112JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 114TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);

DELETE:
Original line: 132report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());

DELETE:
Original line: 134ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 146if(leftType.isNumber()){
validator.expectNumber(t,n,rightType,"right side of numeric comparison");
}

DELETE:
Original line: 160break;

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 166validator.expectObject(t,n,rightType,"'in' requires an object");

DELETE:
Original line: 171left=n.getFirstChild();

DELETE:
Original line: 172right=n.getLastChild();

DELETE:
Original line: 175validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 194case Token.LSH :

DELETE:
Original line: 196case Token.URSH :

DELETE:
Original line: 201case Token.BITAND :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 212break;

DELETE:
Original line: 216validator.expectSwitchMatchesCase(t,n,switchType,caseType);

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 219case Token.WITH :

DELETE:
Original line: 220{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}

DELETE:
Original line: 221Node child=n.getFirstChild();

DELETE:
Original line: 224typeable=false;

DELETE:
Original line: 233case Token.BREAK :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 237case Token.EXPR_RESULT :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 242case Token.DEBUGGER :

DELETE:
Original line: 243case Token.THROW :

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 249case Token.WHILE :

DELETE:
Original line: 252case Token.AND :

DELETE:
Original line: 255case Token.OR :

DELETE:
Original line: 264ensureTyped(t,n);

DELETE:
Original line: 267if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}

DELETE:
Original line: 276break;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

Following are 2th generated patches:
Validating 200 patches...
Tested:411 patches
Compile failed:408 patches
Compilation rate:0.0072992700729927005
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/8.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/8.java
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:visitAssignOrBinop(t,n);
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

INSERT:
4:ensureTyped(t,n);
TO:
1

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 1th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:visitAssignOrBinop(t,n);
TO:
1

INSERT:
4:ensureTyped(t,n);
TO:
1

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 2th generated patches:
Validating 200 patches...
Tested:413 patches
Compile failed:408 patches
Compilation rate:0.012106537530266344
PP
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/9.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/9.java
Current actions:
INSERT:
5:if(isPercentTyped(current)){
return ;
}
TO:
1

Following are 1th generated patches:
Validating 78 patches...
Current actions:
INSERT:
11:if(type!=null&&!type.isUnknownType()&&!type.isNoType()){
percentTypedNodes+=1;
}
TO:
1

Following are 2th generated patches:
Validating 200 patches...
Current actions:
INSERT:
3:Node current=n.getParent();
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

INSERT:
4:while(current!=null){
if(isPercentTyped(current)){
return ;
}
current=current.getParent();
}
TO:
1

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 3th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
10:JSType type=getJSType(n);
TO:
1

INSERT:
12:percentTypedNodes+=1;
TO:
1

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

Following are 4th generated patches:
Validating 19 patches...
Current actions:
DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 6boolean typeable=true;

INSERT:
6:return ;
TO:
1

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
8:current=current.getParent();
TO:
1

INSERT:
10:JSType type=getJSType(n);
TO:
1

INSERT:
12:percentTypedNodes+=1;
TO:
1

Tested:417 patches
Compile failed:410 patches
Compilation rate:0.016786570743405275
PPNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/10.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/10.java
Tested:417 patches
Compile failed:410 patches
Compilation rate:0.016786570743405275

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/11.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/11.java
Current actions:
INSERT:
6:if(right.getType()==Token.FUNCTION){
rightType=getNativeType(FUNCTION_INSTANCE_TYPE);
}
TO:
1

Following are 1th generated patches:
Validating 200 patches...
Current actions:
INSERT:
13:if(leftType==null){
leftType=getNativeType(UNKNOWN_TYPE);
}
TO:
8

Following are 2th generated patches:
Validating 200 patches...
Current actions:
INSERT:
3:Node left=n.getFirstChild();
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

INSERT:
4:Node right=n.getLastChild();
TO:
1

INSERT:
5:JSType rightType=getJSType(right);
TO:
1

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
7:rightType=getNativeType(FUNCTION_INSTANCE_TYPE);
TO:
1

UPDATE
FROM:
3:JSType childType;
TO:
9:JSType leftType;

INSERT:
10:switch (left.getType()){
case Token.NAME :
leftType=t.getScope().getDeclaredType(left.getString());
if(leftType==null){
leftType=getNativeType(UNKNOWN_TYPE);
}
if(left.getParent().getType()==Token.ASSIGN){
validator.expectAssignable(t,left,leftType,rightType,"assignment");
}
ensureTyped(t,n);
break;
case Token.GETPROP :
{
leftType=getJSType(left);
validator.expectLValue(t,left,leftType,"assignment");
if(left.getParent().getType()==Token.ASSIGN){
JSType rightLValueType=rightType.restrictByNotNullOrUndefined();
validator.expectAssignable(t,left,leftType,rightLValueType,"assignment");
}
else{
if(left.getParent().getType()==Token.VAR){
validator.expectAssignable(t,left,leftType,rightType,"variable initialization");
}
}
break;
}
case Token.GETELEM :
{
Node target=left.getFirstChild();
Node key=left.getLastChild();
leftType=getJSType(target);
JSType keyType=getJSType(key);
validator.expectLValue(t,target,leftType,"assignment");
validator.expectStringOrSymbol(t,key,keyType,"assignment target");
if(left.getParent().getType()==Token.ASSIGN){
JSType rightLValueType=rightType.restrictByNotNullOrUndefined();
validator.expectAssignable(t,left,leftType,rightLValueType,"assignment");
}
else{
if(left.getParent().getType()==Token.VAR){
validator.expectAssignable(t,left,leftType,rightType,"variable initialization");
}
}
break;
}
case Token.ARRAYLIT :
leftType=getJSType(left);
validator.expectLValue(t,left,leftType,"assignment");
validator.expectAssignable(t,left,leftType,rightType,"assignment");
break;
case Token.OBJECTLIT :
{
leftType=getJSType(left);
JSType.Builder rightTypeBuilder=rightType.toBuilder();
JSType rightTypeWithMissingProperties=rightTypeBuilder.build();
validator.expectLValue(t,left,leftType,"assignment");
validator.expectAssignable(t,left,leftType,rightTypeWithMissingProperties,"assignment");
break;
}
default :
report(t,n,BAD_ASSIGNMENT);
ensureTyped(t,n);
break;
}
TO:
3

UPDATE
FROM:
222:childType=getJSType(child);
TO:
29:leftType=getJSType(left);

UPDATE
FROM:
221:Node child=n.getFirstChild();
TO:
42:Node target=left.getFirstChild();

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

Tested:618 patches
Compile failed:574 patches
Compilation rate:0.07119741100323625
PNNNNNNNNNNNNNNNNNNPNNNNNPNNNNNNNNNNNNNNNNPNNNPNPNNNPPPNNNPPPPNNNNNPPPNNNNNNNPNPNNNNNPPNNPPPNNPNPNNPNNPNNPNNNNNPNPNNPNPNNNPNNNPNNNNNNPNNPPNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/12.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/12.java
Current actions:
INSERT:
8:if(left.getType()==Token.GETPROP&&left.getJSDocInfo()!=null&&left.getJSDocInfo().hasEnumParameterType()){
ensureTyped(t,n);
return ;
}
TO:
4

Following are 1th generated patches:
Validating 200 patches...
Current actions:
INSERT:
12:if(!isStrict(n)&&!leftTypeRestricted.isMutable()){
report(t,n,ASSIGNMENT_TO_IMMUTABLE_TYPE);
}
TO:
4

Following are 2th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:Node left=n.getFirstChild();
TO:
1

DELETE:
Original line: 5Node left,right;

UPDATE
FROM:
4:JSType leftType,rightType;
TO:
5:JSType leftType=getJSType(left);

INSERT:
6:JSType rightType=getJSType(right);
TO:
4

INSERT:
7:JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
TO:
4

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
8:if(left.getType()==Token.GETPROP&&left.getJSDocInfo()!=null&&left.getJSDocInfo().hasEnumParameterType()){
ensureTyped(t,n);
return ;
}
TO:
4

INSERT:
12:if(!isStrict(n)&&!leftTypeRestricted.isMutable()){
report(t,n,ASSIGNMENT_TO_IMMUTABLE_TYPE);
}
TO:
4

INSERT:
15:if(!leftTypeRestricted.isSubtype(rightType.restrictByNotNullOrUndefined())){
report(t,n,INCOMPATIBLE_TYPES,leftType.toString(),rightType.toString());
}
TO:
4

INSERT:
18:ensureTyped(t,n,leftType);
TO:
4

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 4th generated patches:
Validating 200 patches...
Tested:1019 patches
Compile failed:975 patches
Compilation rate:0.04317958783120707
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/13.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/13.java
Tested:1019 patches
Compile failed:975 patches
Compilation rate:0.04317958783120707

Finish : closure-66 > patch : 0 | Start : Sun Apr 07 17:04:05 HKT 2024 | End : 2024.04.07 AD at 17:09:54 HKT
