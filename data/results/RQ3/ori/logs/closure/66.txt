Repair : closure_66
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/0.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/0.java
Tested:0 patches
Compile failed:0 patches
Compilation rate:NaN

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/1.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/1.java
Current actions:
INSERT:
3:if(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n){
return ;
}
TO:
1

Following are 1th generated patches:
Validating 200 patches...
Current actions:
INSERT:
8:if(leftType.isString()){
ensureTyped(t,n,STRING_TYPE);
return ;
}
TO:
4

Following are 2th generated patches:
Validating 200 patches...
Current actions:
INSERT:
3:if(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n){
return ;
}
TO:
1

DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

UPDATE
FROM:
4:JSType leftType,rightType;
TO:
7:JSType leftType=getJSType(left);

INSERT:
10:return ;
TO:
4

INSERT:
14:return ;
TO:
4

INSERT:
18:return ;
TO:
4

INSERT:
20:if(leftType.isNullable()){
ensureTyped(t,n,NULL_TYPE);
return ;
}
TO:
4

INSERT:
25:if(leftType.isNumber()&&leftType.matchesStringContext()){
ensureTyped(t,n,STRING_TYPE);
return ;
}
TO:
4

INSERT:
30:ensureTyped(t,n,NUMBER_TYPE);
TO:
4

INSERT:
31:return ;
TO:
4

INSERT:
34:ensureTyped(t,n,NUMBER_TYPE);
TO:
4

INSERT:
35:return ;
TO:
4

INSERT:
37:if(leftType.isString()&&leftType.matchesStringContext()){
ensureTyped(t,n,NUMBER_TYPE);
return ;
}
TO:
4

INSERT:
41:if(leftType.isString()&&leftType.matchesNumberContext()){
ensureTyped(t,n,NUMBER_TYPE);
return ;
}
TO:
4

INSERT:
45:if(leftType.isString()&&leftType.matchesBooleanContext()){
ensureTyped(t,n,STRING_TYPE);
return ;
}
TO:
4

INSERT:
49:if(leftType.isBoolean()&&leftType.matchesNumberContext()){
ensureTyped(t,n,BOOLEAN_TYPE);
return ;
}
TO:
4

INSERT:
53:if(leftType.isBoolean()&&leftType.matchesBooleanContext()){
ensureTyped(t,n,NUMBER_TYPE);
return ;
}
TO:
4

INSERT:
59:return ;
TO:
4

INSERT:
69:if(leftType.isString()&&leftType.matchesUndefinedContext()){
ensureTyped(t,n,VOID_TYPE);
return ;
}
TO:
4

INSERT:
77:if(leftType.isBoolean()&&leftType.matchesUndefinedContext()){
ensureTyped(t,n,VOID_TYPE);
return ;
}
TO:
4

INSERT:
83:if(currentType.isUnionType()){
for(JSType type : currentType.getAlternates()){
possibleValues.addAll(type.getReferencedProperties());
}
}
TO:
4

INSERT:
90:}

TO:
15

INSERT:
91:if(possibleValues.isEmpty()){
ensureTyped(t,n,VOID_TYPE);
return ;
}
TO:
15

INSERT:
95:if(allBooleans(possibleValues)){
ensureTyped(t,n,BOOLEAN_TYPE);
return ;
}
TO:
15

INSERT:
104:ensureTyped(t,n,STRING_TYPE);
TO:
15

INSERT:
109:return ;
TO:
15

INSERT:
113:return ;
TO:
15

INSERT:
117:return ;
TO:
15

INSERT:
119:if(leftType.isNumber()||leftType.isString()){
ensureTyped(t,n,NUMBER_TYPE);
return ;
}
TO:
15

INSERT:
123:if(leftType.isBoolean()){
ensureTyped(t,n,STRING_TYPE);
return ;
}
TO:
15

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Tested:201 patches
Compile failed:198 patches
Compilation rate:0.014925373134328358
PNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNPNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNP
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/2.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/2.java
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
4:Node right=n.getLastChild();
TO:
1

UPDATE
FROM:
4:JSType leftType,rightType;
TO:
5:JSType leftType=getJSType(left);

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
9:n.setJSType(rightValueType);
TO:
4

INSERT:
10:n.setDeclaredType(rightValueType);
TO:
4

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

Following are 1th generated patches:
Validating 200 patches...
Tested:352 patches
Compile failed:349 patches
Compilation rate:0.008522727272727272
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/3.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/3.java
Current actions:
INSERT:
5:if(typeNode==null){
return true;
}
TO:
1

Following are 1th generated patches:
Validating 200 patches...
Current actions:
INSERT:
9:if(!type.isExplicitAnyType()&&!type.isUnknownType()){
ensureTyped(t,n,type);
}
TO:
1

Following are 2th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
4:Node typeNode=findTypeNode(name,n);
TO:
1

DELETE:
Original line: 5Node left,right;

INSERT:
6:return true;
TO:
1

DELETE:
Original line: 8case Token.NAME :

DELETE:
Original line: 9typeable=visitName(t,n,parent);

DELETE:
Original line: 11case Token.LP :

DELETE:
Original line: 13ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 19case Token.COMMA :

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 28break;

DELETE:
Original line: 29case Token.REF_SPECIAL :

DELETE:
Original line: 30ensureTyped(t,n);

DELETE:
Original line: 31break;

DELETE:
Original line: 33ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 34break;

DELETE:
Original line: 35case Token.NULL :

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 37break;

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 40break;

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 48break;

DELETE:
Original line: 49case Token.ARRAYLIT :

DELETE:
Original line: 51break;

DELETE:
Original line: 53ensureTyped(t,n,REGEXP_TYPE);

DELETE:
Original line: 54break;

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 56visitGetProp(t,n,parent);

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 61typeable=false;

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 64visitVar(t,n);

DELETE:
Original line: 66break;

DELETE:
Original line: 67case Token.NEW :

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 70break;

DELETE:
Original line: 72visitCall(t,n);

DELETE:
Original line: 73typeable=!NodeUtil.isExpressionNode(parent);

DELETE:
Original line: 74break;

DELETE:
Original line: 78break;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 84break;

DELETE:
Original line: 86ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 91case Token.TYPEOF :

DELETE:
Original line: 94case Token.BITNOT :

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 99ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 100break;

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 105ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 106break;

DELETE:
Original line: 107case Token.EQ :

DELETE:
Original line: 108case Token.NE :

DELETE:
Original line: 109{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 110leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 113JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 115if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 126{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 128rightType=getJSType(n.getLastChild());

DELETE:
Original line: 131if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}

DELETE:
Original line: 135break;

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 138case Token.LE :

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 144validator.expectNumber(t,n,leftType,"left side of numeric comparison");

DELETE:
Original line: 146if(leftType.isNumber()){
validator.expectNumber(t,n,rightType,"right side of numeric comparison");
}

DELETE:
Original line: 160break;

DELETE:
Original line: 161case Token.IN :

DELETE:
Original line: 164leftType=getJSType(left);

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 169break;

DELETE:
Original line: 170case Token.INSTANCEOF :

DELETE:
Original line: 171left=n.getFirstChild();

DELETE:
Original line: 172right=n.getLastChild();

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 178break;

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 181typeable=false;

DELETE:
Original line: 185case Token.ASSIGN_URSH :

DELETE:
Original line: 186case Token.ASSIGN_DIV :

DELETE:
Original line: 187case Token.ASSIGN_MOD :

DELETE:
Original line: 188case Token.ASSIGN_BITOR :

DELETE:
Original line: 189case Token.ASSIGN_BITXOR :

DELETE:
Original line: 191case Token.ASSIGN_SUB :

DELETE:
Original line: 192case Token.ASSIGN_ADD :

DELETE:
Original line: 193case Token.ASSIGN_MUL :

DELETE:
Original line: 195case Token.RSH :

DELETE:
Original line: 196case Token.URSH :

DELETE:
Original line: 197case Token.DIV :

DELETE:
Original line: 198case Token.MOD :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 202case Token.SUB :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 206break;

DELETE:
Original line: 207case Token.DELPROP :

DELETE:
Original line: 208if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}

DELETE:
Original line: 212break;

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 219case Token.WITH :

DELETE:
Original line: 221Node child=n.getFirstChild();

DELETE:
Original line: 222childType=getJSType(child);

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 231case Token.LABEL_NAME :

DELETE:
Original line: 232case Token.SWITCH :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 237case Token.EXPR_RESULT :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 240case Token.DEFAULT :

DELETE:
Original line: 242case Token.DEBUGGER :

DELETE:
Original line: 244typeable=false;

DELETE:
Original line: 245break;

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 247case Token.FOR :

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 249case Token.WHILE :

DELETE:
Original line: 252case Token.AND :

DELETE:
Original line: 253case Token.HOOK :

DELETE:
Original line: 256if(n.getJSType()!=null){
ensureTyped(t,n);
}

DELETE:
Original line: 267if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}

DELETE:
Original line: 273default :

DELETE:
Original line: 274report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));

DELETE:
Original line: 275ensureTyped(t,n);

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 3th generated patches:
Validating 138 patches...
Current actions:
INSERT:
3:String name=n.getString();
TO:
1

DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 6boolean typeable=true;

INSERT:
8:JSType type=getJSType(typeNode);
TO:
1

DELETE:
Original line: 9typeable=visitName(t,n,parent);

INSERT:
10:ensureTyped(t,n,type);
TO:
1

DELETE:
Original line: 11case Token.LP :

DELETE:
Original line: 12if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}

INSERT:
12:return false;
TO:
1

DELETE:
Original line: 20ensureTyped(t,n,getJSType(n.getLastChild()));

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 25break;

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 30ensureTyped(t,n);

DELETE:
Original line: 31break;

DELETE:
Original line: 32case Token.GET_REF :

DELETE:
Original line: 33ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 34break;

DELETE:
Original line: 35case Token.NULL :

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 38case Token.NUMBER :

DELETE:
Original line: 40break;

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 42if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}

DELETE:
Original line: 46case Token.GET :

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 50ensureTyped(t,n,ARRAY_TYPE);

DELETE:
Original line: 52case Token.REGEXP :

DELETE:
Original line: 54break;

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 56visitGetProp(t,n,parent);

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 64visitVar(t,n);

DELETE:
Original line: 65typeable=false;

DELETE:
Original line: 67case Token.NEW :

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 72visitCall(t,n);

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 78break;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 82validator.expectNumber(t,left,getJSType(left),"increment/decrement");

DELETE:
Original line: 83ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 87break;

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 90break;

DELETE:
Original line: 91case Token.TYPEOF :

DELETE:
Original line: 93break;

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 101case Token.POS :

DELETE:
Original line: 102case Token.NEG :

DELETE:
Original line: 103left=n.getFirstChild();

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 105ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 106break;

DELETE:
Original line: 108case Token.NE :

DELETE:
Original line: 109{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 113JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 114TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);

DELETE:
Original line: 121ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 122break;

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 126{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 129JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 130JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 140case Token.GE :

DELETE:
Original line: 142rightType=getJSType(n.getLastChild());

DELETE:
Original line: 143if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}

DELETE:
Original line: 159ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 164leftType=getJSType(left);

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 166validator.expectObject(t,n,rightType,"'in' requires an object");

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 168ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 169break;

DELETE:
Original line: 170case Token.INSTANCEOF :

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 176validator.expectActualObject(t,right,rightType,"instanceof requires an object");

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 178break;

DELETE:
Original line: 181typeable=false;

DELETE:
Original line: 182break;

DELETE:
Original line: 183case Token.ASSIGN_LSH :

DELETE:
Original line: 185case Token.ASSIGN_URSH :

DELETE:
Original line: 186case Token.ASSIGN_DIV :

DELETE:
Original line: 189case Token.ASSIGN_BITXOR :

DELETE:
Original line: 190case Token.ASSIGN_BITAND :

DELETE:
Original line: 191case Token.ASSIGN_SUB :

DELETE:
Original line: 192case Token.ASSIGN_ADD :

DELETE:
Original line: 194case Token.LSH :

DELETE:
Original line: 195case Token.RSH :

DELETE:
Original line: 196case Token.URSH :

DELETE:
Original line: 197case Token.DIV :

DELETE:
Original line: 198case Token.MOD :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 202case Token.SUB :

DELETE:
Original line: 203case Token.ADD :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 205visitBinaryOperator(n.getType(),t,n);

DELETE:
Original line: 206break;

DELETE:
Original line: 208if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}

DELETE:
Original line: 212break;

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 215JSType caseType=getJSType(n.getFirstChild());

DELETE:
Original line: 218break;

DELETE:
Original line: 219case Token.WITH :

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 224typeable=false;

DELETE:
Original line: 228visitFunction(t,n);

DELETE:
Original line: 229break;

DELETE:
Original line: 230case Token.LABEL :

DELETE:
Original line: 232case Token.SWITCH :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 237case Token.EXPR_RESULT :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 243case Token.THROW :

DELETE:
Original line: 245break;

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 247case Token.FOR :

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 249case Token.WHILE :

DELETE:
Original line: 252case Token.AND :

DELETE:
Original line: 255case Token.OR :

DELETE:
Original line: 256if(n.getJSType()!=null){
ensureTyped(t,n);
}

DELETE:
Original line: 272break;

DELETE:
Original line: 274report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));

DELETE:
Original line: 276break;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 4th generated patches:
Validating 200 patches...
Tested:356 patches
Compile failed:351 patches
Compilation rate:0.014044943820224719
PPNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/4.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/4.java
Tested:356 patches
Compile failed:351 patches
Compilation rate:0.014044943820224719

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/5.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/5.java
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:return (n.getType()==Token.NAME)||(n.getType()==Token.GETPROP);
TO:
1

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 8case Token.NAME :

DELETE:
Original line: 9typeable=visitName(t,n,parent);

DELETE:
Original line: 10break;

DELETE:
Original line: 13ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 18break;

DELETE:
Original line: 20ensureTyped(t,n,getJSType(n.getLastChild()));

DELETE:
Original line: 21break;

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 25break;

DELETE:
Original line: 28break;

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 37break;

DELETE:
Original line: 38case Token.NUMBER :

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 40break;

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 45break;

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 48break;

DELETE:
Original line: 49case Token.ARRAYLIT :

DELETE:
Original line: 50ensureTyped(t,n,ARRAY_TYPE);

DELETE:
Original line: 51break;

DELETE:
Original line: 52case Token.REGEXP :

DELETE:
Original line: 53ensureTyped(t,n,REGEXP_TYPE);

DELETE:
Original line: 54break;

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 56visitGetProp(t,n,parent);

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 61typeable=false;

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 65typeable=false;

DELETE:
Original line: 67case Token.NEW :

DELETE:
Original line: 69typeable=true;

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 72visitCall(t,n);

DELETE:
Original line: 73typeable=!NodeUtil.isExpressionNode(parent);

DELETE:
Original line: 74break;

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 82validator.expectNumber(t,left,getJSType(left),"increment/decrement");

DELETE:
Original line: 84break;

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 86ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 87break;

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 90break;

DELETE:
Original line: 91case Token.TYPEOF :

DELETE:
Original line: 92ensureTyped(t,n,STRING_TYPE);

DELETE:
Original line: 93break;

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 99ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 100break;

DELETE:
Original line: 105ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 108case Token.NE :

DELETE:
Original line: 109{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 110leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 113JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 114TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);

DELETE:
Original line: 115if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 126{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 127leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 130JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 131if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}

DELETE:
Original line: 134ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 141leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 142rightType=getJSType(n.getLastChild());

DELETE:
Original line: 143if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}

DELETE:
Original line: 160break;

DELETE:
Original line: 161case Token.IN :

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 164leftType=getJSType(left);

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 168ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 170case Token.INSTANCEOF :

DELETE:
Original line: 171left=n.getFirstChild();

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 175validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");

DELETE:
Original line: 176validator.expectActualObject(t,right,rightType,"instanceof requires an object");

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 178break;

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 182break;

DELETE:
Original line: 183case Token.ASSIGN_LSH :

DELETE:
Original line: 186case Token.ASSIGN_DIV :

DELETE:
Original line: 187case Token.ASSIGN_MOD :

DELETE:
Original line: 189case Token.ASSIGN_BITXOR :

DELETE:
Original line: 190case Token.ASSIGN_BITAND :

DELETE:
Original line: 191case Token.ASSIGN_SUB :

DELETE:
Original line: 192case Token.ASSIGN_ADD :

DELETE:
Original line: 193case Token.ASSIGN_MUL :

DELETE:
Original line: 194case Token.LSH :

DELETE:
Original line: 198case Token.MOD :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 201case Token.BITAND :

DELETE:
Original line: 202case Token.SUB :

DELETE:
Original line: 203case Token.ADD :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 205visitBinaryOperator(n.getType(),t,n);

DELETE:
Original line: 206break;

DELETE:
Original line: 207case Token.DELPROP :

DELETE:
Original line: 208if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}

DELETE:
Original line: 211ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 212break;

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 216validator.expectSwitchMatchesCase(t,n,switchType,caseType);

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 220{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}

DELETE:
Original line: 221Node child=n.getFirstChild();

DELETE:
Original line: 222childType=getJSType(child);

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 227case Token.FUNCTION :

DELETE:
Original line: 229break;

DELETE:
Original line: 230case Token.LABEL :

DELETE:
Original line: 231case Token.LABEL_NAME :

DELETE:
Original line: 233case Token.BREAK :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 237case Token.EXPR_RESULT :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 240case Token.DEFAULT :

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 242case Token.DEBUGGER :

DELETE:
Original line: 243case Token.THROW :

DELETE:
Original line: 244typeable=false;

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 247case Token.FOR :

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 249case Token.WHILE :

DELETE:
Original line: 255case Token.OR :

DELETE:
Original line: 256if(n.getJSType()!=null){
ensureTyped(t,n);
}

DELETE:
Original line: 267if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}

DELETE:
Original line: 272break;

DELETE:
Original line: 273default :

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

Following are 1th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 18break;

DELETE:
Original line: 19case Token.COMMA :

DELETE:
Original line: 20ensureTyped(t,n,getJSType(n.getLastChild()));

DELETE:
Original line: 25break;

DELETE:
Original line: 28break;

DELETE:
Original line: 42if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}

DELETE:
Original line: 51break;

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 67case Token.NEW :

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 76visitReturn(t,n);

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 86ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 91case Token.TYPEOF :

DELETE:
Original line: 122break;

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 135break;

DELETE:
Original line: 153validator.expectString(t,n,leftType,message);

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 169break;

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 178break;

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 185case Token.ASSIGN_URSH :

DELETE:
Original line: 194case Token.LSH :

DELETE:
Original line: 208if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}

DELETE:
Original line: 228visitFunction(t,n);

DELETE:
Original line: 233case Token.BREAK :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 250typeable=false;

DELETE:
Original line: 253case Token.HOOK :

DELETE:
Original line: 256if(n.getJSType()!=null){
ensureTyped(t,n);
}

DELETE:
Original line: 274report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));

Following are 2th generated patches:
Validating 36 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

Following are 3th generated patches:
Validating 3 patches...
Current actions:
DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 4th generated patches:
Validating 3 patches...
Current actions:
INSERT:
3:return (n.getType()==Token.NAME)||(n.getType()==Token.GETPROP);
TO:
1

DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Tested:360 patches
Compile failed:354 patches
Compilation rate:0.016666666666666666
NNPN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/6.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/6.java
Tested:360 patches
Compile failed:354 patches
Compilation rate:0.016666666666666666

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/7.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/7.java
Current actions:
INSERT:
20:if(isReference(left)){
visitAssignToReference(t,n);
}
TO:
193

Following are 1th generated patches:
Validating 200 patches...
Current actions:
INSERT:
3:Node left=n.getFirstChild();
TO:
1

DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 4JSType leftType,rightType;

INSERT:
4:Node right=n.getLastChild();
TO:
1

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 9typeable=visitName(t,n,parent);

DELETE:
Original line: 11case Token.LP :

DELETE:
Original line: 12if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}

INSERT:
17:visitBinaryOperator(n.getType(),t,n);
TO:
193

INSERT:
18:break;
TO:
193

DELETE:
Original line: 18break;

DELETE:
Original line: 19case Token.COMMA :

INSERT:
20:if(isReference(left)){
visitAssignToReference(t,n);
}
TO:
193

DELETE:
Original line: 20ensureTyped(t,n,getJSType(n.getLastChild()));

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

INSERT:
25:}

TO:
263

DELETE:
Original line: 25break;

DELETE:
Original line: 26case Token.THIS :

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 28break;

DELETE:
Original line: 29case Token.REF_SPECIAL :

DELETE:
Original line: 30ensureTyped(t,n);

DELETE:
Original line: 31break;

DELETE:
Original line: 32case Token.GET_REF :

DELETE:
Original line: 34break;

DELETE:
Original line: 35case Token.NULL :

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 37break;

DELETE:
Original line: 38case Token.NUMBER :

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 42if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}

DELETE:
Original line: 46case Token.GET :

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 48break;

DELETE:
Original line: 49case Token.ARRAYLIT :

DELETE:
Original line: 50ensureTyped(t,n,ARRAY_TYPE);

DELETE:
Original line: 52case Token.REGEXP :

DELETE:
Original line: 53ensureTyped(t,n,REGEXP_TYPE);

DELETE:
Original line: 54break;

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 56visitGetProp(t,n,parent);

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 61typeable=false;

DELETE:
Original line: 62break;

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 64visitVar(t,n);

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 69typeable=true;

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 73typeable=!NodeUtil.isExpressionNode(parent);

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 77typeable=false;

DELETE:
Original line: 78break;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 83ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 86ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 90break;

DELETE:
Original line: 91case Token.TYPEOF :

DELETE:
Original line: 93break;

DELETE:
Original line: 94case Token.BITNOT :

DELETE:
Original line: 95childType=getJSType(n.getFirstChild());

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 99ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 100break;

DELETE:
Original line: 101case Token.POS :

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 105ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 106break;

DELETE:
Original line: 109{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 110leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 113JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 115if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}

DELETE:
Original line: 121ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 122break;

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 126{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 127leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 128rightType=getJSType(n.getLastChild());

DELETE:
Original line: 129JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 130JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 131if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}

DELETE:
Original line: 135break;

DELETE:
Original line: 138case Token.LE :

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 140case Token.GE :

DELETE:
Original line: 142rightType=getJSType(n.getLastChild());

DELETE:
Original line: 143if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}

DELETE:
Original line: 161case Token.IN :

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 164leftType=getJSType(left);

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 166validator.expectObject(t,n,rightType,"'in' requires an object");

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 169break;

DELETE:
Original line: 170case Token.INSTANCEOF :

DELETE:
Original line: 171left=n.getFirstChild();

DELETE:
Original line: 172right=n.getLastChild();

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 176validator.expectActualObject(t,right,rightType,"instanceof requires an object");

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 178break;

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 181typeable=false;

DELETE:
Original line: 194case Token.LSH :

DELETE:
Original line: 195case Token.RSH :

DELETE:
Original line: 197case Token.DIV :

DELETE:
Original line: 198case Token.MOD :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 201case Token.BITAND :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 205visitBinaryOperator(n.getType(),t,n);

DELETE:
Original line: 206break;

DELETE:
Original line: 207case Token.DELPROP :

DELETE:
Original line: 208if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}

DELETE:
Original line: 212break;

DELETE:
Original line: 213case Token.CASE :

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 215JSType caseType=getJSType(n.getFirstChild());

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 218break;

DELETE:
Original line: 219case Token.WITH :

DELETE:
Original line: 220{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}

DELETE:
Original line: 221Node child=n.getFirstChild();

DELETE:
Original line: 222childType=getJSType(child);

DELETE:
Original line: 224typeable=false;

DELETE:
Original line: 227case Token.FUNCTION :

DELETE:
Original line: 228visitFunction(t,n);

DELETE:
Original line: 229break;

DELETE:
Original line: 230case Token.LABEL :

DELETE:
Original line: 231case Token.LABEL_NAME :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 236case Token.SCRIPT :

DELETE:
Original line: 237case Token.EXPR_RESULT :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 240case Token.DEFAULT :

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 242case Token.DEBUGGER :

DELETE:
Original line: 243case Token.THROW :

DELETE:
Original line: 244typeable=false;

DELETE:
Original line: 245break;

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 250typeable=false;

DELETE:
Original line: 251break;

DELETE:
Original line: 253case Token.HOOK :

DELETE:
Original line: 255case Token.OR :

DELETE:
Original line: 257ensureTyped(t,n);

DELETE:
Original line: 259else{
if((n.getType()==Token.OBJECTLIT)&&(parent.getJSType() instanceof EnumType)){
ensureTyped(t,n,parent.getJSType());
}
else{
ensureTyped(t,n);
}
}

DELETE:
Original line: 269visitObjLitKey(t,key,n);

DELETE:
Original line: 274report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));

DELETE:
Original line: 275ensureTyped(t,n);

DELETE:
Original line: 276break;

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

Following are 2th generated patches:
Validating 200 patches...
Tested:561 patches
Compile failed:555 patches
Compilation rate:0.0106951871657754
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/8.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/8.java
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
4:ensureTyped(t,n);
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 9typeable=visitName(t,n,parent);

DELETE:
Original line: 10break;

DELETE:
Original line: 11case Token.LP :

DELETE:
Original line: 13ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 15else{
typeable=false;
}

DELETE:
Original line: 19case Token.COMMA :

DELETE:
Original line: 20ensureTyped(t,n,getJSType(n.getLastChild()));

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 26case Token.THIS :

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 30ensureTyped(t,n);

DELETE:
Original line: 31break;

DELETE:
Original line: 32case Token.GET_REF :

DELETE:
Original line: 34break;

DELETE:
Original line: 35case Token.NULL :

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 40break;

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 46case Token.GET :

DELETE:
Original line: 48break;

DELETE:
Original line: 49case Token.ARRAYLIT :

DELETE:
Original line: 50ensureTyped(t,n,ARRAY_TYPE);

DELETE:
Original line: 51break;

DELETE:
Original line: 52case Token.REGEXP :

DELETE:
Original line: 53ensureTyped(t,n,REGEXP_TYPE);

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 56visitGetProp(t,n,parent);

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 58break;

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 65typeable=false;

DELETE:
Original line: 66break;

DELETE:
Original line: 69typeable=true;

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 72visitCall(t,n);

DELETE:
Original line: 74break;

DELETE:
Original line: 76visitReturn(t,n);

DELETE:
Original line: 78break;

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 82validator.expectNumber(t,left,getJSType(left),"increment/decrement");

DELETE:
Original line: 84break;

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 90break;

DELETE:
Original line: 91case Token.TYPEOF :

DELETE:
Original line: 92ensureTyped(t,n,STRING_TYPE);

DELETE:
Original line: 94case Token.BITNOT :

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 99ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 101case Token.POS :

DELETE:
Original line: 103left=n.getFirstChild();

DELETE:
Original line: 105ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 106break;

DELETE:
Original line: 107case Token.EQ :

DELETE:
Original line: 109{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 112JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 113JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 116if(n.getType()==Token.NE){
result=result.not();
}

DELETE:
Original line: 121ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 122break;

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 126{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 127leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 128rightType=getJSType(n.getLastChild());

DELETE:
Original line: 131if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}

DELETE:
Original line: 134ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 135break;

DELETE:
Original line: 138case Token.LE :

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 140case Token.GE :

DELETE:
Original line: 141leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 142rightType=getJSType(n.getLastChild());

DELETE:
Original line: 143if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}

DELETE:
Original line: 159ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 161case Token.IN :

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 164leftType=getJSType(left);

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 166validator.expectObject(t,n,rightType,"'in' requires an object");

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 168ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 169break;

DELETE:
Original line: 170case Token.INSTANCEOF :

DELETE:
Original line: 172right=n.getLastChild();

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 175validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 178break;

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 183case Token.ASSIGN_LSH :

DELETE:
Original line: 184case Token.ASSIGN_RSH :

DELETE:
Original line: 186case Token.ASSIGN_DIV :

DELETE:
Original line: 188case Token.ASSIGN_BITOR :

DELETE:
Original line: 189case Token.ASSIGN_BITXOR :

DELETE:
Original line: 191case Token.ASSIGN_SUB :

DELETE:
Original line: 193case Token.ASSIGN_MUL :

DELETE:
Original line: 196case Token.URSH :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 205visitBinaryOperator(n.getType(),t,n);

DELETE:
Original line: 206break;

DELETE:
Original line: 207case Token.DELPROP :

DELETE:
Original line: 209report(t,n,BAD_DELETE);

DELETE:
Original line: 213case Token.CASE :

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 216validator.expectSwitchMatchesCase(t,n,switchType,caseType);

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 218break;

DELETE:
Original line: 219case Token.WITH :

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 224typeable=false;

DELETE:
Original line: 225break;

DELETE:
Original line: 228visitFunction(t,n);

DELETE:
Original line: 229break;

DELETE:
Original line: 230case Token.LABEL :

DELETE:
Original line: 231case Token.LABEL_NAME :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 236case Token.SCRIPT :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 240case Token.DEFAULT :

DELETE:
Original line: 243case Token.THROW :

DELETE:
Original line: 245break;

DELETE:
Original line: 247case Token.FOR :

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 250typeable=false;

DELETE:
Original line: 252case Token.AND :

DELETE:
Original line: 253case Token.HOOK :

DELETE:
Original line: 255case Token.OR :

DELETE:
Original line: 257ensureTyped(t,n);

DELETE:
Original line: 259else{
if((n.getType()==Token.OBJECTLIT)&&(parent.getJSType() instanceof EnumType)){
ensureTyped(t,n,parent.getJSType());
}
else{
ensureTyped(t,n);
}
}

DELETE:
Original line: 268for(Node key : n.children()){
visitObjLitKey(t,key,n);
}

DELETE:
Original line: 272break;

DELETE:
Original line: 273default :

DELETE:
Original line: 274report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));

DELETE:
Original line: 275ensureTyped(t,n);

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 1th generated patches:
Validating 146 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:visitAssignOrBinop(t,n);
TO:
1

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 2th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:visitAssignOrBinop(t,n);
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

INSERT:
4:ensureTyped(t,n);
TO:
1

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 3th generated patches:
Validating 200 patches...
Tested:564 patches
Compile failed:557 patches
Compilation rate:0.012411347517730497
NNP
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/9.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/9.java
Current actions:
INSERT:
5:if(isPercentTyped(current)){
return ;
}
TO:
1

Following are 1th generated patches:
Validating 78 patches...
Current actions:
INSERT:
11:if(type!=null&&!type.isUnknownType()&&!type.isNoType()){
percentTypedNodes+=1;
}
TO:
1

Following are 2th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 4JSType leftType,rightType;

INSERT:
4:while(current!=null){
if(isPercentTyped(current)){
return ;
}
current=current.getParent();
}
TO:
1

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
10:JSType type=getJSType(n);
TO:
1

INSERT:
11:if(type!=null&&!type.isUnknownType()&&!type.isNoType()){
percentTypedNodes+=1;
}
TO:
1

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 3th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 4JSType leftType,rightType;

INSERT:
4:while(current!=null){
if(isPercentTyped(current)){
return ;
}
current=current.getParent();
}
TO:
1

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
11:if(type!=null&&!type.isUnknownType()&&!type.isNoType()){
percentTypedNodes+=1;
}
TO:
1

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 4th generated patches:
Validating 200 patches...
Tested:568 patches
Compile failed:557 patches
Compilation rate:0.01936619718309859
PPPP
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/10.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/10.java
Tested:568 patches
Compile failed:557 patches
Compilation rate:0.01936619718309859

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/11.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/11.java
Current actions:
INSERT:
6:if(right.getType()==Token.FUNCTION){
rightType=getNativeType(FUNCTION_INSTANCE_TYPE);
}
TO:
1

Following are 1th generated patches:
Validating 200 patches...
Current actions:
INSERT:
13:if(leftType==null){
leftType=getNativeType(UNKNOWN_TYPE);
}
TO:
8

Following are 2th generated patches:
Validating 200 patches...
Current actions:
INSERT:
3:Node left=n.getFirstChild();
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 6boolean typeable=true;

INSERT:
7:rightType=getNativeType(FUNCTION_INSTANCE_TYPE);
TO:
1

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
12:leftType=t.getScope().getDeclaredType(left.getString());
TO:
8

INSERT:
14:leftType=getNativeType(UNKNOWN_TYPE);
TO:
8

INSERT:
20:validator.expectAssignable(t,left,leftType,rightType,"variable initialization");
TO:
8

INSERT:
32:JSType rightLValueType=rightType.restrictByNotNullOrUndefined();
TO:
222

INSERT:
33:validator.expectAssignable(t,left,leftType,rightLValueType,"assignment");
TO:
222

INSERT:
36:validator.expectAssignable(t,left,leftType,rightType,"variable initialization");
TO:
118

INSERT:
45:JSType keyType=getJSType(key);
TO:
221

INSERT:
46:validator.expectLValue(t,target,leftType,"assignment");
TO:
221

INSERT:
52:else{
if(left.getParent().getType()==Token.VAR){
validator.expectAssignable(t,left,leftType,rightType,"variable initialization");
}
}
TO:
136

INSERT:
57:case Token.ARRAYLIT :
TO:
210

UPDATE
FROM:
104:validator.expectNumber(t,left,getJSType(left),"sign operator");
TO:
59:validator.expectLValue(t,left,leftType,"assignment");

INSERT:
65:JSType.Builder rightTypeBuilder=rightType.toBuilder();
TO:
220

INSERT:
67:validator.expectLValue(t,left,leftType,"assignment");
TO:
220

INSERT:
68:validator.expectAssignable(t,left,leftType,rightTypeWithMissingProperties,"assignment");
TO:
220

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

Tested:769 patches
Compile failed:691 patches
Compilation rate:0.10143042912873862
PNNNNNNNNNNNNNNNNNNPPPNPPPPNNNNNNPPNNPPNNNPPPNNNNNNNNNNPPNPNNNNNNNNPNNNNPPNNNNNNNNNNPNPPPNNNPNNNPPPNNNNNNNNNNNPPNNPNPNNNNNNPNNNPNPPPNNNPNPPNPNNPNNNNNPNNNNPPPNNNNPNNNPNPPNPPNNNNPPNPNNNPPPPNPPNPNNNNNPPPP
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/12.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/12.java
Current actions:
INSERT:
8:if(left.getType()==Token.GETPROP&&left.getJSDocInfo()!=null&&left.getJSDocInfo().hasEnumParameterType()){
ensureTyped(t,n);
return ;
}
TO:
4

Following are 1th generated patches:
Validating 1 patches...
Current actions:
INSERT:
12:if(!isStrict(n)&&!leftTypeRestricted.isMutable()){
report(t,n,ASSIGNMENT_TO_IMMUTABLE_TYPE);
}
TO:
4

Following are 2th generated patches:
Validating 200 patches...
Current actions:
INSERT:
3:Node left=n.getFirstChild();
TO:
1

DELETE:
Original line: 3JSType childType;

INSERT:
4:Node right=n.getLastChild();
TO:
1

DELETE:
Original line: 5Node left,right;

INSERT:
6:JSType rightType=getJSType(right);
TO:
4

DELETE:
Original line: 6boolean typeable=true;

INSERT:
7:JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
TO:
4

INSERT:
10:return ;
TO:
4

DELETE:
Original line: 11case Token.LP :

INSERT:
13:report(t,n,ASSIGNMENT_TO_IMMUTABLE_TYPE);
TO:
4

DELETE:
Original line: 13ensureTyped(t,n,getJSType(n.getFirstChild()));

INSERT:
15:if(!leftTypeRestricted.isSubtype(rightType.restrictByNotNullOrUndefined())){
report(t,n,INCOMPATIBLE_TYPES,leftType.toString(),rightType.toString());
}
TO:
4

INSERT:
18:ensureTyped(t,n,leftType);
TO:
4

DELETE:
Original line: 18break;

DELETE:
Original line: 19case Token.COMMA :

DELETE:
Original line: 21break;

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 25break;

DELETE:
Original line: 26case Token.THIS :

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 28break;

DELETE:
Original line: 29case Token.REF_SPECIAL :

DELETE:
Original line: 31break;

DELETE:
Original line: 32case Token.GET_REF :

DELETE:
Original line: 34break;

DELETE:
Original line: 35case Token.NULL :

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 38case Token.NUMBER :

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 40break;

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 43ensureTyped(t,n,STRING_TYPE);

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 48break;

DELETE:
Original line: 49case Token.ARRAYLIT :

DELETE:
Original line: 50ensureTyped(t,n,ARRAY_TYPE);

DELETE:
Original line: 51break;

DELETE:
Original line: 52case Token.REGEXP :

DELETE:
Original line: 54break;

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 58break;

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 61typeable=false;

DELETE:
Original line: 62break;

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 65typeable=false;

DELETE:
Original line: 67case Token.NEW :

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 69typeable=true;

DELETE:
Original line: 70break;

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 72visitCall(t,n);

DELETE:
Original line: 73typeable=!NodeUtil.isExpressionNode(parent);

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 76visitReturn(t,n);

DELETE:
Original line: 77typeable=false;

DELETE:
Original line: 78break;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 83ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 90break;

DELETE:
Original line: 91case Token.TYPEOF :

DELETE:
Original line: 93break;

DELETE:
Original line: 95childType=getJSType(n.getFirstChild());

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 99ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 102case Token.NEG :

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 106break;

DELETE:
Original line: 108case Token.NE :

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 112JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 114TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);

DELETE:
Original line: 115if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}

DELETE:
Original line: 121ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 126{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 129JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 130JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 132report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());

DELETE:
Original line: 134ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 135break;

DELETE:
Original line: 138case Token.LE :

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 140case Token.GE :

DELETE:
Original line: 142rightType=getJSType(n.getLastChild());

DELETE:
Original line: 143if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}

DELETE:
Original line: 159ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 160break;

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 164leftType=getJSType(left);

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 168ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 172right=n.getLastChild();

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 175validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");

DELETE:
Original line: 176validator.expectActualObject(t,right,rightType,"instanceof requires an object");

DELETE:
Original line: 178break;

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 181typeable=false;

DELETE:
Original line: 183case Token.ASSIGN_LSH :

DELETE:
Original line: 184case Token.ASSIGN_RSH :

DELETE:
Original line: 185case Token.ASSIGN_URSH :

DELETE:
Original line: 186case Token.ASSIGN_DIV :

DELETE:
Original line: 187case Token.ASSIGN_MOD :

DELETE:
Original line: 189case Token.ASSIGN_BITXOR :

DELETE:
Original line: 194case Token.LSH :

DELETE:
Original line: 195case Token.RSH :

DELETE:
Original line: 196case Token.URSH :

DELETE:
Original line: 197case Token.DIV :

DELETE:
Original line: 198case Token.MOD :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 203case Token.ADD :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 209report(t,n,BAD_DELETE);

DELETE:
Original line: 212break;

DELETE:
Original line: 213case Token.CASE :

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 216validator.expectSwitchMatchesCase(t,n,switchType,caseType);

DELETE:
Original line: 218break;

DELETE:
Original line: 219case Token.WITH :

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 225break;

DELETE:
Original line: 228visitFunction(t,n);

DELETE:
Original line: 229break;

DELETE:
Original line: 230case Token.LABEL :

DELETE:
Original line: 231case Token.LABEL_NAME :

DELETE:
Original line: 232case Token.SWITCH :

DELETE:
Original line: 233case Token.BREAK :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 236case Token.SCRIPT :

DELETE:
Original line: 237case Token.EXPR_RESULT :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 240case Token.DEFAULT :

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 243case Token.THROW :

DELETE:
Original line: 244typeable=false;

DELETE:
Original line: 245break;

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 249case Token.WHILE :

DELETE:
Original line: 250typeable=false;

DELETE:
Original line: 251break;

DELETE:
Original line: 252case Token.AND :

DELETE:
Original line: 253case Token.HOOK :

DELETE:
Original line: 255case Token.OR :

DELETE:
Original line: 259else{
if((n.getType()==Token.OBJECTLIT)&&(parent.getJSType() instanceof EnumType)){
ensureTyped(t,n,parent.getJSType());
}
else{
ensureTyped(t,n);
}
}

DELETE:
Original line: 267if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}

DELETE:
Original line: 272break;

DELETE:
Original line: 273default :

DELETE:
Original line: 274report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));

DELETE:
Original line: 275ensureTyped(t,n);

DELETE:
Original line: 276break;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

Following are 4th generated patches:
Validating 200 patches...
Tested:971 patches
Compile failed:893 patches
Compilation rate:0.08032955715756952
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/13.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/13.java
Tested:971 patches
Compile failed:893 patches
Compilation rate:0.08032955715756952

Finish : closure-66 > patch : 0 | Start : Sat Apr 13 20:09:25 HKT 2024 | End : 2024.04.13 AD at 20:14:03 HKT
