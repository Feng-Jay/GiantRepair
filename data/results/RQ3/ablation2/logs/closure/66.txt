Repair : closure_66
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/0.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/0.java
Tested:0 patches
Compile failed:0 patches
Compilation rate:NaN

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/1.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/1.java
Current actions:
DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 8case Token.NAME :

DELETE:
Original line: 9typeable=visitName(t,n,parent);

INSERT:
9:ensureTyped(t,n,STRING_TYPE);
TO:
4

DELETE:
Original line: 12if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}

INSERT:
14:return ;
TO:
4

INSERT:
16:if(leftType.isBoolean()){
ensureTyped(t,n,BOOLEAN_TYPE);
return ;
}
TO:
4

DELETE:
Original line: 18break;

DELETE:
Original line: 21break;

INSERT:
25:if(leftType.isNumber()&&leftType.matchesStringContext()){
ensureTyped(t,n,STRING_TYPE);
return ;
}
TO:
4

DELETE:
Original line: 29case Token.REF_SPECIAL :

DELETE:
Original line: 33ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 43ensureTyped(t,n,STRING_TYPE);

INSERT:
46:ensureTyped(t,n,STRING_TYPE);
TO:
4

DELETE:
Original line: 49case Token.ARRAYLIT :

INSERT:
50:ensureTyped(t,n,BOOLEAN_TYPE);
TO:
4

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 66break;

INSERT:
69:if(leftType.isString()&&leftType.matchesUndefinedContext()){
ensureTyped(t,n,VOID_TYPE);
return ;
}
TO:
4

DELETE:
Original line: 70break;

DELETE:
Original line: 82validator.expectNumber(t,left,getJSType(left),"increment/decrement");

DELETE:
Original line: 86ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 90break;

INSERT:
90:}

TO:
15

INSERT:
91:if(possibleValues.isEmpty()){
ensureTyped(t,n,VOID_TYPE);
return ;
}
TO:
15

DELETE:
Original line: 93break;

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 101case Token.POS :

INSERT:
103:if(allStrings(possibleValues)){
ensureTyped(t,n,STRING_TYPE);
return ;
}
TO:
15

DELETE:
Original line: 110leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 113JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

INSERT:
113:return ;
TO:
15

INSERT:
115:if(allStrings(possibleValues)){
ensureTyped(t,n,BOOLEAN_TYPE);
return ;
}
TO:
15

DELETE:
Original line: 140case Token.GE :

DELETE:
Original line: 155message="right side of comparison";

DELETE:
Original line: 164leftType=getJSType(left);

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 169break;

DELETE:
Original line: 172right=n.getLastChild();

DELETE:
Original line: 178break;

DELETE:
Original line: 181typeable=false;

DELETE:
Original line: 188case Token.ASSIGN_BITOR :

DELETE:
Original line: 193case Token.ASSIGN_MUL :

DELETE:
Original line: 203case Token.ADD :

DELETE:
Original line: 211ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 213case Token.CASE :

DELETE:
Original line: 221Node child=n.getFirstChild();

DELETE:
Original line: 229break;

DELETE:
Original line: 232case Token.SWITCH :

DELETE:
Original line: 233case Token.BREAK :

DELETE:
Original line: 236case Token.SCRIPT :

DELETE:
Original line: 259else{
if((n.getType()==Token.OBJECTLIT)&&(parent.getJSType() instanceof EnumType)){
ensureTyped(t,n,parent.getJSType());
}
else{
ensureTyped(t,n);
}
}

DELETE:
Original line: 268for(Node key : n.children()){
visitObjLitKey(t,key,n);
}

DELETE:
Original line: 275ensureTyped(t,n);

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 1th generated patches:
Validating 200 patches...
Tested:191 patches
Compile failed:191 patches
Compilation rate:0.0
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/2.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/2.java
Current actions:
INSERT:
6:JSType rightType=getJSType(right);
TO:
4

DELETE:
Original line: 9typeable=visitName(t,n,parent);

INSERT:
9:n.setJSType(rightValueType);
TO:
4

DELETE:
Original line: 13ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 19case Token.COMMA :

DELETE:
Original line: 20ensureTyped(t,n,getJSType(n.getLastChild()));

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 28break;

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 40break;

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 46case Token.GET :

DELETE:
Original line: 49case Token.ARRAYLIT :

DELETE:
Original line: 50ensureTyped(t,n,ARRAY_TYPE);

DELETE:
Original line: 53ensureTyped(t,n,REGEXP_TYPE);

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 61typeable=false;

DELETE:
Original line: 67case Token.NEW :

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 86ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 97report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());

DELETE:
Original line: 114TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);

DELETE:
Original line: 117result=result.not();

DELETE:
Original line: 119report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());

DELETE:
Original line: 126{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 135break;

DELETE:
Original line: 175validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 178break;

DELETE:
Original line: 181typeable=false;

DELETE:
Original line: 182break;

DELETE:
Original line: 189case Token.ASSIGN_BITXOR :

DELETE:
Original line: 197case Token.DIV :

DELETE:
Original line: 198case Token.MOD :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 208if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}

DELETE:
Original line: 229break;

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 243case Token.THROW :

DELETE:
Original line: 245break;

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 255case Token.OR :

DELETE:
Original line: 257ensureTyped(t,n);

DELETE:
Original line: 269visitObjLitKey(t,key,n);

DELETE:
Original line: 275ensureTyped(t,n);

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 1th generated patches:
Validating 200 patches...
Current actions:
UPDATE
FROM:
4:JSType leftType,rightType;
TO:
5:JSType leftType=getJSType(left);

INSERT:
6:JSType rightType=getJSType(right);
TO:
4

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
7:validator.expectLValue(t,n,left,leftType);
TO:
4

INSERT:
8:JSType rightValueType=validator.expectAssignableType(t,right,rightType,leftType,"right side of assignment",false);
TO:
4

Following are 2th generated patches:
Validating 200 patches...
Tested:543 patches
Compile failed:543 patches
Compilation rate:0.0
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/3.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/3.java
Current actions:
INSERT:
3:String name=n.getString();
TO:
1

DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 6boolean typeable=true;

INSERT:
9:if(!type.isExplicitAnyType()&&!type.isUnknownType()){
ensureTyped(t,n,type);
}
TO:
1

DELETE:
Original line: 10break;

DELETE:
Original line: 15else{
typeable=false;
}

DELETE:
Original line: 20ensureTyped(t,n,getJSType(n.getLastChild()));

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 25break;

DELETE:
Original line: 26case Token.THIS :

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 28break;

DELETE:
Original line: 30ensureTyped(t,n);

DELETE:
Original line: 31break;

DELETE:
Original line: 33ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 34break;

DELETE:
Original line: 35case Token.NULL :

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 37break;

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 46case Token.GET :

DELETE:
Original line: 48break;

DELETE:
Original line: 51break;

DELETE:
Original line: 53ensureTyped(t,n,REGEXP_TYPE);

DELETE:
Original line: 56visitGetProp(t,n,parent);

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 58break;

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 62break;

DELETE:
Original line: 64visitVar(t,n);

DELETE:
Original line: 66break;

DELETE:
Original line: 69typeable=true;

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 72visitCall(t,n);

DELETE:
Original line: 74break;

DELETE:
Original line: 76visitReturn(t,n);

DELETE:
Original line: 78break;

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 82validator.expectNumber(t,left,getJSType(left),"increment/decrement");

DELETE:
Original line: 84break;

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 87break;

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 90break;

DELETE:
Original line: 93break;

DELETE:
Original line: 94case Token.BITNOT :

DELETE:
Original line: 95childType=getJSType(n.getFirstChild());

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 100break;

DELETE:
Original line: 101case Token.POS :

DELETE:
Original line: 103left=n.getFirstChild();

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 105ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 106break;

DELETE:
Original line: 107case Token.EQ :

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 112JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 115if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}

DELETE:
Original line: 122break;

DELETE:
Original line: 126{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 128rightType=getJSType(n.getLastChild());

DELETE:
Original line: 129JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 131if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}

DELETE:
Original line: 135break;

DELETE:
Original line: 138case Token.LE :

DELETE:
Original line: 141leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 147validator.expectNumber(t,n,rightType,"right side of numeric comparison");

DELETE:
Original line: 149if(leftType.matchesNumberContext()&&rightType.matchesNumberContext()){
}

DELETE:
Original line: 159ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 161case Token.IN :

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 164leftType=getJSType(left);

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 168ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 170case Token.INSTANCEOF :

DELETE:
Original line: 172right=n.getLastChild();

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 175validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");

DELETE:
Original line: 176validator.expectActualObject(t,right,rightType,"instanceof requires an object");

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 178break;

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 181typeable=false;

DELETE:
Original line: 186case Token.ASSIGN_DIV :

DELETE:
Original line: 187case Token.ASSIGN_MOD :

DELETE:
Original line: 188case Token.ASSIGN_BITOR :

DELETE:
Original line: 190case Token.ASSIGN_BITAND :

DELETE:
Original line: 192case Token.ASSIGN_ADD :

DELETE:
Original line: 195case Token.RSH :

DELETE:
Original line: 201case Token.BITAND :

DELETE:
Original line: 202case Token.SUB :

DELETE:
Original line: 203case Token.ADD :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 205visitBinaryOperator(n.getType(),t,n);

DELETE:
Original line: 207case Token.DELPROP :

DELETE:
Original line: 211ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 212break;

DELETE:
Original line: 213case Token.CASE :

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 216validator.expectSwitchMatchesCase(t,n,switchType,caseType);

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 218break;

DELETE:
Original line: 221Node child=n.getFirstChild();

DELETE:
Original line: 227case Token.FUNCTION :

DELETE:
Original line: 229break;

DELETE:
Original line: 230case Token.LABEL :

DELETE:
Original line: 231case Token.LABEL_NAME :

DELETE:
Original line: 233case Token.BREAK :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 237case Token.EXPR_RESULT :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 244typeable=false;

DELETE:
Original line: 245break;

DELETE:
Original line: 247case Token.FOR :

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 252case Token.AND :

DELETE:
Original line: 254case Token.OBJECTLIT :

DELETE:
Original line: 257ensureTyped(t,n);

DELETE:
Original line: 259else{
if((n.getType()==Token.OBJECTLIT)&&(parent.getJSType() instanceof EnumType)){
ensureTyped(t,n,parent.getJSType());
}
else{
ensureTyped(t,n);
}
}

DELETE:
Original line: 268for(Node key : n.children()){
visitObjLitKey(t,key,n);
}

DELETE:
Original line: 274report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

Following are 1th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 5Node left,right;

INSERT:
8:JSType type=getJSType(typeNode);
TO:
1

DELETE:
Original line: 11case Token.LP :

INSERT:
12:return false;
TO:
1

DELETE:
Original line: 21break;

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 30ensureTyped(t,n);

DELETE:
Original line: 32case Token.GET_REF :

DELETE:
Original line: 34break;

DELETE:
Original line: 37break;

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 45break;

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 51break;

DELETE:
Original line: 62break;

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 67case Token.NEW :

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 70break;

DELETE:
Original line: 76visitReturn(t,n);

DELETE:
Original line: 77typeable=false;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 84break;

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 86ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 87break;

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 92ensureTyped(t,n,STRING_TYPE);

DELETE:
Original line: 93break;

DELETE:
Original line: 95childType=getJSType(n.getFirstChild());

DELETE:
Original line: 99ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 108case Token.NE :

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 116if(n.getType()==Token.NE){
result=result.not();
}

DELETE:
Original line: 121ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 134ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 140case Token.GE :

DELETE:
Original line: 142rightType=getJSType(n.getLastChild());

DELETE:
Original line: 147validator.expectNumber(t,n,rightType,"right side of numeric comparison");

DELETE:
Original line: 149if(leftType.matchesNumberContext()&&rightType.matchesNumberContext()){
}

DELETE:
Original line: 161case Token.IN :

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 166validator.expectObject(t,n,rightType,"'in' requires an object");

DELETE:
Original line: 170case Token.INSTANCEOF :

DELETE:
Original line: 171left=n.getFirstChild();

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 175validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 181typeable=false;

DELETE:
Original line: 183case Token.ASSIGN_LSH :

DELETE:
Original line: 184case Token.ASSIGN_RSH :

DELETE:
Original line: 187case Token.ASSIGN_MOD :

DELETE:
Original line: 188case Token.ASSIGN_BITOR :

DELETE:
Original line: 190case Token.ASSIGN_BITAND :

DELETE:
Original line: 191case Token.ASSIGN_SUB :

DELETE:
Original line: 193case Token.ASSIGN_MUL :

DELETE:
Original line: 197case Token.DIV :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 203case Token.ADD :

DELETE:
Original line: 205visitBinaryOperator(n.getType(),t,n);

DELETE:
Original line: 209report(t,n,BAD_DELETE);

DELETE:
Original line: 211ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 212break;

DELETE:
Original line: 220{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}

DELETE:
Original line: 222childType=getJSType(child);

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 232case Token.SWITCH :

DELETE:
Original line: 233case Token.BREAK :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 249case Token.WHILE :

DELETE:
Original line: 254case Token.OBJECTLIT :

DELETE:
Original line: 257ensureTyped(t,n);

DELETE:
Original line: 259else{
if((n.getType()==Token.OBJECTLIT)&&(parent.getJSType() instanceof EnumType)){
ensureTyped(t,n,parent.getJSType());
}
else{
ensureTyped(t,n);
}
}

DELETE:
Original line: 269visitObjLitKey(t,key,n);

DELETE:
Original line: 276break;

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

Following are 2th generated patches:
Validating 79 patches...
Tested:545 patches
Compile failed:545 patches
Compilation rate:0.0
NN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/4.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/4.java
Tested:545 patches
Compile failed:545 patches
Compilation rate:0.0

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/5.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/5.java
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:return (n.getType()==Token.NAME)||(n.getType()==Token.GETPROP);
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 1th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 8case Token.NAME :

DELETE:
Original line: 9typeable=visitName(t,n,parent);

DELETE:
Original line: 10break;

DELETE:
Original line: 13ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 15else{
typeable=false;
}

DELETE:
Original line: 18break;

DELETE:
Original line: 19case Token.COMMA :

DELETE:
Original line: 20ensureTyped(t,n,getJSType(n.getLastChild()));

DELETE:
Original line: 21break;

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 28break;

DELETE:
Original line: 29case Token.REF_SPECIAL :

DELETE:
Original line: 30ensureTyped(t,n);

DELETE:
Original line: 31break;

DELETE:
Original line: 33ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 34break;

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 38case Token.NUMBER :

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 40break;

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 42if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}

DELETE:
Original line: 45break;

DELETE:
Original line: 49case Token.ARRAYLIT :

DELETE:
Original line: 51break;

DELETE:
Original line: 52case Token.REGEXP :

DELETE:
Original line: 53ensureTyped(t,n,REGEXP_TYPE);

DELETE:
Original line: 54break;

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 56visitGetProp(t,n,parent);

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 58break;

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 64visitVar(t,n);

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 69typeable=true;

DELETE:
Original line: 70break;

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 73typeable=!NodeUtil.isExpressionNode(parent);

DELETE:
Original line: 74break;

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 76visitReturn(t,n);

DELETE:
Original line: 77typeable=false;

DELETE:
Original line: 78break;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 83ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 87break;

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 91case Token.TYPEOF :

DELETE:
Original line: 95childType=getJSType(n.getFirstChild());

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 100break;

DELETE:
Original line: 102case Token.NEG :

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 105ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 106break;

DELETE:
Original line: 107case Token.EQ :

DELETE:
Original line: 109{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 110leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 112JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 113JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 116if(n.getType()==Token.NE){
result=result.not();
}

DELETE:
Original line: 122break;

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 127leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 129JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 130JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 131if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}

DELETE:
Original line: 134ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 135break;

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 138case Token.LE :

DELETE:
Original line: 141leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 142rightType=getJSType(n.getLastChild());

DELETE:
Original line: 146if(leftType.isNumber()){
validator.expectNumber(t,n,rightType,"right side of numeric comparison");
}

DELETE:
Original line: 159ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 166validator.expectObject(t,n,rightType,"'in' requires an object");

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 168ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 171left=n.getFirstChild();

DELETE:
Original line: 172right=n.getLastChild();

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 176validator.expectActualObject(t,right,rightType,"instanceof requires an object");

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 178break;

DELETE:
Original line: 181typeable=false;

DELETE:
Original line: 185case Token.ASSIGN_URSH :

DELETE:
Original line: 187case Token.ASSIGN_MOD :

DELETE:
Original line: 191case Token.ASSIGN_SUB :

DELETE:
Original line: 197case Token.DIV :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 201case Token.BITAND :

DELETE:
Original line: 202case Token.SUB :

DELETE:
Original line: 203case Token.ADD :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 206break;

DELETE:
Original line: 207case Token.DELPROP :

DELETE:
Original line: 211ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 212break;

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 218break;

DELETE:
Original line: 219case Token.WITH :

DELETE:
Original line: 220{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}

DELETE:
Original line: 221Node child=n.getFirstChild();

DELETE:
Original line: 222childType=getJSType(child);

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 228visitFunction(t,n);

DELETE:
Original line: 229break;

DELETE:
Original line: 232case Token.SWITCH :

DELETE:
Original line: 233case Token.BREAK :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 236case Token.SCRIPT :

DELETE:
Original line: 237case Token.EXPR_RESULT :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 240case Token.DEFAULT :

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 243case Token.THROW :

DELETE:
Original line: 245break;

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 252case Token.AND :

DELETE:
Original line: 253case Token.HOOK :

DELETE:
Original line: 254case Token.OBJECTLIT :

DELETE:
Original line: 255case Token.OR :

DELETE:
Original line: 257ensureTyped(t,n);

DELETE:
Original line: 260if((n.getType()==Token.OBJECTLIT)&&(parent.getJSType() instanceof EnumType)){
ensureTyped(t,n,parent.getJSType());
}

DELETE:
Original line: 264ensureTyped(t,n);

DELETE:
Original line: 269visitObjLitKey(t,key,n);

DELETE:
Original line: 272break;

DELETE:
Original line: 273default :

DELETE:
Original line: 274report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 2th generated patches:
Validating 146 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:return (n.getType()==Token.NAME)||(n.getType()==Token.GETPROP);
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 3th generated patches:
Validating 200 patches...
Tested:548 patches
Compile failed:546 patches
Compilation rate:0.0036496350364963502
PNP
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/6.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/6.java
Tested:548 patches
Compile failed:546 patches
Compilation rate:0.0036496350364963502

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/7.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/7.java
Current actions:
INSERT:
3:Node left=n.getFirstChild();
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

INSERT:
4:Node right=n.getLastChild();
TO:
1

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 9typeable=visitName(t,n,parent);

DELETE:
Original line: 10break;

DELETE:
Original line: 11case Token.LP :

DELETE:
Original line: 12if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}

INSERT:
17:visitBinaryOperator(n.getType(),t,n);
TO:
193

DELETE:
Original line: 18break;

INSERT:
18:break;
TO:
193

INSERT:
19:case Token.ASSIGN :
TO:
193

DELETE:
Original line: 19case Token.COMMA :

INSERT:
20:if(isReference(left)){
visitAssignToReference(t,n);
}
TO:
193

DELETE:
Original line: 20ensureTyped(t,n,getJSType(n.getLastChild()));

DELETE:
Original line: 21break;

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

INSERT:
25:}

TO:
263

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 28break;

INSERT:
28:throw new RuntimeException("unreachable");
TO:
273

DELETE:
Original line: 29case Token.REF_SPECIAL :

DELETE:
Original line: 30ensureTyped(t,n);

DELETE:
Original line: 32case Token.GET_REF :

DELETE:
Original line: 33ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 34break;

DELETE:
Original line: 35case Token.NULL :

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 37break;

DELETE:
Original line: 38case Token.NUMBER :

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 40break;

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 42if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}

DELETE:
Original line: 45break;

DELETE:
Original line: 46case Token.GET :

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 48break;

DELETE:
Original line: 49case Token.ARRAYLIT :

DELETE:
Original line: 50ensureTyped(t,n,ARRAY_TYPE);

DELETE:
Original line: 51break;

DELETE:
Original line: 52case Token.REGEXP :

DELETE:
Original line: 53ensureTyped(t,n,REGEXP_TYPE);

DELETE:
Original line: 54break;

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 56visitGetProp(t,n,parent);

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 61typeable=false;

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 64visitVar(t,n);

DELETE:
Original line: 65typeable=false;

DELETE:
Original line: 66break;

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 70break;

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 73typeable=!NodeUtil.isExpressionNode(parent);

DELETE:
Original line: 74break;

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 76visitReturn(t,n);

DELETE:
Original line: 77typeable=false;

DELETE:
Original line: 78break;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 83ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 84break;

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 90break;

DELETE:
Original line: 92ensureTyped(t,n,STRING_TYPE);

DELETE:
Original line: 93break;

DELETE:
Original line: 95childType=getJSType(n.getFirstChild());

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 100break;

DELETE:
Original line: 101case Token.POS :

DELETE:
Original line: 102case Token.NEG :

DELETE:
Original line: 103left=n.getFirstChild();

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 106break;

DELETE:
Original line: 107case Token.EQ :

DELETE:
Original line: 108case Token.NE :

DELETE:
Original line: 109{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 112JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 113JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 114TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);

DELETE:
Original line: 116if(n.getType()==Token.NE){
result=result.not();
}

DELETE:
Original line: 119report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());

DELETE:
Original line: 121ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 122break;

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 126{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 127leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 128rightType=getJSType(n.getLastChild());

DELETE:
Original line: 129JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 130JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 131if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}

DELETE:
Original line: 134ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 135break;

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 138case Token.LE :

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 140case Token.GE :

DELETE:
Original line: 141leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 142rightType=getJSType(n.getLastChild());

DELETE:
Original line: 143if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}

DELETE:
Original line: 159ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 160break;

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 164leftType=getJSType(left);

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 166validator.expectObject(t,n,rightType,"'in' requires an object");

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 169break;

DELETE:
Original line: 170case Token.INSTANCEOF :

DELETE:
Original line: 172right=n.getLastChild();

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 175validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");

DELETE:
Original line: 176validator.expectActualObject(t,right,rightType,"instanceof requires an object");

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 178break;

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 182break;

DELETE:
Original line: 194case Token.LSH :

DELETE:
Original line: 195case Token.RSH :

DELETE:
Original line: 196case Token.URSH :

DELETE:
Original line: 197case Token.DIV :

DELETE:
Original line: 198case Token.MOD :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 201case Token.BITAND :

DELETE:
Original line: 203case Token.ADD :

DELETE:
Original line: 205visitBinaryOperator(n.getType(),t,n);

DELETE:
Original line: 206break;

DELETE:
Original line: 207case Token.DELPROP :

DELETE:
Original line: 209report(t,n,BAD_DELETE);

DELETE:
Original line: 211ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 212break;

DELETE:
Original line: 213case Token.CASE :

DELETE:
Original line: 214JSType switchType=getJSType(parent.getFirstChild());

DELETE:
Original line: 215JSType caseType=getJSType(n.getFirstChild());

DELETE:
Original line: 216validator.expectSwitchMatchesCase(t,n,switchType,caseType);

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 218break;

DELETE:
Original line: 219case Token.WITH :

DELETE:
Original line: 220{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}

DELETE:
Original line: 222childType=getJSType(child);

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 225break;

DELETE:
Original line: 227case Token.FUNCTION :

DELETE:
Original line: 228visitFunction(t,n);

DELETE:
Original line: 229break;

DELETE:
Original line: 230case Token.LABEL :

DELETE:
Original line: 231case Token.LABEL_NAME :

DELETE:
Original line: 232case Token.SWITCH :

DELETE:
Original line: 233case Token.BREAK :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 236case Token.SCRIPT :

DELETE:
Original line: 237case Token.EXPR_RESULT :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 240case Token.DEFAULT :

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 242case Token.DEBUGGER :

DELETE:
Original line: 244typeable=false;

DELETE:
Original line: 245break;

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 247case Token.FOR :

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 249case Token.WHILE :

DELETE:
Original line: 250typeable=false;

DELETE:
Original line: 251break;

DELETE:
Original line: 252case Token.AND :

DELETE:
Original line: 254case Token.OBJECTLIT :

DELETE:
Original line: 256if(n.getJSType()!=null){
ensureTyped(t,n);
}

DELETE:
Original line: 267if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}

DELETE:
Original line: 274report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));

DELETE:
Original line: 276break;

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 1th generated patches:
Validating 200 patches...
Tested:549 patches
Compile failed:547 patches
Compilation rate:0.0036429872495446266
N
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/8.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/8.java
Current actions:
INSERT:
4:ensureTyped(t,n);
TO:
1

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 1th generated patches:
Validating 4 patches...
Current actions:
DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 9typeable=visitName(t,n,parent);

DELETE:
Original line: 10break;

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 24ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 25break;

DELETE:
Original line: 26case Token.THIS :

DELETE:
Original line: 29case Token.REF_SPECIAL :

DELETE:
Original line: 31break;

DELETE:
Original line: 38case Token.NUMBER :

DELETE:
Original line: 40break;

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 51break;

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 56visitGetProp(t,n,parent);

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 61typeable=false;

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 65typeable=false;

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 73typeable=!NodeUtil.isExpressionNode(parent);

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 78break;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 84break;

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 87break;

DELETE:
Original line: 90break;

DELETE:
Original line: 93break;

DELETE:
Original line: 94case Token.BITNOT :

DELETE:
Original line: 99ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 101case Token.POS :

DELETE:
Original line: 102case Token.NEG :

DELETE:
Original line: 103left=n.getFirstChild();

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 105ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 107case Token.EQ :

DELETE:
Original line: 108case Token.NE :

DELETE:
Original line: 110leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 114TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);

DELETE:
Original line: 115if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}

DELETE:
Original line: 128rightType=getJSType(n.getLastChild());

DELETE:
Original line: 130JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 131if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 140case Token.GE :

DELETE:
Original line: 152String message="left side of comparison";

DELETE:
Original line: 155message="right side of comparison";

DELETE:
Original line: 157validator.expectNotNullOrUndefined(t,n,rightType,message,getNativeType(STRING_TYPE));

DELETE:
Original line: 159ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 160break;

DELETE:
Original line: 161case Token.IN :

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 166validator.expectObject(t,n,rightType,"'in' requires an object");

DELETE:
Original line: 168ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 176validator.expectActualObject(t,right,rightType,"instanceof requires an object");

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 182break;

DELETE:
Original line: 185case Token.ASSIGN_URSH :

DELETE:
Original line: 187case Token.ASSIGN_MOD :

DELETE:
Original line: 193case Token.ASSIGN_MUL :

DELETE:
Original line: 196case Token.URSH :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 208if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}

DELETE:
Original line: 212break;

DELETE:
Original line: 215JSType caseType=getJSType(n.getFirstChild());

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 227case Token.FUNCTION :

DELETE:
Original line: 228visitFunction(t,n);

DELETE:
Original line: 229break;

DELETE:
Original line: 230case Token.LABEL :

DELETE:
Original line: 232case Token.SWITCH :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 239case Token.EMPTY :

DELETE:
Original line: 242case Token.DEBUGGER :

DELETE:
Original line: 254case Token.OBJECTLIT :

DELETE:
Original line: 259else{
if((n.getType()==Token.OBJECTLIT)&&(parent.getJSType() instanceof EnumType)){
ensureTyped(t,n,parent.getJSType());
}
else{
ensureTyped(t,n);
}
}

DELETE:
Original line: 267if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}

DELETE:
Original line: 272break;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

Following are 2th generated patches:
Validating 89 patches...
Current actions:
DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 28break;

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 65typeable=false;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 117result=result.not();

DELETE:
Original line: 149if(leftType.matchesNumberContext()&&rightType.matchesNumberContext()){
}

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 167validator.expectString(t,left,leftType,"left side of 'in'");

DELETE:
Original line: 198case Token.MOD :

DELETE:
Original line: 216validator.expectSwitchMatchesCase(t,n,switchType,caseType);

DELETE:
Original line: 232case Token.SWITCH :

DELETE:
Original line: 261ensureTyped(t,n,parent.getJSType());

DELETE:
Original line: 280doPercentTypedAccounting(t,n);

Following are 3th generated patches:
Validating 15 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
3:visitAssignOrBinop(t,n);
TO:
1

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 12if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}

DELETE:
Original line: 18break;

DELETE:
Original line: 21break;

DELETE:
Original line: 22case Token.TRUE :

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 25break;

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 28break;

DELETE:
Original line: 29case Token.REF_SPECIAL :

DELETE:
Original line: 32case Token.GET_REF :

DELETE:
Original line: 34break;

DELETE:
Original line: 36ensureTyped(t,n,NULL_TYPE);

DELETE:
Original line: 37break;

DELETE:
Original line: 38case Token.NUMBER :

DELETE:
Original line: 40break;

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 48break;

DELETE:
Original line: 49case Token.ARRAYLIT :

DELETE:
Original line: 50ensureTyped(t,n,ARRAY_TYPE);

DELETE:
Original line: 52case Token.REGEXP :

DELETE:
Original line: 54break;

DELETE:
Original line: 55case Token.GETPROP :

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 62break;

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 64visitVar(t,n);

DELETE:
Original line: 67case Token.NEW :

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 73typeable=!NodeUtil.isExpressionNode(parent);

DELETE:
Original line: 74break;

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 78break;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 82validator.expectNumber(t,left,getJSType(left),"increment/decrement");

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 89ensureTyped(t,n,VOID_TYPE);

DELETE:
Original line: 90break;

DELETE:
Original line: 91case Token.TYPEOF :

DELETE:
Original line: 92ensureTyped(t,n,STRING_TYPE);

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 103left=n.getFirstChild();

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 110leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 112JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 115if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}

DELETE:
Original line: 121ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 122break;

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 129JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 130JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 132report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 138case Token.LE :

DELETE:
Original line: 139case Token.GT :

DELETE:
Original line: 140case Token.GE :

DELETE:
Original line: 141leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 142rightType=getJSType(n.getLastChild());

DELETE:
Original line: 143if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}

DELETE:
Original line: 161case Token.IN :

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 164leftType=getJSType(left);

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 166validator.expectObject(t,n,rightType,"'in' requires an object");

DELETE:
Original line: 173leftType=getJSType(left);

DELETE:
Original line: 174rightType=getJSType(right).restrictByNotNullOrUndefined();

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 178break;

DELETE:
Original line: 179case Token.ASSIGN :

DELETE:
Original line: 182break;

DELETE:
Original line: 183case Token.ASSIGN_LSH :

DELETE:
Original line: 187case Token.ASSIGN_MOD :

DELETE:
Original line: 189case Token.ASSIGN_BITXOR :

DELETE:
Original line: 192case Token.ASSIGN_ADD :

DELETE:
Original line: 194case Token.LSH :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 209report(t,n,BAD_DELETE);

DELETE:
Original line: 211ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 212break;

DELETE:
Original line: 215JSType caseType=getJSType(n.getFirstChild());

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 218break;

DELETE:
Original line: 219case Token.WITH :

DELETE:
Original line: 220{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}

DELETE:
Original line: 221Node child=n.getFirstChild();

DELETE:
Original line: 222childType=getJSType(child);

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 224typeable=false;

DELETE:
Original line: 225break;

DELETE:
Original line: 227case Token.FUNCTION :

DELETE:
Original line: 231case Token.LABEL_NAME :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 242case Token.DEBUGGER :

DELETE:
Original line: 245break;

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 247case Token.FOR :

DELETE:
Original line: 250typeable=false;

DELETE:
Original line: 254case Token.OBJECTLIT :

DELETE:
Original line: 256if(n.getJSType()!=null){
ensureTyped(t,n);
}

DELETE:
Original line: 267if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}

DELETE:
Original line: 273default :

DELETE:
Original line: 275ensureTyped(t,n);

DELETE:
Original line: 276break;

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

Following are 4th generated patches:
Validating 200 patches...
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
4:ensureTyped(t,n);
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 8case Token.NAME :

DELETE:
Original line: 9typeable=visitName(t,n,parent);

DELETE:
Original line: 10break;

DELETE:
Original line: 11case Token.LP :

DELETE:
Original line: 13ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 18break;

DELETE:
Original line: 19case Token.COMMA :

DELETE:
Original line: 20ensureTyped(t,n,getJSType(n.getLastChild()));

DELETE:
Original line: 23case Token.FALSE :

DELETE:
Original line: 26case Token.THIS :

DELETE:
Original line: 27ensureTyped(t,n,t.getScope().getTypeOfThis());

DELETE:
Original line: 28break;

DELETE:
Original line: 29case Token.REF_SPECIAL :

DELETE:
Original line: 30ensureTyped(t,n);

DELETE:
Original line: 31break;

DELETE:
Original line: 32case Token.GET_REF :

DELETE:
Original line: 33ensureTyped(t,n,getJSType(n.getFirstChild()));

DELETE:
Original line: 34break;

DELETE:
Original line: 35case Token.NULL :

DELETE:
Original line: 38case Token.NUMBER :

DELETE:
Original line: 39ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 41case Token.STRING :

DELETE:
Original line: 42if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}

DELETE:
Original line: 45break;

DELETE:
Original line: 46case Token.GET :

DELETE:
Original line: 47case Token.SET :

DELETE:
Original line: 48break;

DELETE:
Original line: 50ensureTyped(t,n,ARRAY_TYPE);

DELETE:
Original line: 51break;

DELETE:
Original line: 52case Token.REGEXP :

DELETE:
Original line: 53ensureTyped(t,n,REGEXP_TYPE);

DELETE:
Original line: 54break;

DELETE:
Original line: 57typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);

DELETE:
Original line: 58break;

DELETE:
Original line: 59case Token.GETELEM :

DELETE:
Original line: 60visitGetElem(t,n);

DELETE:
Original line: 61typeable=false;

DELETE:
Original line: 62break;

DELETE:
Original line: 63case Token.VAR :

DELETE:
Original line: 65typeable=false;

DELETE:
Original line: 66break;

DELETE:
Original line: 68visitNew(t,n);

DELETE:
Original line: 71case Token.CALL :

DELETE:
Original line: 73typeable=!NodeUtil.isExpressionNode(parent);

DELETE:
Original line: 74break;

DELETE:
Original line: 75case Token.RETURN :

DELETE:
Original line: 76visitReturn(t,n);

DELETE:
Original line: 77typeable=false;

DELETE:
Original line: 78break;

DELETE:
Original line: 79case Token.DEC :

DELETE:
Original line: 80case Token.INC :

DELETE:
Original line: 81left=n.getFirstChild();

DELETE:
Original line: 82validator.expectNumber(t,left,getJSType(left),"increment/decrement");

DELETE:
Original line: 83ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 84break;

DELETE:
Original line: 85case Token.NOT :

DELETE:
Original line: 87break;

DELETE:
Original line: 88case Token.VOID :

DELETE:
Original line: 90break;

DELETE:
Original line: 93break;

DELETE:
Original line: 94case Token.BITNOT :

DELETE:
Original line: 96if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}

DELETE:
Original line: 99ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 100break;

DELETE:
Original line: 101case Token.POS :

DELETE:
Original line: 102case Token.NEG :

DELETE:
Original line: 103left=n.getFirstChild();

DELETE:
Original line: 104validator.expectNumber(t,left,getJSType(left),"sign operator");

DELETE:
Original line: 105ensureTyped(t,n,NUMBER_TYPE);

DELETE:
Original line: 106break;

DELETE:
Original line: 107case Token.EQ :

DELETE:
Original line: 109{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 110leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 111rightType=getJSType(n.getLastChild());

DELETE:
Original line: 112JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();

DELETE:
Original line: 113JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 115if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}

DELETE:
Original line: 121ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 122break;

DELETE:
Original line: 124case Token.SHEQ :

DELETE:
Original line: 125case Token.SHNE :

DELETE:
Original line: 126{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}

DELETE:
Original line: 127leftType=getJSType(n.getFirstChild());

DELETE:
Original line: 130JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();

DELETE:
Original line: 132report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());

DELETE:
Original line: 135break;

DELETE:
Original line: 137case Token.LT :

DELETE:
Original line: 138case Token.LE :

DELETE:
Original line: 142rightType=getJSType(n.getLastChild());

DELETE:
Original line: 143if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}

DELETE:
Original line: 159ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 160break;

DELETE:
Original line: 161case Token.IN :

DELETE:
Original line: 162left=n.getFirstChild();

DELETE:
Original line: 163right=n.getLastChild();

DELETE:
Original line: 165rightType=getJSType(right);

DELETE:
Original line: 166validator.expectObject(t,n,rightType,"'in' requires an object");

DELETE:
Original line: 169break;

DELETE:
Original line: 170case Token.INSTANCEOF :

DELETE:
Original line: 171left=n.getFirstChild();

DELETE:
Original line: 172right=n.getLastChild();

DELETE:
Original line: 175validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");

DELETE:
Original line: 176validator.expectActualObject(t,right,rightType,"instanceof requires an object");

DELETE:
Original line: 177ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 178break;

DELETE:
Original line: 180visitAssign(t,n);

DELETE:
Original line: 181typeable=false;

DELETE:
Original line: 185case Token.ASSIGN_URSH :

DELETE:
Original line: 188case Token.ASSIGN_BITOR :

DELETE:
Original line: 189case Token.ASSIGN_BITXOR :

DELETE:
Original line: 190case Token.ASSIGN_BITAND :

DELETE:
Original line: 191case Token.ASSIGN_SUB :

DELETE:
Original line: 192case Token.ASSIGN_ADD :

DELETE:
Original line: 193case Token.ASSIGN_MUL :

DELETE:
Original line: 194case Token.LSH :

DELETE:
Original line: 196case Token.URSH :

DELETE:
Original line: 197case Token.DIV :

DELETE:
Original line: 198case Token.MOD :

DELETE:
Original line: 199case Token.BITOR :

DELETE:
Original line: 200case Token.BITXOR :

DELETE:
Original line: 201case Token.BITAND :

DELETE:
Original line: 202case Token.SUB :

DELETE:
Original line: 203case Token.ADD :

DELETE:
Original line: 204case Token.MUL :

DELETE:
Original line: 205visitBinaryOperator(n.getType(),t,n);

DELETE:
Original line: 207case Token.DELPROP :

DELETE:
Original line: 208if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}

DELETE:
Original line: 211ensureTyped(t,n,BOOLEAN_TYPE);

DELETE:
Original line: 212break;

DELETE:
Original line: 213case Token.CASE :

DELETE:
Original line: 215JSType caseType=getJSType(n.getFirstChild());

DELETE:
Original line: 216validator.expectSwitchMatchesCase(t,n,switchType,caseType);

DELETE:
Original line: 217typeable=false;

DELETE:
Original line: 221Node child=n.getFirstChild();

DELETE:
Original line: 222childType=getJSType(child);

DELETE:
Original line: 223validator.expectObject(t,child,childType,"with requires an object");

DELETE:
Original line: 224typeable=false;

DELETE:
Original line: 227case Token.FUNCTION :

DELETE:
Original line: 228visitFunction(t,n);

DELETE:
Original line: 229break;

DELETE:
Original line: 232case Token.SWITCH :

DELETE:
Original line: 234case Token.CATCH :

DELETE:
Original line: 235case Token.TRY :

DELETE:
Original line: 238case Token.BLOCK :

DELETE:
Original line: 241case Token.CONTINUE :

DELETE:
Original line: 242case Token.DEBUGGER :

DELETE:
Original line: 243case Token.THROW :

DELETE:
Original line: 246case Token.DO :

DELETE:
Original line: 248case Token.IF :

DELETE:
Original line: 251break;

DELETE:
Original line: 253case Token.HOOK :

DELETE:
Original line: 254case Token.OBJECTLIT :

DELETE:
Original line: 256if(n.getJSType()!=null){
ensureTyped(t,n);
}

DELETE:
Original line: 267if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}

DELETE:
Original line: 273default :

DELETE:
Original line: 274report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));

DELETE:
Original line: 276break;

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Tested:553 patches
Compile failed:550 patches
Compilation rate:0.0054249547920434
PNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/9.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/9.java
Current actions:
DELETE:
Original line: 3JSType childType;

DELETE:
Original line: 4JSType leftType,rightType;

INSERT:
5:if(isPercentTyped(current)){
return ;
}
TO:
1

DELETE:
Original line: 5Node left,right;

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
8:current=current.getParent();
TO:
1

INSERT:
10:JSType type=getJSType(n);
TO:
1

INSERT:
11:if(type!=null&&!type.isUnknownType()&&!type.isNoType()){
percentTypedNodes+=1;
}
TO:
1

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 1th generated patches:
Validating 200 patches...
Current actions:
INSERT:
3:Node current=n.getParent();
TO:
1

DELETE:
Original line: 4JSType leftType,rightType;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

Following are 2th generated patches:
Validating 200 patches...
Tested:555 patches
Compile failed:551 patches
Compilation rate:0.007207207207207207
NP
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/10.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/10.java
Tested:555 patches
Compile failed:551 patches
Compilation rate:0.007207207207207207

Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/11.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/11.java
Current actions:
DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
19:if(left.getParent().getType()==Token.VAR){
validator.expectAssignable(t,left,leftType,rightType,"variable initialization");
}
TO:
8

UPDATE
FROM:
222:childType=getJSType(child);
TO:
29:leftType=getJSType(left);

UPDATE
FROM:
221:Node child=n.getFirstChild();
TO:
42:Node target=left.getFirstChild();

INSERT:
44:leftType=getJSType(target);
TO:
221

INSERT:
58:leftType=getJSType(left);
TO:
210

UPDATE
FROM:
104:validator.expectNumber(t,left,getJSType(left),"sign operator");
TO:
59:validator.expectLValue(t,left,leftType,"assignment");

UPDATE
FROM:
167:validator.expectString(t,left,leftType,"left side of 'in'");
TO:
60:validator.expectAssignable(t,left,leftType,rightType,"assignment");

INSERT:
62:case Token.OBJECTLIT :
TO:
218

INSERT:
65:JSType.Builder rightTypeBuilder=rightType.toBuilder();
TO:
220

INSERT:
66:JSType rightTypeWithMissingProperties=rightTypeBuilder.build();
TO:
220

INSERT:
68:validator.expectAssignable(t,left,leftType,rightTypeWithMissingProperties,"assignment");
TO:
220

INSERT:
72:report(t,n,BAD_ASSIGNMENT);
TO:
273

DELETE:
Original line: 278typeable=typeable&&!inExterns;

Following are 1th generated patches:
Validating 200 patches...
Tested:753 patches
Compile failed:749 patches
Compilation rate:0.005312084993359893
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/12.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/12.java
Current actions:
DELETE:
Original line: 3JSType childType;

INSERT:
4:Node right=n.getLastChild();
TO:
1

UPDATE
FROM:
4:JSType leftType,rightType;
TO:
5:JSType leftType=getJSType(left);

DELETE:
Original line: 5Node left,right;

INSERT:
6:JSType rightType=getJSType(right);
TO:
4

DELETE:
Original line: 6boolean typeable=true;

DELETE:
Original line: 7switch (n.getType()){
case Token.NAME :
typeable=visitName(t,n,parent);
break;
case Token.LP :
if(parent.getType()!=Token.FUNCTION){
ensureTyped(t,n,getJSType(n.getFirstChild()));
}
break;
case Token.COMMA :
ensureTyped(t,n,getJSType(n.getLastChild()));
break;
case Token.TRUE :
case Token.FALSE :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.THIS :
ensureTyped(t,n,t.getScope().getTypeOfThis());
break;
case Token.REF_SPECIAL :
ensureTyped(t,n);
break;
case Token.GET_REF :
ensureTyped(t,n,getJSType(n.getFirstChild()));
break;
case Token.NULL :
ensureTyped(t,n,NULL_TYPE);
break;
case Token.NUMBER :
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.STRING :
if(!NodeUtil.isObjectLitKey(n,n.getParent())){
ensureTyped(t,n,STRING_TYPE);
}
break;
case Token.GET :
case Token.SET :
break;
case Token.ARRAYLIT :
ensureTyped(t,n,ARRAY_TYPE);
break;
case Token.REGEXP :
ensureTyped(t,n,REGEXP_TYPE);
break;
case Token.GETPROP :
visitGetProp(t,n,parent);
typeable=!(parent.getType()==Token.ASSIGN&&parent.getFirstChild()==n);
break;
case Token.GETELEM :
visitGetElem(t,n);
typeable=false;
break;
case Token.VAR :
visitVar(t,n);
typeable=false;
break;
case Token.NEW :
visitNew(t,n);
typeable=true;
break;
case Token.CALL :
visitCall(t,n);
typeable=!NodeUtil.isExpressionNode(parent);
break;
case Token.RETURN :
visitReturn(t,n);
typeable=false;
break;
case Token.DEC :
case Token.INC :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"increment/decrement");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.NOT :
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.VOID :
ensureTyped(t,n,VOID_TYPE);
break;
case Token.TYPEOF :
ensureTyped(t,n,STRING_TYPE);
break;
case Token.BITNOT :
childType=getJSType(n.getFirstChild());
if(!childType.matchesInt32Context()){
report(t,n,BIT_OPERATION,NodeUtil.opToStr(n.getType()),childType.toString());
}
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.POS :
case Token.NEG :
left=n.getFirstChild();
validator.expectNumber(t,left,getJSType(left),"sign operator");
ensureTyped(t,n,NUMBER_TYPE);
break;
case Token.EQ :
case Token.NE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
TernaryValue result=leftTypeRestricted.testForEquality(rightTypeRestricted);
if(result!=TernaryValue.UNKNOWN){
if(n.getType()==Token.NE){
result=result.not();
}
report(t,n,DETERMINISTIC_TEST,leftType.toString(),rightType.toString(),result.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.SHEQ :
case Token.SHNE :
{
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted=rightType.restrictByNotNullOrUndefined();
if(!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)){
report(t,n,DETERMINISTIC_TEST_NO_RESULT,leftType.toString(),rightType.toString());
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
}
case Token.LT :
case Token.LE :
case Token.GT :
case Token.GE :
leftType=getJSType(n.getFirstChild());
rightType=getJSType(n.getLastChild());
if(rightType.isNumber()){
validator.expectNumber(t,n,leftType,"left side of numeric comparison");
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.IN :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right);
validator.expectObject(t,n,rightType,"'in' requires an object");
validator.expectString(t,left,leftType,"left side of 'in'");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.INSTANCEOF :
left=n.getFirstChild();
right=n.getLastChild();
leftType=getJSType(left);
rightType=getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(t,left,leftType,"deterministic instanceof yields false");
validator.expectActualObject(t,right,rightType,"instanceof requires an object");
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.ASSIGN :
visitAssign(t,n);
typeable=false;
break;
case Token.ASSIGN_LSH :
case Token.ASSIGN_RSH :
case Token.ASSIGN_URSH :
case Token.ASSIGN_DIV :
case Token.ASSIGN_MOD :
case Token.ASSIGN_BITOR :
case Token.ASSIGN_BITXOR :
case Token.ASSIGN_BITAND :
case Token.ASSIGN_SUB :
case Token.ASSIGN_ADD :
case Token.ASSIGN_MUL :
case Token.LSH :
case Token.RSH :
case Token.URSH :
case Token.DIV :
case Token.MOD :
case Token.BITOR :
case Token.BITXOR :
case Token.BITAND :
case Token.SUB :
case Token.ADD :
case Token.MUL :
visitBinaryOperator(n.getType(),t,n);
break;
case Token.DELPROP :
if(!isReference(n.getFirstChild())){
report(t,n,BAD_DELETE);
}
ensureTyped(t,n,BOOLEAN_TYPE);
break;
case Token.CASE :
JSType switchType=getJSType(parent.getFirstChild());
JSType caseType=getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t,n,switchType,caseType);
typeable=false;
break;
case Token.WITH :
{
Node child=n.getFirstChild();
childType=getJSType(child);
validator.expectObject(t,child,childType,"with requires an object");
typeable=false;
break;
}
case Token.FUNCTION :
visitFunction(t,n);
break;
case Token.LABEL :
case Token.LABEL_NAME :
case Token.SWITCH :
case Token.BREAK :
case Token.CATCH :
case Token.TRY :
case Token.SCRIPT :
case Token.EXPR_RESULT :
case Token.BLOCK :
case Token.EMPTY :
case Token.DEFAULT :
case Token.CONTINUE :
case Token.DEBUGGER :
case Token.THROW :
typeable=false;
break;
case Token.DO :
case Token.FOR :
case Token.IF :
case Token.WHILE :
typeable=false;
break;
case Token.AND :
case Token.HOOK :
case Token.OBJECTLIT :
case Token.OR :
if(n.getJSType()!=null){
ensureTyped(t,n);
}
if(n.getType()==Token.OBJECTLIT){
for(Node key : n.children()){
visitObjLitKey(t,key,n);
}
}
break;
default :
report(t,n,UNEXPECTED_TOKEN,Token.name(n.getType()));
ensureTyped(t,n);
break;
}

INSERT:
7:JSType leftTypeRestricted=leftType.restrictByNotNullOrUndefined();
TO:
4

INSERT:
13:report(t,n,ASSIGNMENT_TO_IMMUTABLE_TYPE);
TO:
4

INSERT:
15:if(!leftTypeRestricted.isSubtype(rightType.restrictByNotNullOrUndefined())){
report(t,n,INCOMPATIBLE_TYPES,leftType.toString(),rightType.toString());
}
TO:
4

INSERT:
18:ensureTyped(t,n,leftType);
TO:
4

DELETE:
Original line: 278typeable=typeable&&!inExterns;

DELETE:
Original line: 279if(typeable){
doPercentTypedAccounting(t,n);
}

DELETE:
Original line: 282checkNoTypeCheckSection(n,false);

Following are 1th generated patches:
Validating 200 patches...
Tested:843 patches
Compile failed:839 patches
Compilation rate:0.004744958481613286
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
Current file:/data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/13.java
Patch Number: /data/PLM4APR/codex_out/200_patches_starcoder_all/closure_66/13.java
Tested:843 patches
Compile failed:839 patches
Compilation rate:0.004744958481613286

Finish : closure-66 > patch : 0 | Start : Wed Apr 10 15:51:28 HKT 2024 | End : 2024.04.10 AD at 15:53:42 HKT
