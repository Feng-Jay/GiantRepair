Repair : time_26
Current failed test : org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2 | 2019.09.05 AD at 05:41:46 CDT
Location : org.joda.time.DateTime.withMinuteOfHour:[1662]#0.4472135954999579
Compute Candidate : 2019.09.05 AD at 05:44:23 CDT - 2019.09.05 AD at 05:49:02 CDT , PNumber : 11258, CandNumber : 32 
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour().add(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V48/2994/pattern-ver1-serial/src.Model.java-clusterData.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:49:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+int a=0;
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:49:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour().set(getMillis()-22,minute));
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/2147/pattern-ver1-serial/src.main.java.ch.bfh.ti.projekt1.sokoban.view.GameWindowView.java-loadSolutionFile.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:49:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+String OUTSTRING="";
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:49:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+if(equals(minute)){
+return null;
+}
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:49:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour().set(Math.max(getMillis(),minute),minute));
 }

PATTERN : /home/jiajun/GithubData/2016/V11/4531/pattern-ver1-serial/rsen.src.main.java.com.rsen.github.common.L.java-i.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:49:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+int a=1;
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:49:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour().set(getMillis()+1,minute));
 }

PATTERN : /home/jiajun/GithubData/2015/V22/7285/pattern-ver1-serial/jm-prta-parser.src.main.java.org.meyerlab.nopence.jm_prta_parser.attributes.NumericAttribute.java-getBinByValue.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:49:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+boolean b=true;
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:49:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+if(getChronology()==null){
+return null;
+}
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:49:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+if(getChronology().minuteOfHour()==null){
+return null;
+}
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:50:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+if(minute<0){
+return null;
+}
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2016/V23/1167/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.router.Publishers.java-receivedData.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:50:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour().set(getMillis(),minute)-1);
 }

PATTERN : /home/jiajun/GithubData/2015/V16/4594/pattern-ver1-serial/EzSignin.app.src.main.java.signin.ez.ezsignin.MainActivity.java-populateFieldsWithRecord.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:50:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour().set(getMillis(),minute)*-1);
 }

PATTERN : /home/jiajun/GithubData/2016/V33/1084/pattern-ver1-serial/Bank.src.entities.Account.java-returnLoan.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:50:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour().set(getMillis(),minute)*1000);
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/3175/pattern-ver1-serial/src.de.fuberlin.wiwiss.d2rq.server.D2RServer.java-describe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:50:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour()==null?null:getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2015/V31/4299/pattern-ver1-serial/client.synapseJavaClient.src.main.java.org.sagebionetworks.client.SynapseClientImpl.java-uploadToS3FileHandle.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:50:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour()!=null?getChronology().minuteOfHour().set(getMillis(),minute):null);
 }

PATTERN : /home/jiajun/GithubData/2016/V2/4302/pattern-ver1-serial/src.com.floreantpos.model.KitchenTicket.java-fromTicket.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:50:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+assert (minute>=0):"Receive a negative tratment";
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6481/pattern-ver1-serial/QualCurso.app.src.main.java.models.Book.java-setChapters.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:50:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
+import java.util.Calendar;
+
+import java.util.Date;
+
 public DateTime withMinuteOfHour(int minute){
+assert (minute!=0):"Receive a size tratment";
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6481/pattern-ver1-serial/QualCurso.app.src.main.java.models.Course.java-newArray.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:50:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(Math.abs(getChronology().minuteOfHour().set(getMillis(),minute)));
 }

PATTERN : /home/jiajun/GithubData/2016/V31/6264/pattern-ver1-serial/src.main.java.com.metal.fetcher.fetcher.impl.WeiboFetcher.java-getRandomAccount.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:50:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour().set(getMillis(),minute)&0xff);
 }

PATTERN : /home/jiajun/GithubData/2015/V4/4742/pattern-ver1-serial/src.uk.ac.herts.SmartLab.XBee.Response.XBeeRx16Response.java-GetReceiveStatus.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:51:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return this;
 }

PATTERN : /home/jiajun/GithubData/2015/V4/2420/pattern-ver1-serial/Nian_Karl.QL.src.org.uva.ql.ast.value.Undefined.java-getValue.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:51:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMinuteOfHour(0);
 }

PATTERN : /home/jiajun/GithubData/2015/V40/1788/pattern-ver1-serial/src.org.expression.parser.ExpressionParser.java-expr.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:51:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return null;
 }

PATTERN : /home/jiajun/GithubData/2016/V48/2471/pattern-ver1-serial/src.com.widerwille.afterglow.AfterglowIconProvider.java-getIcon.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:51:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+if(getChronology()==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:51:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+if(getChronology().minuteOfHour()==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:51:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
+if(minute>7){
+throw new RuntimeException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
+}
 return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:51:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return new DateTime(withMillis(getChronology().minuteOfHour().set(getMillis(),minute)));
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/2421/pattern-ver1-serial/src.uk.co.quartzcraft.kingdoms.features.kingdom.Kingdom.java-getKing.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:51:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return (DateTime)withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2011/V1/5127/pattern-ver1-serial/com.buglabs.common.com.buglabs.bug.sysfs.BMIDevice.java-apply.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:51:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour().set(getMillis(),minute))!=null?withMillis(getChronology().minuteOfHour().set(getMillis(),minute)):new DateTime();
 }

PATTERN : /home/jiajun/GithubData/2016/V23/4736/pattern-ver1-serial/server.src.main.java.com.paypal.selion.grid.SeLionStandaloneConfiguration.java-getStandaloneConfiguration.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:51:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return withMillis(getChronology().minuteOfHour().set(getMillis(),minute))==null?new DateTime():withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
 }

PATTERN : /home/jiajun/GithubData/2016/V2/5999/pattern-ver1-serial/persistence.src.main.java.com.softserve.osbb.model.Bill.java-getApartment.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:51:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[1649,1663]
------------Candidate---------------
 public DateTime withMinuteOfHour(int minute){
-return withMillis(getChronology().minuteOfHour().set(getMillis(),minute));
+return (DateTime)(withMillis(getChronology().minuteOfHour().set(getMillis(),minute)));
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/1621/pattern-ver1-serial/src.lab4.FileService.FileService.java-readFile.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:52:00 CDT
--------------- END -----------------
Location : org.joda.time.DateTime.DateTime:[220, 219]#0.15249857033260467
Compute Candidate : 2019.09.05 AD at 05:52:20 CDT - 2019.09.05 AD at 05:56:10 CDT , PNumber : 11268, CandNumber : 14 
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+return ;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:56:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+while(true){
+
+}
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:58:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+instant=this;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/4878/pattern-ver1-serial/app.src.main.java.com.trukr.shipper.activity.Notification.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:58:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+instant=instant;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:58:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+instant=zone;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:58:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+zone=zone;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:58:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:58:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+int indexSelection=0;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:58:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+boolean loggingIn=false;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/2030/pattern-ver1-serial/src.client.gui.batchstate.BatchState.java-BatchState.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:58:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+assert (instant!=null);
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:58:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+assert (zone!=null);
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:59:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+if((Thread.currentThread().interrupted())){
+return ;
+}
 }

PATTERN : /home/jiajun/GithubData/2015/V16/2/pattern-ver1-serial/src.com.grishberg.data.api.MqServer.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:59:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:59:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/DateTime.java[198,220]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public DateTime(Object instant,DateTimeZone zone){
 super(instant,zone);
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 05:59:19 CDT
--------------- END -----------------
Location : org.joda.time.format.DateTimeFormatterBuilder.parseInto:[2686, 2687, 2706, 2721, 2715, 2716, 2718, 2699, 2700, 2713, 2697, 2691, 2692, 2683, 2703, 2704, 2705, 2710, 2668, 2669, 2671, 2672, 2674, 2675, 2677, 2679, 2680, 2681, 2689, 2690]#0.14744195615489714
Compute Candidate : 2019.09.05 AD at 05:59:38 CDT - 2019.09.05 AD at 07:07:58 CDT , PNumber : 11347, CandNumber : 932 
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+continue;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:08:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+continue;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:08:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+continue;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:08:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+continue;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/5856/pattern-ver1-serial/internalLibraries.backup.src.main.java.com.emc.storageos.management.backup.DbBackupHandler.java-dumpBackup.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:08:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+continue;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/5856/pattern-ver1-serial/internalLibraries.backup.src.main.java.com.emc.storageos.management.backup.DbBackupHandler.java-dumpBackup.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:08:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
- final Object originalState=bucket.saveState();
+ Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:08:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
-int parsePos=parser.parseInto(bucket,text,position);
+ int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:08:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
-Object bestValidState=null;
+ Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:08:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
-DateTimeParser[] parsers=iParsers;
+ DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:08:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
+ int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:09:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
-boolean isOptional=false;
+ boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:09:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
-int bestValidPos=position;
+ int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:09:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
-DateTimeParser parser=parsers[i];
+ DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:09:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
-int bestInvalidPos=position;
+ int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:09:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position&&(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V17/3484/pattern-ver1-serial/src.com.massivecraft.creativegates.MainListener.java-stabilizePortalContent.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:09:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>1||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5133/pattern-ver1-serial/app.src.main.java.com.bignerdranch.android.photogallery.PhotoGalleryFragment.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:09:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>1){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5133/pattern-ver1-serial/app.src.main.java.com.bignerdranch.android.photogallery.PhotoGalleryFragment.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:09:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos>1){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5133/pattern-ver1-serial/app.src.main.java.com.bignerdranch.android.photogallery.PhotoGalleryFragment.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:09:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos==0&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/4568/pattern-ver1-serial/src.client.game.GameFrame.java-received.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:10:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>=position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/3225/pattern-ver1-serial/src.org.peg4d.ParserContext.java-beginPeformStat.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:10:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>=bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/3225/pattern-ver1-serial/src.org.peg4d.ParserContext.java-beginPeformStat.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:10:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos>=bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/3225/pattern-ver1-serial/src.org.peg4d.ParserContext.java-beginPeformStat.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:10:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(bestValidState==null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V40/1240/pattern-ver1-serial/flexo-foundation.src.main.java.org.openflexo.foundation.viewpoint.FlexoConceptInstanceRole.java-applyValidation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:10:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=1;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:10:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=1;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:10:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+return 0;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:10:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+return 0;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:10:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+return 0;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:10:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+return 0;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:10:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+return 0;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:11:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
-if(parser==null){
+if(parser!=null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/4111/pattern-ver1-serial/tephra-core.src.main.java.co.cask.tephra.snapshot.SnapshotCodecV4.java-encodeInProgress.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:11:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+return 0;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V41/1695/pattern-ver1-serial/src.fr.project.bluechat.layout.activity.MainActivity.java-newName.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:11:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;bestInvalidPos<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/7268/pattern-ver1-serial/src.org.easypr.core.CharsSegment.java-SortRect.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:11:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;bestValidPos<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/7268/pattern-ver1-serial/src.org.easypr.core.CharsSegment.java-SortRect.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:11:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(bestInvalidPos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/7268/pattern-ver1-serial/src.org.easypr.core.CharsSegment.java-SortRect.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:11:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;position<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/7268/pattern-ver1-serial/src.org.easypr.core.CharsSegment.java-SortRect.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:11:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return 1;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/377/pattern-ver1-serial/src.kreuzungsSimulation.EventComparator.java-compare.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:11:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return 1;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/377/pattern-ver1-serial/src.kreuzungsSimulation.EventComparator.java-compare.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:11:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
+long length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V23/3496/pattern-ver1-serial/teavm-classlib.src.main.java.org.teavm.classlib.java.lang.TAbstractStringBuilder.java-append.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:11:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=0;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V64/1097/pattern-ver1-serial/plugins.de.ovgu.featureide.core.mpl.src.de.ovgu.featureide.core.mpl.signature.javadoc.AJavaDocCommentMerger.java-parseTags.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:12:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=0;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V64/1097/pattern-ver1-serial/plugins.de.ovgu.featureide.core.mpl.src.de.ovgu.featureide.core.mpl.signature.javadoc.AJavaDocCommentMerger.java-parseTags.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:12:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V28/6188/pattern-ver1-serial/GravityGame.GravityGameApplet.java-onEditLocX1.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:12:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<=0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V45/3857/pattern-ver1-serial/src.com.urverkspel.humancompanion.AttackData.java-roll.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:12:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<=length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V45/3857/pattern-ver1-serial/src.com.urverkspel.humancompanion.AttackData.java-roll.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:12:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+parsePos=~parsePos;
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:12:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+parsePos=~parsePos;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:12:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+parsePos=~parsePos;
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:12:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+parsePos=~parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:12:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<=2){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V42/3732/pattern-ver1-serial/reformulation-core.src.main.java.org.semanticweb.ontop.owlrefplatform.core.unfolding.TypeLift.java-f.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:12:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.Collection;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0,myUid;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V12/276/pattern-ver1-serial/actor-sdk.sdk-core.core.core-shared.src.main.java.im.actor.core.viewmodel.GroupVM.java-create.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:13:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0,DEFAULT_TIMEOUT2;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V49/3872/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ManageAccount.java-addNewUserAccount.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:13:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length&&parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V7/7763/pattern-ver1-serial/app.src.main.java.cheaphone.gui.Offerta.java-setOffert.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:13:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()&&(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V7/7763/pattern-ver1-serial/app.src.main.java.cheaphone.gui.Offerta.java-setOffert.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:13:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos>0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V44/4500/pattern-ver1-serial/src.main.java.com.michael.e.liquislots.item.ItemLiquipack.java-addInformation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:13:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i>length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V44/4500/pattern-ver1-serial/src.main.java.com.michael.e.liquislots.item.ItemLiquipack.java-addInformation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:13:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4108/pattern-ver1-serial/src.main.java.org.roaringbitmap.buffer.MappeableArrayContainer.java-inot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:13:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos>position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4108/pattern-ver1-serial/src.main.java.org.roaringbitmap.buffer.MappeableArrayContainer.java-inot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:13:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0,MAX_SERVICE_NODES;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V48/4395/pattern-ver1-serial/vipr-portal.com.emc.sa.common.src.java.com.emc.sa.zookeeper.ZkServiceDescriptors.java-start.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:13:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0,MAX_ZK_WAIT_RETRY_TIMES;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7180/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.vdc.VdcOpHandler.java-waitForAllNodesAndReboot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:13:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+break;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:13:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+break;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:14:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+break;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:14:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+break;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:14:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
+break;
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/1233/pattern-ver1-serial/crm.src.main.java.com.ogg.crm.ui.activity.CustomerPublicListActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:14:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+break;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/1233/pattern-ver1-serial/crm.src.main.java.com.ogg.crm.ui.activity.CustomerPublicListActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:14:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=2;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:14:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=2;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:14:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos<=position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/4307/pattern-ver1-serial/core.src.com.arkanoid.stm.gameStates.ArkanoidGdx.java-block.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:14:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
+float length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/6860/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.map.impl.eviction.MaxSizeChecker.java-isEvictablePerPartition.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:14:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=3;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:14:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=3;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:14:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i-1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V21/163/pattern-ver1-serial/app.src.main.java.th.zirata.Blocks.EnemyBlocks.Hydra.java-createHydra.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:15:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i-1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V21/163/pattern-ver1-serial/app.src.main.java.th.zirata.Blocks.EnemyBlocks.Hydra.java-createHydra.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:15:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V40/2013/pattern-ver1-serial/src.main.java.mousio.client.retry.RetryWithExponentialBackOff.java-shouldRetry.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:15:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<length;i--){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V7/4666/pattern-ver1-serial/src.main.java.com.deanveloper.playtimeplus.commands.playtime.subcommand.TopSubCmd.java-execute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:15:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]!=null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/6105/pattern-ver1-serial/src.main.java.com.chord4js.ServiceId.java-ServiceId.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:15:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return position;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V69/788/pattern-ver1-serial/app.src.main.java.com.miz.mizuu.fragments.IdentifyMovieFragment.java-getItemId.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:15:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return position;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V69/788/pattern-ver1-serial/app.src.main.java.com.miz.mizuu.fragments.IdentifyMovieFragment.java-getItemId.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:15:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return Integer.MIN_VALUE;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V4/4813/pattern-ver1-serial/src.main.java.net.openhft.chronicle.wire.BinaryWire.java-code.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:15:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return Integer.MIN_VALUE;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V4/4813/pattern-ver1-serial/src.main.java.net.openhft.chronicle.wire.BinaryWire.java-code.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:15:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+position)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/174/pattern-ver1-serial/src.main.java.fr.novia.zaproxyplugin.ZAProxy.java-setUpAuthenticationMethod.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:15:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+position]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/174/pattern-ver1-serial/src.main.java.fr.novia.zaproxyplugin.ZAProxy.java-setUpAuthenticationMethod.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:16:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+length)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/174/pattern-ver1-serial/src.main.java.fr.novia.zaproxyplugin.ZAProxy.java-setUpAuthenticationMethod.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:16:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
-DateTimeParser parser=parsers[i];
+DateTimeParser parser=parsers[0];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2011/V2/4175/pattern-ver1-serial/common-gui.src.main.java.org.drugis.common.gui.FileDialog.java-wrapExtensions.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:16:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos<position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3672/pattern-ver1-serial/src.edu.miamioh.cse283.htw.Room.java-shoot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:16:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos<bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3672/pattern-ver1-serial/src.edu.miamioh.cse283.htw.Room.java-shoot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:16:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(bestValidState!=""){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V29/276/pattern-ver1-serial/src.edu.cpp.cs.cs141.final_project.User_Interface.TextUI.TextUserInterface.java-drawAlertText.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:16:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos>=position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2011/V3/848/pattern-ver1-serial/src.com.mojang.ld22.entity.Slime.java-render.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:16:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos!=position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/71/pattern-ver1-serial/src.edu.stanford.nlp.mt.decoder.feat.base.TranslationModelFeaturizer.java-ruleFeaturize.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:16:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos!=bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/71/pattern-ver1-serial/src.edu.stanford.nlp.mt.decoder.feat.base.TranslationModelFeaturizer.java-ruleFeaturize.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:16:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos!=bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/71/pattern-ver1-serial/src.edu.stanford.nlp.mt.decoder.feat.base.TranslationModelFeaturizer.java-ruleFeaturize.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:16:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos<bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V21/5482/pattern-ver1-serial/src.main.java.capstat.model.Match.java-calculateStartingPlayer.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:16:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
-DateTimeParser parser=parsers[i];
+DateTimeParser parser=parsers[1];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:17:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos!=position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V46/565/pattern-ver1-serial/src.main.java.cloudservices.brokerage.policy.policycommons.model.entities.Policy.java-isValid.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:17:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
-int bestValidPos=position;
+Integer bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7237/pattern-ver1-serial/Project.src.main.java.util.AdjacencyList.java-kruskal.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:17:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
-int bestInvalidPos=position;
+Integer bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7237/pattern-ver1-serial/Project.src.main.java.util.AdjacencyList.java-kruskal.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:17:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
+Integer length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7237/pattern-ver1-serial/Project.src.main.java.util.AdjacencyList.java-kruskal.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:17:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
-int parsePos=parser.parseInto(bucket,text,position);
+Integer parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7237/pattern-ver1-serial/Project.src.main.java.util.AdjacencyList.java-kruskal.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:17:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
+if(bestValidState!=null){
+bucket.restoreState(bestValidState);
+}
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1324/pattern-ver1-serial/cspi-schema.src.main.java.org.collectionspace.chain.csp.schema.Record.java-getServicesTenantDoctype.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:17:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(bestValidPos<=position){
+return position;
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1324/pattern-ver1-serial/cspi-schema.src.main.java.org.collectionspace.chain.csp.schema.Record.java-getServicesTenantDoctype.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:17:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
+if(bestValidPos<=position){
+return position;
+}
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1324/pattern-ver1-serial/cspi-schema.src.main.java.org.collectionspace.chain.csp.schema.Record.java-getServicesTenantDoctype.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:17:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
+}
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1324/pattern-ver1-serial/cspi-schema.src.main.java.org.collectionspace.chain.csp.schema.Record.java-getServicesTenantDoctype.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:17:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
+return 0;
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/5432/pattern-ver1-serial/app.src.main.java.com.rrdevs.peerboard.DBCompare.java-authenticateLogin.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0,localLevel;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/1178/pattern-ver1-serial/wrapper.src.main.java.com.ankit.wrapper.Logger.java-w.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
+isOptional=isOptional;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/3010/pattern-ver1-serial/rakam-spi.src.main.java.com.facebook.presto.sql.RakamSqlFormatter.java-Formatter.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return Integer.MAX_VALUE;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V20/4988/pattern-ver1-serial/hadoop-yarn-project.hadoop-yarn.hadoop-yarn-common.src.main.java.org.apache.hadoop.yarn.util.resource.Resources.java-getMemory.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return Integer.MAX_VALUE;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V20/4988/pattern-ver1-serial/hadoop-yarn-project.hadoop-yarn.hadoop-yarn-common.src.main.java.org.apache.hadoop.yarn.util.resource.Resources.java-getMemory.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos==bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V38/6762/pattern-ver1-serial/metastore.src.java.org.apache.hadoop.hive.metastore.hbase.HBaseFilterPlanUtil.java-compare.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=10;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=10;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
-DateTimeParser parser=parsers[i];
+DateTimeParser parser=parsers[2];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
-return position;
+return 0;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V7/1567/pattern-ver1-serial/src.com.personlife.view.fragment.HomeFragment.java-getItemId.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos>position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/5819/pattern-ver1-serial/FlawlessEssenceMiner.java-active.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.ArrayList;
+
+import com.sun.javafx.scene.control.behavior.KeyBinding;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<length;i++,new ArrayList<KeyBinding>()){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/314/pattern-ver1-serial/src.main.java.jfxtras.labs.internal.scene.control.behavior.SixteenSegmentBehavior.java-SixteenSegmentBehavior.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:18:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=100;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:19:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=100;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:19:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>3||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5511/pattern-ver1-serial/core.src.com.trumandeyoung.sprouts.GameRenderer.java-render.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:19:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>3){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5511/pattern-ver1-serial/core.src.com.trumandeyoung.sprouts.GameRenderer.java-render.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:19:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos>3){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5511/pattern-ver1-serial/core.src.com.trumandeyoung.sprouts.GameRenderer.java-render.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:19:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos>=0.0){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/3703/pattern-ver1-serial/Muehle_Master.src.de.dhbw.muehle.model.theme.Sound.java-fade.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:19:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=0.0||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/3703/pattern-ver1-serial/Muehle_Master.src.de.dhbw.muehle.model.theme.Sound.java-fade.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:19:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)<=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/4156/pattern-ver1-serial/src.eduapp.level.quest.GroupingQuest.java-setResult.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:19:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos<=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/4156/pattern-ver1-serial/src.eduapp.level.quest.GroupingQuest.java-setResult.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:19:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos<=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/4156/pattern-ver1-serial/src.eduapp.level.quest.GroupingQuest.java-setResult.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:19:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+return parsePos;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/6317/pattern-ver1-serial/yamj3-filescanner.src.main.java.org.yamj.filescanner.model.Statistics.java-getTime.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:20:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos>=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6682/pattern-ver1-serial/src.Geometry.Graham_Scan.java-leftTurn.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:20:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos<=bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V18/4868/pattern-ver1-serial/src.main.java.com.offbynull.portmapper.pcp.messages.PcpResponse.java-dump.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:20:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
-return position;
+return bestInvalidPos;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/6187/pattern-ver1-serial/device-manager.core.src.main.java.org.dc.bco.manager.device.core.AbstractDeviceFactory.java-newInstance.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:20:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return bestInvalidPos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/6187/pattern-ver1-serial/device-manager.core.src.main.java.org.dc.bco.manager.device.core.AbstractDeviceFactory.java-newInstance.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:20:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return bestInvalidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/6187/pattern-ver1-serial/device-manager.core.src.main.java.org.dc.bco.manager.device.core.AbstractDeviceFactory.java-newInstance.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:20:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return length;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2011/V1/6794/pattern-ver1-serial/java.src.main.java.net.auxesia.Population.java-getPopulation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:20:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return length;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2011/V1/6794/pattern-ver1-serial/java.src.main.java.net.auxesia.Population.java-getPopulation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:20:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<length;bestInvalidPos++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4470/pattern-ver1-serial/core.src.com.esbjon.inventories.Inventory.java-commandTransferTo.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:22:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<length;bestValidPos++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4470/pattern-ver1-serial/core.src.com.esbjon.inventories.Inventory.java-commandTransferTo.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:24:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<length;length++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4470/pattern-ver1-serial/core.src.com.esbjon.inventories.Inventory.java-commandTransferTo.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:25:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestInvalidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/4897/pattern-ver1-serial/src.main.java.de.axxepta.oxygen.utils.WorkspaceUtils.java-newResourceOrOverwrite.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:25:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position!=(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V26/4543/pattern-ver1-serial/launcher.src.main.java.com.benny.openlauncher.widget.GridAppDrawer.java-readyForDrag.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:25:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos==position!=isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V26/4543/pattern-ver1-serial/launcher.src.main.java.com.benny.openlauncher.widget.GridAppDrawer.java-readyForDrag.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:25:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
+}
 }
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V4/2067/pattern-ver1-serial/src.io.openems.impl.controller.debuglog.Ess.java-Ess.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:25:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=position;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V29/7874/pattern-ver1-serial/jmetal-algorithm.src.main.java.org.uma.jmetal.algorithm.singleobjective.particleswarmoptimization.StandardPSO2007.java-StandardPSO2007.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:25:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=position;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V29/7874/pattern-ver1-serial/jmetal-algorithm.src.main.java.org.uma.jmetal.algorithm.singleobjective.particleswarmoptimization.StandardPSO2007.java-StandardPSO2007.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:25:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=length;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V29/7874/pattern-ver1-serial/jmetal-algorithm.src.main.java.org.uma.jmetal.algorithm.singleobjective.particleswarmoptimization.StandardPSO2007.java-StandardPSO2007.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:26:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=bestValidPos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V29/7874/pattern-ver1-serial/jmetal-algorithm.src.main.java.org.uma.jmetal.algorithm.singleobjective.particleswarmoptimization.StandardPSO2007.java-StandardPSO2007.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:26:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=bucket.toString();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V31/7441/pattern-ver1-serial/HelloWorld.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:26:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
- final Object originalState=bucket.saveState();
+ final Object originalState=bucket.toString();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V31/7441/pattern-ver1-serial/HelloWorld.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:26:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0,_afterComposeMethodCache;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V6/5922/pattern-ver1-serial/zkbind.src.org.zkoss.bind.BindComposer.java-doAfterCompose.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:26:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(text!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:26:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(bucket!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:26:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(parsers!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:26:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(originalState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/5499/pattern-ver1-serial/src.dao.PublicationDAO.java-listComents.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:26:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+3)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4478/pattern-ver1-serial/src.holdem.HoldemGame.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:26:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+3]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4478/pattern-ver1-serial/src.holdem.HoldemGame.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:27:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return i;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V11/2382/pattern-ver1-serial/src.freenet.node.updater.MainJarDependenciesChecker.java-compareTo.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:27:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+i++;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6189/pattern-ver1-serial/src.Connection.java-discoverIP.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:27:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+i++;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6189/pattern-ver1-serial/src.Connection.java-discoverIP.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:27:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+i++;
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6189/pattern-ver1-serial/src.Connection.java-discoverIP.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:27:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.List;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0,mActions;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/428/pattern-ver1-serial/quickaction.src.main.java.com.imallan.quickaction.QuickActionOnTouchListener.java-onDown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:27:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=i;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V33/6978/pattern-ver1-serial/UnionByRankPathCompression.java-union.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:27:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=bestInvalidPos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V33/6978/pattern-ver1-serial/UnionByRankPathCompression.java-union.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:27:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return 100;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V33/5846/pattern-ver1-serial/src.com.yy2039.answermachine.MessagesView.java-getKeybackIsCancel.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:27:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return 100;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V33/5846/pattern-ver1-serial/src.com.yy2039.answermachine.MessagesView.java-getKeybackIsCancel.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:27:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
-boolean isOptional=false;
+Boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/934/pattern-ver1-serial/mifosng-provider.src.main.java.org.mifosplatform.accounting.journalentry.serialization.JournalEntryCommandFromApiJsonDeserializer.java-commandFromApiJson.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:27:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos==position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/870/pattern-ver1-serial/src.com.orange.game.zjh.statemachine.ZjhGameStateMachineBuilder.java-decideNextState.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:28:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<length;i++,new ArrayList<>()){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V43/1043/pattern-ver1-serial/src.main.java.application.controllers.MainController.java-switchScene.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:28:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+bestInvalidPos)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/4130/pattern-ver1-serial/view.ProgramLoop.java-createNewUser.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:28:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+parsePos)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/4130/pattern-ver1-serial/view.ProgramLoop.java-createNewUser.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:28:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+bestValidPos)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/4130/pattern-ver1-serial/view.ProgramLoop.java-createNewUser.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:28:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+i)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/4130/pattern-ver1-serial/view.ProgramLoop.java-createNewUser.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:28:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0,mRelationId;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V16/910/pattern-ver1-serial/app.src.main.java.fr.sims.coachingproject.ui.fragment.RelationChatFragment.java-bindView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:28:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
+bucket.restoreState(originalState);
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7257/pattern-ver1-serial/src.gamemodel.SpecialWall.java-handleProjectileArrive.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:28:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return -1;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V9/2385/pattern-ver1-serial/dionysos.src.gr.teilar.dionysos.Dionysos.java-checkHtml.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:28:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return -1;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V9/2385/pattern-ver1-serial/dionysos.src.gr.teilar.dionysos.Dionysos.java-checkHtml.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:28:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=this;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/3216/pattern-ver1-serial/instagram_integration.app.src.main.java.com.hha.instagram_integration.Photo.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:28:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
-DateTimeParser[] parsers=iParsers;
+ final DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
-DateTimeParser parser=parsers[i];
+ final DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:29:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
-DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
+ final DateTimeParser[] parsers=iParsers;
+ final int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:29:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=1;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:29:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=-1;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:29:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=-1;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:29:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=-1;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:29:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
- final Object originalState=bucket.saveState();
+ int length=parsers.length;
+ Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:29:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
-DateTimeParser[] parsers=iParsers;
+ DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
- final Object originalState=bucket.saveState();
+ Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:29:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
+ int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
-int parsePos=parser.parseInto(bucket,text,position);
+ int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:29:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
- final Object originalState=bucket.saveState();
+ Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
-Object bestValidState=null;
+ Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:29:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
- final Object originalState=bucket.saveState();
+ Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
-DateTimeParser parser=parsers[i];
+ DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:29:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
- final Object originalState=bucket.saveState();
-boolean isOptional=false;
+ Object originalState=bucket.saveState();
+ boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:30:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
- final Object originalState=bucket.saveState();
+ Object originalState=bucket.saveState();
 boolean isOptional=false;
-int bestValidPos=position;
+ int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:30:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
- final Object originalState=bucket.saveState();
+ Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
-int bestInvalidPos=position;
+ int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:30:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
-DateTimeParser[] parsers=iParsers;
+ DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
-int parsePos=parser.parseInto(bucket,text,position);
+ int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:30:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
-boolean isOptional=false;
+ boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
-int parsePos=parser.parseInto(bucket,text,position);
+ int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:30:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=0;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V64/1097/pattern-ver1-serial/plugins.de.ovgu.featureide.core.mpl.src.de.ovgu.featureide.core.mpl.signature.javadoc.AJavaDocCommentMerger.java-parseTags.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:30:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=2;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:30:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=3;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:30:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.Iterator;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos==-1&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V12/7863/pattern-ver1-serial/src.main.java.util.ListTools.java-call.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:30:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
+bestValidPos++;
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:30:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
+position++;
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:31:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+bestInvalidPos++;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:31:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+position++;
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:31:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
+bestValidPos++;
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:31:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
+position++;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:31:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+bestInvalidPos++;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:31:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+bestValidPos++;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:31:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+bestInvalidPos++;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/6147/pattern-ver1-serial/src.system.ResultPathCompare.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:31:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+bestValidPos++;
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/6147/pattern-ver1-serial/src.system.ResultPathCompare.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:31:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+bestInvalidPos++;
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/6147/pattern-ver1-serial/src.system.ResultPathCompare.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:32:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+length++;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/6147/pattern-ver1-serial/src.system.ResultPathCompare.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:32:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+bestInvalidPos--;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:32:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
+bestValidPos--;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:32:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+bestValidPos--;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:32:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+length--;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:32:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+parsePos--;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:32:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<=length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<=0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V9/4679/pattern-ver1-serial/src.course.Grass.java-render.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:32:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+bestValidPos++;
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V68/5574/pattern-ver1-serial/no.ntnu.item.semesterassignment.src.no.ntnu.item.semesterassignment.taxidispatcher.TaxiDispatcher.java-getRequestQueuePosition.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:32:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+bestInvalidPos++;
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V68/5574/pattern-ver1-serial/no.ntnu.item.semesterassignment.src.no.ntnu.item.semesterassignment.taxidispatcher.TaxiDispatcher.java-getRequestQueuePosition.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:32:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
+bestValidPos++;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V68/5574/pattern-ver1-serial/no.ntnu.item.semesterassignment.src.no.ntnu.item.semesterassignment.taxidispatcher.TaxiDispatcher.java-getRequestQueuePosition.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:33:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
-return ~bestInvalidPos;
+return 0;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/5321/pattern-ver1-serial/app.src.main.java.edu.gatech.johndoe.carecoordinator.community.UI.CommunityAdapter.java-compare.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:33:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=true;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6486/pattern-ver1-serial/src.noughtsandcrosses.VictoryConditions.java-gameWon.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:33:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+synchronized(this){
 bestValidPos=parsePos;
+}
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V20/1267/pattern-ver1-serial/src.main.java.io.vertx.ext.shell.command.impl.ProcessImpl.java-endHandler.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:33:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=10;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:33:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
-return ~bestInvalidPos;
+return bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V12/1827/pattern-ver1-serial/src.main.java.com.env.activity.ActivityTaskList.java-getItemId.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:33:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+return 0;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+return 0;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/4557/pattern-ver1-serial/src.de.rincewind.api.gui.elements.ElementCounter.java-setCount.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:33:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+return 0;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+return 0;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/4557/pattern-ver1-serial/src.de.rincewind.api.gui.elements.ElementCounter.java-setCount.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:33:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+return 0;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+return 0;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/4557/pattern-ver1-serial/src.de.rincewind.api.gui.elements.ElementCounter.java-setCount.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:33:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=100;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:33:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=0.0||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/3703/pattern-ver1-serial/Muehle_Master.src.de.dhbw.muehle.model.theme.Sound.java-fade.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:33:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos!=0&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/5558/pattern-ver1-serial/app.src.main.java.in.attreya.dailylist.MainActivity.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:34:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
+synchronized(this){
 isOptional=true;
+}
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V27/3450/pattern-ver1-serial/hbase-server.src.main.java.org.apache.hadoop.hbase.security.visibility.VisibilityController.java-postOpen.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:34:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+synchronized(this){
 bestValidState=bucket.saveState();
+}
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V27/3450/pattern-ver1-serial/hbase-server.src.main.java.org.apache.hadoop.hbase.security.visibility.VisibilityController.java-postOpen.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:34:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+synchronized(bucket){
 bucket.restoreState(bestValidState);
+}
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V17/90/pattern-ver1-serial/PolibudaRun.src.HorizontalMove.java-down.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:34:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+synchronized(bucket){
 bucket.restoreState(originalState);
+}
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V17/90/pattern-ver1-serial/PolibudaRun.src.HorizontalMove.java-down.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:34:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()&&(i+1)>=length&&parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V16/4407/pattern-ver1-serial/app.src.main.java.com.coderockets.referandumproject.util.adapter.MyFavoritesAdapter.java-bind.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:34:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>=bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>=position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V41/6622/pattern-ver1-serial/src.cpsc599.assets.Level.java-collide.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:34:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState="";
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6756/pattern-ver1-serial/src.main.java.org.silvertunnel_ng.netlib.adapter.url.impl.net.http.MessageHeader.java-mergeHeader.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:34:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=0.0;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/4063/pattern-ver1-serial/playgrounds.agarwalamit.src.main.java.playground.agarwalamit.mixedTraffic.plots.LinkPersonInfoContainer.java-updateAvailableLinkSpace.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:34:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=null;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/2637/pattern-ver1-serial/de.bund.bfr.knime.openkrise.views.src.de.bund.bfr.knime.openkrise.views.gisgraphview.GraphSettings.java-GraphSettings.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:34:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
-return ~bestInvalidPos;
+return bestValidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/6187/pattern-ver1-serial/device-manager.core.src.main.java.org.dc.bco.manager.device.core.AbstractDeviceFactory.java-newInstance.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:35:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
-return position;
+return bestValidPos;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V7/4438/pattern-ver1-serial/core.src.in.srain.cube.image.ImageLoadRequest.java-getRequestHeight.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:35:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return bestValidPos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V7/4438/pattern-ver1-serial/core.src.in.srain.cube.image.ImageLoadRequest.java-getRequestHeight.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:35:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
-return ~bestInvalidPos;
+return 1;
 }

PATTERN : /home/jiajun/GithubData/2011/V4/7202/pattern-ver1-serial/client.SurvivalGuide.src.ch.ethz.inf.vs.android.g54.a4.ui.TouchImageView.java-getPointerCount.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:35:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+bestInvalidPos++;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2119/pattern-ver1-serial/src.field.initial.FieldConstructor.java-execute.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:35:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
+length++;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2119/pattern-ver1-serial/src.field.initial.FieldConstructor.java-execute.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:35:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+parsePos=position;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/697/pattern-ver1-serial/umldiag.java-setLineArrow.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:35:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+parsePos=position;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/697/pattern-ver1-serial/umldiag.java-setLineArrow.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:35:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+parsePos=length;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/697/pattern-ver1-serial/umldiag.java-setLineArrow.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:35:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+parsePos=bestValidPos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/697/pattern-ver1-serial/umldiag.java-setLineArrow.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:35:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+-1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4243/pattern-ver1-serial/app.src.main.java.com.ryanwedoff.senor.naoservercontroller.WalkFragment.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:36:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+-1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4243/pattern-ver1-serial/app.src.main.java.com.ryanwedoff.senor.naoservercontroller.WalkFragment.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:36:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=false;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2195/pattern-ver1-serial/src.main.java.ian.hu.webapp.session.FileSessionRepository.java-setStorageDirectory.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:36:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+synchronized(this){
 bucket.restoreState(originalState);
+}
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/6621/pattern-ver1-serial/src.com.qozix.tileview.tiles.TileCache.java-addBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:36:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0,continentName,countryCode;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V9/6266/pattern-ver1-serial/app.src.main.java.com.hyperion.dashdroid.radio.RadioListFragment.java-refresh.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:36:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
-return ~bestInvalidPos;
+return (int)(~bestInvalidPos);
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/1621/pattern-ver1-serial/src.lab4.FileService.FileService.java-readFile.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:36:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return (int)(bestValidPos);
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/1621/pattern-ver1-serial/src.lab4.FileService.FileService.java-readFile.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:36:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return (int)(parsePos);
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/1621/pattern-ver1-serial/src.lab4.FileService.FileService.java-readFile.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:36:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(position>bestValidPos||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V32/3724/pattern-ver1-serial/Fanorona.java-isPossibleCapturingMove.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:36:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(position==bestValidPos&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V32/3724/pattern-ver1-serial/Fanorona.java-isPossibleCapturingMove.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:36:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(position<=bestValidPos){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V32/3724/pattern-ver1-serial/Fanorona.java-isPossibleCapturingMove.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:37:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(position>=parsePos){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V32/3724/pattern-ver1-serial/Fanorona.java-isPossibleCapturingMove.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:37:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(bestInvalidPos>parsePos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V32/3724/pattern-ver1-serial/Fanorona.java-isPossibleCapturingMove.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:37:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=1;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=1;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3191/pattern-ver1-serial/core.src.incanshift.IncanShift.java-create.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:37:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos<0&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/6790/pattern-ver1-serial/Minigames.src.au.com.mineauz.minigames.menu.MenuItemList.java-updateDescription.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:37:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+return 0;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+return 0;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V46/144/pattern-ver1-serial/lettuce.src.main.java.com.lambdaworks.redis.Connections.java-close.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:37:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+while(true){
+
+}
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:39:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+while(true){
+
+}
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:41:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
+while(true){
+
+}
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:43:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+}
+while(true){
+
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:45:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
+while(true){
+
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:47:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
+while(true){
+
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:49:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=text;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1577/pattern-ver1-serial/src.main.java.models.RenameFiles.java-replaceWeirdChar.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:49:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=position;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1577/pattern-ver1-serial/src.main.java.models.RenameFiles.java-replaceWeirdChar.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:49:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=parsers;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1577/pattern-ver1-serial/src.main.java.models.RenameFiles.java-replaceWeirdChar.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:49:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=length;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1577/pattern-ver1-serial/src.main.java.models.RenameFiles.java-replaceWeirdChar.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:49:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=originalState;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1577/pattern-ver1-serial/src.main.java.models.RenameFiles.java-replaceWeirdChar.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:50:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=isOptional;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1577/pattern-ver1-serial/src.main.java.models.RenameFiles.java-replaceWeirdChar.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:50:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=bestValidPos;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1577/pattern-ver1-serial/src.main.java.models.RenameFiles.java-replaceWeirdChar.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:50:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=bestValidState;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1577/pattern-ver1-serial/src.main.java.models.RenameFiles.java-replaceWeirdChar.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:50:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
+bestValidState=bestInvalidPos;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1577/pattern-ver1-serial/src.main.java.models.RenameFiles.java-replaceWeirdChar.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:50:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>=bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<=0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V21/1893/pattern-ver1-serial/com.eclipsesource.tabris.src.com.eclipsesource.tabris.internal.SwipeManager.java-isValidMove.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:50:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos>position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V39/2599/pattern-ver1-serial/Schedule.src.model.Task.java-isInPeriod.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:50:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V39/2599/pattern-ver1-serial/Schedule.src.model.Task.java-isInPeriod.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:50:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos>0&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V23/2696/pattern-ver1-serial/src.main.java.br.com.provaServer.infrastructure.deserialization.gson.GsonDeserialization.java-isWithoutRoot.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:50:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+i--;
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/2847/pattern-ver1-serial/core.src.com.mygdx.game.GameScreen.java-updateBossBullet.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:50:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+i--;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/2847/pattern-ver1-serial/core.src.com.mygdx.game.GameScreen.java-updateBossBullet.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:52:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+i--;
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/2847/pattern-ver1-serial/core.src.com.mygdx.game.GameScreen.java-updateBossBullet.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:54:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+synchronized(this){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+}
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+synchronized(this){
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
+}
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+synchronized(this){
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.nio.charset.Charset;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<length;i++,Charset.forName("UTF-8")){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/3733/pattern-ver1-serial/Code.Part1.src.core.Intraprocedural.java-callgraph.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if(bucket!=null){
 bucket.restoreState(bestValidState);
+}
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6555/pattern-ver1-serial/app.src.main.java.com.example.uaharoni.tourdeplace.view.MapFragment.java-addPlaceMarker.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+if(bucket!=null){
 bucket.restoreState(originalState);
+}
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/6555/pattern-ver1-serial/app.src.main.java.com.example.uaharoni.tourdeplace.view.MapFragment.java-addPlaceMarker.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if(bucket!=bestValidState){
 bucket.restoreState(bestValidState);
+}
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/7075/pattern-ver1-serial/app.src.main.java.com.gustavoparreira.realtimetile.Player.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidState!=null){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+}
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/262/pattern-ver1-serial/src.internal.tree.WorldTree.java-getAllChildren.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+bestValidState=new ArrayList<>();
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/486/pattern-ver1-serial/app.src.main.java.com.rubengees.vocables.pojo.Unit.java-readFromParcel.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+bestValidState=new ArrayList<>();
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/486/pattern-ver1-serial/app.src.main.java.com.rubengees.vocables.pojo.Unit.java-readFromParcel.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+bestValidState=this;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/4878/pattern-ver1-serial/app.src.main.java.com.trukr.shipper.activity.Notification.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+bestValidState=this;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/4878/pattern-ver1-serial/app.src.main.java.com.trukr.shipper.activity.Notification.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:55:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(bestValidState.equals(null)){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/343/pattern-ver1-serial/src.gui.batches.ItemBatchView.java-selectProduct.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:56:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
-if(parser==null){
+if(parser.equals(null)){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/343/pattern-ver1-serial/src.gui.batches.ItemBatchView.java-selectProduct.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:56:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+synchronized(this){
 bucket.restoreState(bestValidState);
+}
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:56:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+synchronized(this){
 return parsePos;
+}
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:56:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
+synchronized(this){
 return position;
+}
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:56:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
+synchronized(this){
 bestInvalidPos=parsePos;
+}
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:56:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||i+1*100>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V17/1028/pattern-ver1-serial/coordinatorsvc.src.main.java.com.emc.storageos.coordinator.client.model.DbConsistencyStatus.java-updateCFProgress.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:56:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
-DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
- final Object originalState=bucket.saveState();
+ @SuppressWarnings("UnusedAssignment") DateTimeParser[] parsers=iParsers;
+ @SuppressWarnings("UnusedAssignment") int length=parsers.length;
+ @SuppressWarnings("UnusedAssignment") Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:56:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
- final Object originalState=bucket.saveState();
+ @SuppressWarnings("UnusedAssignment") int length=parsers.length;
+ @SuppressWarnings("UnusedAssignment") Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
-Object bestValidState=null;
+ @SuppressWarnings("UnusedAssignment") Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:56:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
- final Object originalState=bucket.saveState();
+ @SuppressWarnings("UnusedAssignment") int length=parsers.length;
+ @SuppressWarnings("UnusedAssignment") Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
-DateTimeParser parser=parsers[i];
+ @SuppressWarnings("UnusedAssignment") DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:57:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
- final Object originalState=bucket.saveState();
-boolean isOptional=false;
+ @SuppressWarnings("UnusedAssignment") int length=parsers.length;
+ @SuppressWarnings("UnusedAssignment") Object originalState=bucket.saveState();
+ @SuppressWarnings("UnusedAssignment") boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:57:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
- final Object originalState=bucket.saveState();
+ @SuppressWarnings("UnusedAssignment") int length=parsers.length;
+ @SuppressWarnings("UnusedAssignment") Object originalState=bucket.saveState();
 boolean isOptional=false;
-int bestValidPos=position;
+ @SuppressWarnings("UnusedAssignment") int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:57:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
-int length=parsers.length;
- final Object originalState=bucket.saveState();
+ @SuppressWarnings("UnusedAssignment") int length=parsers.length;
+ @SuppressWarnings("UnusedAssignment") Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
-int bestInvalidPos=position;
+ @SuppressWarnings("UnusedAssignment") int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:57:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
-DateTimeParser[] parsers=iParsers;
+ @SuppressWarnings("UnusedAssignment") DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
- final Object originalState=bucket.saveState();
+ @SuppressWarnings("UnusedAssignment") Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
-Object bestValidState=null;
+ @SuppressWarnings("UnusedAssignment") Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:57:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+bestValidState=text;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:57:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+bucket=bucket;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:57:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+bestValidState=bucket;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:57:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+bestValidState=position;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:57:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
+position=position;
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V31/432/pattern-ver1-serial/src.arcane_arcade_menus.MainMenuMenuCreator.java-MainMenuElement.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:57:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos+position==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3750/pattern-ver1-serial/src.main.java.de.tudarmstadt.awesome.erclaerung.precomputation.LevenshteinStep.java-getAdjustedString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:58:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos+length==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3750/pattern-ver1-serial/src.main.java.de.tudarmstadt.awesome.erclaerung.precomputation.LevenshteinStep.java-getAdjustedString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:58:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos+bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3750/pattern-ver1-serial/src.main.java.de.tudarmstadt.awesome.erclaerung.precomputation.LevenshteinStep.java-getAdjustedString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:58:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos+bestInvalidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3750/pattern-ver1-serial/src.main.java.de.tudarmstadt.awesome.erclaerung.precomputation.LevenshteinStep.java-getAdjustedString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:58:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[0]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2011/V2/4175/pattern-ver1-serial/common-gui.src.main.java.org.drugis.common.gui.FileDialog.java-wrapExtensions.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:58:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(i==4){
+continue;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/5508/pattern-ver1-serial/common.enhancedportals.item.ItemPortalModifierUpgrade.java-getSubItems.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:58:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(i==4){
+continue;
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/5508/pattern-ver1-serial/common.enhancedportals.item.ItemPortalModifierUpgrade.java-getSubItems.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:58:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(i==4){
+continue;
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/5508/pattern-ver1-serial/common.enhancedportals.item.ItemPortalModifierUpgrade.java-getSubItems.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:58:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
-return ~bestInvalidPos;
+return ~bestInvalidPos&0xff;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/5603/pattern-ver1-serial/uk.ac.herts.SmartLab.XBee.Response.XBeeRx64Response.java-GetReceiveStatus.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:58:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return bestValidPos&0xff;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/5603/pattern-ver1-serial/uk.ac.herts.SmartLab.XBee.Response.XBeeRx64Response.java-GetReceiveStatus.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:58:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return parsePos&0xff;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/5603/pattern-ver1-serial/uk.ac.herts.SmartLab.XBee.Response.XBeeRx64Response.java-GetReceiveStatus.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:59:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:59:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+parsePos=1000;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V4/3726/pattern-ver1-serial/WeatherService.src.weatherservice.StatisticsCalculator.java-MinWindSpeed.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:59:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+parsePos=1000;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V4/3726/pattern-ver1-serial/WeatherService.src.weatherservice.StatisticsCalculator.java-MinWindSpeed.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:59:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+parsePos=1000;
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V4/3726/pattern-ver1-serial/WeatherService.src.weatherservice.StatisticsCalculator.java-MinWindSpeed.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:59:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(true){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:59:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
-if(parser==null){
+if(true){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:59:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(true){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:59:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(true){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:59:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(true){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 07:59:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(true){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:00:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(true){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:00:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V40/625/pattern-ver1-serial/src.controllers.multiPlayer.sampleMCTS.SingleTreeNode.java-rollOut.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:00:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+if(bestValidState==null){
 bestValidState=bucket.saveState();
+}
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V53/4035/pattern-ver1-serial/whois-client.src.main.java.net.ripe.db.whois.common.rpsl.RpslAttribute.java-extractCleanValueAndComment.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:00:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.Arrays;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
+Arrays.sort(parsers);
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/405/pattern-ver1-serial/twitter-topic-strand-core.src.main.java.twittertopicstrand.util.FileOperations.java-getFiles.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:00:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[2]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:00:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+int a=0;
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:00:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+int a=0;
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:00:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+int a=0;
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:00:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+int a=0;
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:00:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
+int a=0;
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:01:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+int a=0;
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:01:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
+int a=0;
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:01:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
+int a=0;
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:01:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+int a=0;
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:01:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+int a=0;
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:01:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
+bestValidState=false;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/271/pattern-ver1-serial/src.datamining.clustering.protoype.altopt.PolynomFCMNoiseClusteringAlgorithm.java-classifyNoise.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:01:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+isOptional=true;
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
+isOptional=false;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:01:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
+isOptional=false;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+isOptional=true;
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:01:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
+isOptional=false;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+isOptional=true;
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:01:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
+isOptional=false;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+isOptional=true;
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:02:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
+isOptional=false;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+isOptional=true;
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:02:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
+isOptional=true;
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
+isOptional=false;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:02:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
+isOptional=false;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+isOptional=true;
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:02:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
+isOptional=false;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+isOptional=true;
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:02:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
+isOptional=false;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+isOptional=true;
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:02:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(parsePos==0.0){
+continue;
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4118/pattern-ver1-serial/src.behavior.irl.TabularIRL.java-getBehaviorLogProbabilityHelper.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:02:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+if(parsePos==0.0){
+continue;
+}
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4118/pattern-ver1-serial/src.behavior.irl.TabularIRL.java-getBehaviorLogProbabilityHelper.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:02:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+if(parsePos==0.0){
+continue;
+}
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4118/pattern-ver1-serial/src.behavior.irl.TabularIRL.java-getBehaviorLogProbabilityHelper.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:02:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+String OUTSTRING="";
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:02:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+String OUTSTRING="";
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:03:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+String OUTSTRING="";
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:03:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
+String OUTSTRING="";
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:03:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+String OUTSTRING="";
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:03:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+String OUTSTRING="";
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:03:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+String OUTSTRING="";
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:03:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+String OUTSTRING="";
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:03:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
+String OUTSTRING="";
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:03:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+String OUTSTRING="";
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:03:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(text.isEmpty()){
+return 0;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/5856/pattern-ver1-serial/src.main.java.io.aif.associations.builder.ExperimentsConnectionsGraphReducer.java-normalize.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:03:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+if(text.isEmpty()){
+return 0;
+}
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/5856/pattern-ver1-serial/src.main.java.io.aif.associations.builder.ExperimentsConnectionsGraphReducer.java-normalize.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:04:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<length;){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+i++;
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/7304/pattern-ver1-serial/vipr-portal.com.iwave.isa.content.src.java.com.emc.sa.service.vipr.file.tasks.IngestUnmanagedFilesystems.java-ingestInChunks.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:06:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<length;){
+i++;
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/7304/pattern-ver1-serial/vipr-portal.com.iwave.isa.content.src.java.com.emc.sa.service.vipr.file.tasks.IngestUnmanagedFilesystems.java-ingestInChunks.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:06:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<length;){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+i++;
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/7304/pattern-ver1-serial/vipr-portal.com.iwave.isa.content.src.java.com.emc.sa.service.vipr.file.tasks.IngestUnmanagedFilesystems.java-ingestInChunks.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:08:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
-if(parser==null){
+if(isOptional&&(parser==null)){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:08:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(isOptional&&(bestValidState!=null)){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:08:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(isOptional&&(parsePos>bestValidPos)){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:08:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(isOptional&&(parsePos>=position)){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:08:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(isOptional&&(parsePos<0)){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:08:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(isOptional&&(bestValidPos<=position)){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:08:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(isOptional&&(parsePos>bestInvalidPos)){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:08:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(bestValidState!=null||isOptional){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:08:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<=position||isOptional){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:09:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
-if(parser==null){
+if(parser==null||isOptional){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:09:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos>bestInvalidPos||isOptional){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:09:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<0||isOptional){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:09:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos||isOptional){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:09:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos>=position||isOptional){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:09:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(Double.isNaN(bestValidPos)){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V32/1622/pattern-ver1-serial/src.mckay.utilities.staticlibraries.StringMethods.java-getDoubleInScientificNotation.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:09:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(Double.isNaN(parsePos)){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V32/1622/pattern-ver1-serial/src.mckay.utilities.staticlibraries.StringMethods.java-getDoubleInScientificNotation.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:09:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(Double.isNaN(parsePos)){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V32/1622/pattern-ver1-serial/src.mckay.utilities.staticlibraries.StringMethods.java-getDoubleInScientificNotation.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:09:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(Double.isNaN(parsePos)){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V32/1622/pattern-ver1-serial/src.mckay.utilities.staticlibraries.StringMethods.java-getDoubleInScientificNotation.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:10:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(Double.isNaN(parsePos)){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V32/1622/pattern-ver1-serial/src.mckay.utilities.staticlibraries.StringMethods.java-getDoubleInScientificNotation.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:10:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:10:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:10:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:10:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:10:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:10:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:10:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:10:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos&&isOptional){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/5215/pattern-ver1-serial/src.usask.hci.fastdraw.DrawView.java-changeSelection.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:10:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(equals(text)){
+return 0;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:11:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(equals(text)){
+return 0;
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:11:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(equals(text)){
+return 0;
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:11:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+if(equals(text)){
+return 0;
+}
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:11:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
+}
+if(equals(position)){
+return 0;
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:11:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(equals(parsePos)){
+return 0;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:11:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(equals(parsePos)){
+return 0;
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:11:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(equals(length)){
+return 0;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:11:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+int indexSelection=0;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:11:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+int indexSelection=0;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:11:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+int indexSelection=0;
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:12:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
+int indexSelection=0;
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:12:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+int indexSelection=0;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:12:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+int indexSelection=0;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:12:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+int indexSelection=0;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:12:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.Arrays;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1-1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/7420/pattern-ver1-serial/src.webradio.Show.java-convertArrToString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:12:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.Arrays;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
-DateTimeParser parser=parsers[i];
+DateTimeParser parser=parsers[i-1];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/7420/pattern-ver1-serial/src.webradio.Show.java-convertArrToString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:12:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(text.equals("sounds")){
+continue;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:12:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+if(bucket.equals("sounds")){
+continue;
+}
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/2569/pattern-ver1-serial/src.main.java.net.dirtydeeds.discordsoundboard.chat.ListCategoriesProcessor.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:12:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=bestInvalidPos+parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V18/2052/pattern-ver1-serial/cg.cg.GTSurferMove.java-drawFactor.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:13:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=bestValidPos+parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V18/2052/pattern-ver1-serial/cg.cg.GTSurferMove.java-drawFactor.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:13:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if("Chrome".equals(bestValidPos)||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V17/4219/pattern-ver1-serial/src.browsermator.com.STAppController.java-itemStateChanged.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:13:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(isOptional){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/7120/pattern-ver1-serial/app.src.main.java.com.codephillip.intmain.fitracer.MainActivity.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:13:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(isOptional){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/7120/pattern-ver1-serial/app.src.main.java.com.codephillip.intmain.fitracer.MainActivity.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:13:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+int a=1;
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:13:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+int a=1;
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:13:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
+int a=1;
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:13:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+int a=1;
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:13:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+int a=1;
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:13:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
+int a=1;
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:14:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+int a=1;
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:14:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
+int a=1;
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:14:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+int a=1;
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:14:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+int a=1;
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:14:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+boolean b=true;
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:14:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+boolean b=true;
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:14:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+boolean b=true;
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:14:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+boolean b=true;
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:14:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
+boolean b=true;
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:14:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+boolean b=true;
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:15:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
+boolean b=true;
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:15:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+boolean b=true;
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:15:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+boolean b=true;
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:15:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
+boolean b=true;
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:15:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(text.isEmpty()){
+return parsePos;
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V7/6812/pattern-ver1-serial/src.main.java.wslf.homemoviebase.logic.Worker.java-parseTags.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:15:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
 }
+if(text.isEmpty()){
+return parsePos;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V7/6812/pattern-ver1-serial/src.main.java.wslf.homemoviebase.logic.Worker.java-parseTags.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:15:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(text==null){
+continue;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:15:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(bucket==null){
+continue;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:15:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(text==null){
+continue;
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:16:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(bucket==null){
+continue;
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:16:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+if(text==null){
+continue;
+}
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:16:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+if(bucket==null){
+continue;
+}
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7058/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.manager.FileManager.java-getExternalSDCardDirectory.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:16:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return bestValidPos+position;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/5747/pattern-ver1-serial/src.main.java.MySimpleClass.java-add.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:16:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+return parsePos+position;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/5747/pattern-ver1-serial/src.main.java.MySimpleClass.java-add.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:16:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return bestValidPos+length;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/5747/pattern-ver1-serial/src.main.java.MySimpleClass.java-add.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:16:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
-for(int i=0;i<length;i++){
+for(int i=0;i<length;Math.abs(i++)){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/6264/pattern-ver1-serial/src.main.java.com.metal.fetcher.fetcher.impl.WeiboFetcher.java-getRandomAccount.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:16:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
+if(originalState==null){
+return 0;
+}
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/grib.src.main.java.ucar.nc2.grib.grib1.tables.NcepHtmlScraper.java-parseTable2.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:16:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
+if(parsers==null){
+return 0;
+}
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/grib.src.main.java.ucar.nc2.grib.grib1.tables.NcepHtmlScraper.java-parseTable2.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:16:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
+if(bestValidState==null){
+return 0;
+}
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/grib.src.main.java.ucar.nc2.grib.grib1.tables.NcepHtmlScraper.java-parseTable2.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:17:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if(bucket==null){
+return 0;
+}
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:17:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bucket==null){
+return 0;
+}
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:17:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+if(bucket==null){
+return 0;
+}
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:17:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
+}
+if(bucket==null){
+return 0;
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:17:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(bucket==null){
+return 0;
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:17:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(text==null){
+return 0;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:17:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(bucket==null){
+return 0;
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:17:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
+if(bestValidState==null){
+return length;
+}
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:17:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
+if(bestValidState==null){
+return bestValidPos;
+}
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:17:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+if(bestValidState==null){
+return bestInvalidPos;
+}
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:18:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if(bestValidState==null){
+return 0;
+}
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/886/pattern-ver1-serial/src.com.inovex.zabbixmobile.activities.BaseSeverityFilterActivity.java-onSeveritySelected.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:18:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidState==null){
+return 0;
+}
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/886/pattern-ver1-serial/src.com.inovex.zabbixmobile.activities.BaseSeverityFilterActivity.java-onSeveritySelected.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:18:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if("index".equals(bucket)){
+return 0;
+}
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:18:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if("index".equals(text)){
+return 0;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:18:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if("index".equals(bucket)){
+return 0;
+}
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:18:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if("index".equals(text)){
+return 0;
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:18:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if("index".equals(bucket)){
+return 0;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:18:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if("index".equals(bucket)){
+return 0;
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:18:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
+if("index".equals(position)){
+return 0;
+}
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:19:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
+if("index".equals(position)){
+return 0;
+}
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:19:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if("index".equals(bestValidState)){
+return 0;
+}
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:19:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if("index".equals(bestValidPos)){
+return 0;
+}
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:19:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+bucket.restoreState(originalState);
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:19:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+bucket.restoreState(bestValidState);
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:19:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+bucket.restoreState(originalState);
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:19:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+bucket.restoreState(originalState);
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:19:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
+bucket.restoreState(originalState);
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:19:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+bucket.restoreState(originalState);
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:19:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
+bucket.restoreState(originalState);
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:20:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+bucket.restoreState(originalState);
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:20:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+bucket.restoreState(originalState);
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:20:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+bucket.restoreState(bestValidState);
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:20:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+bucket.restoreState(bestValidState);
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:20:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+bucket.restoreState(bestValidState);
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:20:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+bucket.restoreState(bestValidState);
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:20:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
+bucket.restoreState(bestValidState);
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:20:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
+bucket.restoreState(bestValidState);
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:20:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+bucket.restoreState(bestValidState);
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:20:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+bucket.restoreState(bestValidState);
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:21:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
+bucket.restoreState(bestValidState);
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:21:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
+bucket.restoreState(bestValidState);
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:21:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+bucket.restoreState(bestValidState);
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:21:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+bucket.restoreState(bestValidState);
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:21:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+bucket.restoreState(bestValidState);
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:21:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+bucket.restoreState(bestValidState);
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:21:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+bucket.restoreState(bestValidState);
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:21:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+bucket.restoreState(originalState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:21:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
+bucket.restoreState(bestValidState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:21:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+bucket.restoreState(bestValidState);
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:22:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+bucket.restoreState(originalState);
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:22:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+bucket.restoreState(originalState);
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:22:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+isOptional=true;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:22:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
+bestInvalidPos=parsePos;
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:22:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+bucket.restoreState(bestValidState);
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/5726/pattern-ver1-serial/library.src.main.java.com.cocosw.bottomsheet.ClosableSlidingLayout.java-onViewReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:22:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
+bucket.restoreState(bestValidState);
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2665/pattern-ver1-serial/channel.src.main.java.com.github.dm.jrt.channel.ReplayChannel.java-onError.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:22:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
+bucket.restoreState(bestValidState);
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2665/pattern-ver1-serial/channel.src.main.java.com.github.dm.jrt.channel.ReplayChannel.java-onError.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:22:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
+bucket.restoreState(originalState);
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2665/pattern-ver1-serial/channel.src.main.java.com.github.dm.jrt.channel.ReplayChannel.java-onError.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:22:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+bestValidPos=parsePos;
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:22:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+bestValidPos=parsePos;
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:23:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
+bestValidPos=parsePos;
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:23:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+bestValidPos=parsePos;
 return parsePos;
 }
-bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:23:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+bestValidPos=parsePos;
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:23:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+if(bestValidState!=null){
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/3128/pattern-ver1-serial/src.cubicmadness.gamestates.GameStateManager.java-popCurrentState.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:23:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+isOptional=true;
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V49/5647/pattern-ver1-serial/src.worms.model.statements.Print.java-executeStatement.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:23:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+bestInvalidPos=parsePos;
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V49/5647/pattern-ver1-serial/src.worms.model.statements.Print.java-executeStatement.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:23:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+bucket.restoreState(originalState);
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/2664/pattern-ver1-serial/src.main.java.micdoodle8.mods.galacticraft.planets.asteroids.entities.EntityGrapple.java-EntityGrapple.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:23:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+bucket.restoreState(originalState);
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/2664/pattern-ver1-serial/src.main.java.micdoodle8.mods.galacticraft.planets.asteroids.entities.EntityGrapple.java-EntityGrapple.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:23:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+bucket.restoreState(originalState);
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/2664/pattern-ver1-serial/src.main.java.micdoodle8.mods.galacticraft.planets.asteroids.entities.EntityGrapple.java-EntityGrapple.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:24:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
+bucket.restoreState(originalState);
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/2664/pattern-ver1-serial/src.main.java.micdoodle8.mods.galacticraft.planets.asteroids.entities.EntityGrapple.java-EntityGrapple.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:24:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+isOptional=true;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:24:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+isOptional=true;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:24:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
+isOptional=true;
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:24:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+isOptional=true;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:24:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+isOptional=true;
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1266/pattern-ver1-serial/catroid.src.org.catrobat.catroid.livewallpaper.LiveWallpaper.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:24:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+isOptional=true;
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1266/pattern-ver1-serial/catroid.src.org.catrobat.catroid.livewallpaper.LiveWallpaper.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:24:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+bestInvalidPos=parsePos;
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1266/pattern-ver1-serial/catroid.src.org.catrobat.catroid.livewallpaper.LiveWallpaper.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:24:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+bestInvalidPos=parsePos;
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1266/pattern-ver1-serial/catroid.src.org.catrobat.catroid.livewallpaper.LiveWallpaper.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:25:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if(!bestValidState.equals("")){
 bucket.restoreState(bestValidState);
+}
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/60/pattern-ver1-serial/app.src.main.java.com.holygon.dishcuss.Fragments.AccountPhotosFragment.java-SetImageURL.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:25:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
+bucket.restoreState(originalState);
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:25:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
 break;
 }
+isOptional=true;
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/2094/pattern-ver1-serial/src.main.java.com.dagobert_engine.core.service.UpdateService.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:25:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+bucket.restoreState(originalState);
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/7429/pattern-ver1-serial/library.src.main.java.com.datatorrent.lib.appdata.qr.processor.AbstractWEQueryQueueManager.java-enqueueHelper.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:25:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
+if(originalState.equals("-1")){
+return 0;
+}
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:25:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
+if(parsers.equals("-1")){
+return 0;
+}
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:25:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
+if(bestValidState.equals("-1")){
+return 0;
+}
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:25:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+bucket.restoreState(bestValidState);
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:25:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+bucket.restoreState(bestValidState);
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:25:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+bucket.restoreState(bestValidState);
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:26:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+bucket.restoreState(bestValidState);
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:26:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+bucket.restoreState(originalState);
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:26:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+bucket.restoreState(originalState);
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:26:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<=position||bestValidPos==Long.MIN_VALUE){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V5/7087/pattern-ver1-serial/BDEBase.src.main.java.gr.demokritos.iit.base.util.Utils.java-extractYearMonthDayLiteral.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:26:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos>bestInvalidPos||parsePos==Long.MIN_VALUE){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V5/7087/pattern-ver1-serial/BDEBase.src.main.java.gr.demokritos.iit.base.util.Utils.java-extractYearMonthDayLiteral.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:26:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos||parsePos==Long.MIN_VALUE){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V5/7087/pattern-ver1-serial/BDEBase.src.main.java.gr.demokritos.iit.base.util.Utils.java-extractYearMonthDayLiteral.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:26:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<0||parsePos==Long.MIN_VALUE){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V5/7087/pattern-ver1-serial/BDEBase.src.main.java.gr.demokritos.iit.base.util.Utils.java-extractYearMonthDayLiteral.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:26:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos>=position||parsePos==Long.MIN_VALUE){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V5/7087/pattern-ver1-serial/BDEBase.src.main.java.gr.demokritos.iit.base.util.Utils.java-extractYearMonthDayLiteral.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:26:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
+bucket.restoreState(originalState);
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V67/6439/pattern-ver1-serial/core.src.game.screen.battle.Battle.java-render.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:27:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+isOptional=true;
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V9/6301/pattern-ver1-serial/app.src.main.java.client.example.sj.pulltoscaleheaderlayout.PullToScaleHeaderLayout.java-computeScroll.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:27:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+bucket.restoreState(bestValidState);
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:27:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
+bucket.restoreState(bestValidState);
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:27:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+bucket.restoreState(bestValidState);
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:27:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+bucket.restoreState(originalState);
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4025/pattern-ver1-serial/AZoCamSyncDesktop.src.de.quadrillenschule.azocamsyncd.gui.SwingBackgroundUpdater.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:27:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+bucket.restoreState(originalState);
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4025/pattern-ver1-serial/AZoCamSyncDesktop.src.de.quadrillenschule.azocamsyncd.gui.SwingBackgroundUpdater.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:27:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
-}
 }
 }
 bucket.restoreState(originalState);
+}
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4025/pattern-ver1-serial/AZoCamSyncDesktop.src.de.quadrillenschule.azocamsyncd.gui.SwingBackgroundUpdater.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:27:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+isOptional=true;
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1875/pattern-ver1-serial/TherapistApp.src.application.Main.java-handle.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:27:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
+isOptional=true;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
-isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1875/pattern-ver1-serial/TherapistApp.src.application.Main.java-handle.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:28:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
+isOptional=true;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1875/pattern-ver1-serial/TherapistApp.src.application.Main.java-handle.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:28:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
 }
 }
 }
+bestInvalidPos=parsePos;
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1875/pattern-ver1-serial/TherapistApp.src.application.Main.java-handle.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:28:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
 }
 }
+bestInvalidPos=parsePos;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1875/pattern-ver1-serial/TherapistApp.src.application.Main.java-handle.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:28:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
 }
+bestInvalidPos=parsePos;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1875/pattern-ver1-serial/TherapistApp.src.application.Main.java-handle.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:28:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+bestInvalidPos=parsePos;
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1875/pattern-ver1-serial/TherapistApp.src.application.Main.java-handle.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:28:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+bucket.restoreState(originalState);
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V32/156/pattern-ver1-serial/ControlCenter.src.main.java.org.votingsystem.web.controlcenter.filter.FilterVS.java-doFilter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:28:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+bucket.restoreState(bestValidState);
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/3822/pattern-ver1-serial/app.src.main.java.com.peprally.jeremy.peprally.activities.ProfileActivity.java-SetupNewUserProfile.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:28:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+bucket.restoreState(bestValidState);
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/3822/pattern-ver1-serial/app.src.main.java.com.peprally.jeremy.peprally.activities.ProfileActivity.java-SetupNewUserProfile.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:28:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+bucket.restoreState(bestValidState);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/3822/pattern-ver1-serial/app.src.main.java.com.peprally.jeremy.peprally.activities.ProfileActivity.java-SetupNewUserProfile.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:28:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+if(parsePos>bestInvalidPos){
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V48/2335/pattern-ver1-serial/app.src.main.java.swampthings.dems.LoginActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:29:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(text==null){
+return 0;
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/4925/pattern-ver1-serial/statemachine-persistence.src.main.java.de.teck.statemachine.persistence.model.TransitionGraph.java-addTransition.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:29:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+if(bucket==null){
+return 0;
+}
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/4925/pattern-ver1-serial/statemachine-persistence.src.main.java.de.teck.statemachine.persistence.model.TransitionGraph.java-addTransition.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:29:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(text==null){
+return 0;
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/4925/pattern-ver1-serial/statemachine-persistence.src.main.java.de.teck.statemachine.persistence.model.TransitionGraph.java-addTransition.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:29:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+if(text==null){
+return 0;
+}
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/4925/pattern-ver1-serial/statemachine-persistence.src.main.java.de.teck.statemachine.persistence.model.TransitionGraph.java-addTransition.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:29:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
+if(bucket==null){
+return 0;
+}
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/4925/pattern-ver1-serial/statemachine-persistence.src.main.java.de.teck.statemachine.persistence.model.TransitionGraph.java-addTransition.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:29:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+try{
 bucket.restoreState(originalState);
+}finally{
+isOptional=true;
+}
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 1, INS : 0, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:29:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+try{
 bucket.restoreState(originalState);
+}finally{
+bestInvalidPos=parsePos;
+}
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 1, INS : 0, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:29:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+bestValidPos=parsePos;
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/1831/pattern-ver1-serial/bitrepository-audit-trail-service.src.main.java.org.bitrepository.audittrails.collector.IncrementalCollector.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:29:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+bestValidPos=parsePos;
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/1831/pattern-ver1-serial/bitrepository-audit-trail-service.src.main.java.org.bitrepository.audittrails.collector.IncrementalCollector.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:29:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+assert (text!=null);
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:30:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+assert (bucket!=null);
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:30:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+assert (text!=null);
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:30:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+assert (bucket!=null);
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:30:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+assert (bucket!=null);
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:30:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+assert (bucket!=null);
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:30:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+assert (bestValidState!=null);
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:30:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+assert (bestValidState!=null);
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:30:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+assert (!text.isEmpty());
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:30:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+assert (!text.isEmpty());
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:30:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(text.contains(text)){
+return 0;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V43/6402/pattern-ver1-serial/src.edu.calpoly.android.imfree.DataStore.java-trueAddParseFriend.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:31:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+bestValidPos=parsePos;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/1092/pattern-ver1-serial/app.src.main.java.dimitris.android.chessviews.Square.java-setPiece.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:31:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+bestValidPos=parsePos;
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/1092/pattern-ver1-serial/app.src.main.java.dimitris.android.chessviews.Square.java-setPiece.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:31:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+bestValidPos=parsePos;
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/1092/pattern-ver1-serial/app.src.main.java.dimitris.android.chessviews.Square.java-setPiece.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:31:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(text.contains(text)){
+return 0;
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/5787/pattern-ver1-serial/modules.web.web-impl.src.main.java.com.enonic.xp.web.impl.WebHandlerRegistry.java-add.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:31:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(text.contains(text)){
+return 0;
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/5787/pattern-ver1-serial/modules.web.web-impl.src.main.java.com.enonic.xp.web.impl.WebHandlerRegistry.java-add.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:31:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+if(text.contains(text)){
+return 0;
+}
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/5787/pattern-ver1-serial/modules.web.web-impl.src.main.java.com.enonic.xp.web.impl.WebHandlerRegistry.java-add.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:31:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if(bucket!=null){
+bucket.restoreState(bestValidState);
+}
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:31:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bucket!=null){
+if(bestValidState!=null){
+bucket.restoreState(bestValidState);
+}
+return bestValidPos;
+}
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:31:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
+if(bucket!=null){
+DateTimeParser[] parsers=iParsers;
+int length=parsers.length;
+ final Object originalState=bucket.saveState();
+boolean isOptional=false;
+int bestValidPos=position;
+Object bestValidState=null;
+int bestInvalidPos=position;
+for(int i=0;i<length;i++){
+DateTimeParser parser=parsers[i];
+if(parser==null){
+if(bestValidPos<=position){
+return position;
+}
+isOptional=true;
+break;
+}
+int parsePos=parser.parseInto(bucket,text,position);
+if(parsePos>=position){
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
+}else {
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
+}
+}
+}
+bucket.restoreState(originalState);
+}
+if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidState!=null){
+bucket.restoreState(bestValidState);
+}
+return bestValidPos;
+}
+return ~bestInvalidPos;
+}
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:31:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(bucket!=null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:32:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(bucket!=null){
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:32:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+if(bucket!=null){
+DateTimeParser parser=parsers[i];
+if(parser==null){
+if(bestValidPos<=position){
+return position;
+}
+isOptional=true;
+break;
+}
+int parsePos=parser.parseInto(bucket,text,position);
+if(parsePos>=position){
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
+}else {
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
+}
+}
+}
+bucket.restoreState(originalState);
+}
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:32:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(text!=null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:32:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(text!=null){
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:32:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+if(text!=null){
+DateTimeParser parser=parsers[i];
+if(parser==null){
+if(bestValidPos<=position){
+return position;
+}
+isOptional=true;
+break;
+}
+int parsePos=parser.parseInto(bucket,text,position);
+if(parsePos>=position){
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
+}else {
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
+}
+}
+}
+bucket.restoreState(originalState);
+}
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:32:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+bestInvalidPos=parsePos;
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/7028/pattern-ver1-serial/src.main.java.lc.server.StargateConnection.java-thinkSpinUp.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:32:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||bestValidState==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/4897/pattern-ver1-serial/src.main.java.de.axxepta.oxygen.utils.WorkspaceUtils.java-newResourceOrOverwrite.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:32:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=-1;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=-1;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/446/pattern-ver1-serial/core.src.game.MathAlgorithms.mathQCreator.java-getPathsArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:32:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
+if(bestInvalidPos==0){
+return 0;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:32:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+if(bestInvalidPos==0){
+return 0;
+}
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:33:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
+if(bestInvalidPos==0){
+return 0;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:33:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+bucket.restoreState(originalState);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/2108/pattern-ver1-serial/pac4j-oauth.src.main.java.org.pac4j.oauth.client.BaseOAuth10Client.java-addAccessTokenToProfile.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:33:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+assert (!text.isEmpty());
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getOptionalStringArrayParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:33:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||((int)i+(int)1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V10/2453/pattern-ver1-serial/GURPS.src.Character.java-getMovementSpeed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:33:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[(int)i+(int)1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V10/2453/pattern-ver1-serial/GURPS.src.Character.java-getMovementSpeed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:33:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
+assert (parsers!=iParsers);
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:33:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
+assert (length!=parsers.length);
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:33:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
+assert (isOptional!=false);
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:33:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
+assert (bestValidPos!=position);
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:33:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
+assert (originalState!=bucket.saveState());
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:34:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+assert (bestInvalidPos!=position);
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:34:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+assert (parser!=parsers[i]);
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:34:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+assert (parsers!=null);
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V33/4564/pattern-ver1-serial/app.src.main.java.com.squirrel.justrread.api.RedditAPI.java-checkIfSubscribed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:34:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+bucket.restoreState(originalState);
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/198/pattern-ver1-serial/src.com.bekvon.bukkit.residence.listeners.ResidencePlayerListener.java-onPlayerMove.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:34:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+bucket.restoreState(originalState);
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/198/pattern-ver1-serial/src.com.bekvon.bukkit.residence.listeners.ResidencePlayerListener.java-onPlayerMove.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:34:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+bestInvalidPos++;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=-1;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:34:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=-1;
 }
 }
 }
+bestInvalidPos++;
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:34:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+bestInvalidPos++;
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=-1;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:34:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=-1;
 }
 }
 }
 bucket.restoreState(originalState);
 }
+bestInvalidPos++;
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:34:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=-1;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
+bestInvalidPos++;
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:35:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=-1;
 }
+bestInvalidPos++;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:35:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=-1;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+bestInvalidPos++;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:35:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=-1;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+bestValidPos++;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:35:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=-1;
 bestValidState=bucket.saveState();
 }
+bestValidPos++;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:35:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=-1;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+bestValidPos++;
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:35:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if("Chrome".equals(parsePos)||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V17/4219/pattern-ver1-serial/src.browsermator.com.STAppController.java-itemStateChanged.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:35:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+assert (text!=null);
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/126/pattern-ver1-serial/main.table.org.gamegineer.table.core.src.org.gamegineer.table.core.ComponentPath.java-compareTo.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:35:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+assert (bucket!=null);
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/126/pattern-ver1-serial/main.table.org.gamegineer.table.core.src.org.gamegineer.table.core.ComponentPath.java-compareTo.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:35:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+assert (bucket!=null);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:35:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
+assert (bucket!=null);
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:36:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+assert (text!=null);
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:36:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+assert (bucket!=null);
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:36:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+assert (text!=null);
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:36:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+assert (text!=null);
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:36:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+assert (bucket!=null);
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:36:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
+assert (text!=null);
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:36:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+bucket.restoreState(bestValidState);
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:36:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+bucket.restoreState(bestValidState);
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:36:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+bucket.restoreState(bestValidState);
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:36:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
+bucket.restoreState(bestValidState);
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:37:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
+bucket.restoreState(bestValidState);
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:37:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+bucket.restoreState(bestValidState);
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:37:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+bucket.restoreState(bestValidState);
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:37:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
+bucket.restoreState(bestValidState);
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/2420/pattern-ver1-serial/OpenWatch.src.org.ale.openwatch.fb.FBUtils.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:37:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
+if(!isOptional){
+throw new IllegalStateException("マージ対象のファイルが一つも見つかりませんでした。");
+}
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/4688/pattern-ver1-serial/src.org.teachothers.fishwatchr.CommentList.java-merge.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:37:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(bestValidState!=null||"查看红包".equals(bestValidState)){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:37:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
-if(parser==null){
+if(parser==null||"查看红包".equals(parser)){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:37:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<=position||"查看红包".equals(bestValidPos)){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:37:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos>bestInvalidPos||"查看红包".equals(parsePos)){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:37:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos||"查看红包".equals(parsePos)){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:38:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<0||"查看红包".equals(parsePos)){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:38:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos>=position||"查看红包".equals(parsePos)){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:38:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos||parsePos==3){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/1380/pattern-ver1-serial/Cluedo.src.control.Player.java-validMove.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:38:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<0||parsePos==3){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/1380/pattern-ver1-serial/Cluedo.src.control.Player.java-validMove.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:38:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<=position||bestValidPos==3){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/1380/pattern-ver1-serial/Cluedo.src.control.Player.java-validMove.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:38:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos>=position||parsePos==3){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/1380/pattern-ver1-serial/Cluedo.src.control.Player.java-validMove.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:38:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos>bestInvalidPos||parsePos==3){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/1380/pattern-ver1-serial/Cluedo.src.control.Player.java-validMove.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:38:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
-DateTimeParser parser=parsers[i];
-if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
+DateTimeParser parser=parsers[i];
+if(parser==null){
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/4240/pattern-ver1-serial/app.src.main.java.com.extenprise.mapp.service.activity.AppointmentDetailsActivity.java-gotResponse.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:38:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+bestValidState=bucket.saveState();
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:39:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+bestValidState=bucket.saveState();
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:39:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
+bestValidState=bucket.saveState();
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:39:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+bestValidState=bucket.saveState();
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:39:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+bestValidState=bucket.saveState();
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:39:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+bestValidState=bucket.saveState();
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:39:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+bestValidState=bucket.saveState();
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/6741/pattern-ver1-serial/core.src.main.java.org.jahia.modules.external.ExternalSessionImpl.java-move.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:39:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+bestValidState=bucket.saveState();
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/6741/pattern-ver1-serial/core.src.main.java.org.jahia.modules.external.ExternalSessionImpl.java-move.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:39:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
-parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
+parsePos=~parsePos;
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4266/pattern-ver1-serial/src.br.com.carlosrafaelgn.fplay.ActivityAbout.java-onCreateLayout.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:39:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
+parsePos=~parsePos;
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4266/pattern-ver1-serial/src.br.com.carlosrafaelgn.fplay.ActivityAbout.java-onCreateLayout.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:39:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
+}
+if(text.isEmpty()){
+text=null;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:40:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+if(text.isEmpty()){
+text=null;
+}
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:40:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(bestValidState!=null||bestValidState==""){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V38/7341/pattern-ver1-serial/log210_webproject_BDD.src.RechercheLivre.java-RechercheLivre.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:40:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<0||bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1602/pattern-ver1-serial/src.engine.network.server.ServerClient.java-knowMap.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:40:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos<0||parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1602/pattern-ver1-serial/src.engine.network.server.ServerClient.java-knowMap.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:40:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos<0||parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1602/pattern-ver1-serial/src.engine.network.server.ServerClient.java-knowMap.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:40:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<0||parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1602/pattern-ver1-serial/src.engine.network.server.ServerClient.java-knowMap.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:40:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos<0||parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1602/pattern-ver1-serial/src.engine.network.server.ServerClient.java-knowMap.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:40:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+bestValidState=bucket.saveState();
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:40:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+bestValidState=bucket.saveState();
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:41:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
+bestValidState=bucket.saveState();
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2665/pattern-ver1-serial/channel.src.main.java.com.github.dm.jrt.channel.ReplayChannel.java-onError.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:41:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
+bestValidState=bucket.saveState();
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2665/pattern-ver1-serial/channel.src.main.java.com.github.dm.jrt.channel.ReplayChannel.java-onError.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:41:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+bestValidState=bucket.saveState();
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6349/pattern-ver1-serial/src.com.example.smartphone.SelectECActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:41:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+bestValidState=bucket.saveState();
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:41:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+parsePos=~parsePos;
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1950/pattern-ver1-serial/Node.java-eventDelete.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:41:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
 parsePos=~parsePos;
+if(parsePos<0){
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V4/389/pattern-ver1-serial/src.profilGestion.java-gestion.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:41:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+bestValidState=bucket.saveState();
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/3128/pattern-ver1-serial/src.cubicmadness.gamestates.GameStateManager.java-popCurrentState.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:41:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+bestValidState=bucket.saveState();
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/3128/pattern-ver1-serial/src.cubicmadness.gamestates.GameStateManager.java-popCurrentState.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+bestValidState=bucket.saveState();
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/3128/pattern-ver1-serial/src.cubicmadness.gamestates.GameStateManager.java-popCurrentState.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:41:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||text.equals("manufacturedOn")||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V37/509/pattern-ver1-serial/product-validation-system-war.src.main.java.com.pvs.web.freemarker.processors.ProductTemplateRegistrationProcessor.java-postHTML.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:42:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+bestValidState=bucket.saveState();
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1266/pattern-ver1-serial/catroid.src.org.catrobat.catroid.livewallpaper.LiveWallpaper.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:42:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+bestValidState=bucket.saveState();
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1266/pattern-ver1-serial/catroid.src.org.catrobat.catroid.livewallpaper.LiveWallpaper.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:42:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+bestValidState=bucket.saveState();
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:42:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+bestValidState=bucket.saveState();
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:42:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
+bestInvalidPos=(parsePos+parsePos)%parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:42:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=(parsePos+parsePos)%parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:42:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position&&bestValidPos>=0||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1272/pattern-ver1-serial/rest-provider.src.main.java.org.jboss.pressgang.ccms.proxy.RESTCSRelatedNodeV1ProxyHandler.java-internalInvoke.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:42:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos==position&&bestValidPos>=0&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1272/pattern-ver1-serial/rest-provider.src.main.java.org.jboss.pressgang.ccms.proxy.RESTCSRelatedNodeV1ProxyHandler.java-internalInvoke.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:42:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
-bestValidPos=parsePos;
+bestValidPos=parsePos<0?0:parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V42/1445/pattern-ver1-serial/src.main.java.com.laudandjolynn.csvtools.CsvFile.java-CsvFile.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:42:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||((bestValidPos==position||bestValidPos=='\'')&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/6625/pattern-ver1-serial/src.com.google.javascript.jscomp.CodeConsumer.java-add.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:43:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if((bestValidPos>position||bestValidPos=='\'')||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/6625/pattern-ver1-serial/src.com.google.javascript.jscomp.CodeConsumer.java-add.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:43:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+bestValidState=bucket.saveState();
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3904/pattern-ver1-serial/src.heartbeat.TachySyringe.java-Use.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:43:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+bestValidState=bucket.saveState();
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3904/pattern-ver1-serial/src.heartbeat.TachySyringe.java-Use.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:43:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
+bestValidState=bucket.saveState();
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3904/pattern-ver1-serial/src.heartbeat.TachySyringe.java-Use.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:43:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
+bestValidState=bucket.saveState();
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3904/pattern-ver1-serial/src.heartbeat.TachySyringe.java-Use.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:43:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
+bestValidState=bucket.saveState();
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3904/pattern-ver1-serial/src.heartbeat.TachySyringe.java-Use.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:43:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<=position||bestValidPos==0){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1056/pattern-ver1-serial/lts-admin.src.main.java.com.github.ltsopensource.admin.web.api.SuspendJobQueueApi.java-suspendJobRecovery.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:43:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos||parsePos==0){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1056/pattern-ver1-serial/lts-admin.src.main.java.com.github.ltsopensource.admin.web.api.SuspendJobQueueApi.java-suspendJobRecovery.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:44:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<0||parsePos==0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1056/pattern-ver1-serial/lts-admin.src.main.java.com.github.ltsopensource.admin.web.api.SuspendJobQueueApi.java-suspendJobRecovery.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:44:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos>bestInvalidPos||parsePos==0){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1056/pattern-ver1-serial/lts-admin.src.main.java.com.github.ltsopensource.admin.web.api.SuspendJobQueueApi.java-suspendJobRecovery.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:44:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos>=position||parsePos==0){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1056/pattern-ver1-serial/lts-admin.src.main.java.com.github.ltsopensource.admin.web.api.SuspendJobQueueApi.java-suspendJobRecovery.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:44:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<0||parsePos>9){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2964/pattern-ver1-serial/main.plugins.org.talend.dataquality.sampling.src.main.java.org.talend.dataquality.datamasking.FunctionApplier.java-generateDuplicate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:44:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<=position||bestValidPos>9){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2964/pattern-ver1-serial/main.plugins.org.talend.dataquality.sampling.src.main.java.org.talend.dataquality.datamasking.FunctionApplier.java-generateDuplicate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:44:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos>bestInvalidPos||parsePos>9){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2964/pattern-ver1-serial/main.plugins.org.talend.dataquality.sampling.src.main.java.org.talend.dataquality.datamasking.FunctionApplier.java-generateDuplicate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:44:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos||parsePos>9){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2964/pattern-ver1-serial/main.plugins.org.talend.dataquality.sampling.src.main.java.org.talend.dataquality.datamasking.FunctionApplier.java-generateDuplicate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:44:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos>=position||parsePos>9){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2964/pattern-ver1-serial/main.plugins.org.talend.dataquality.sampling.src.main.java.org.talend.dataquality.datamasking.FunctionApplier.java-generateDuplicate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:44:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+bestValidState=bucket.saveState();
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/6314/pattern-ver1-serial/app.src.main.java.mobile.tiis.app.postman.SynchronisationService.java-onHandleIntent.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:44:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+bestValidState=bucket.saveState();
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
-bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/6314/pattern-ver1-serial/app.src.main.java.mobile.tiis.app.postman.SynchronisationService.java-onHandleIntent.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:45:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
- final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+ final Object originalState=bucket.saveState();
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V32/4434/pattern-ver1-serial/gui.src.main.java.org.jboss.as.console.client.shared.subsys.messaging.forms.ConnectorForm.java-asWidget.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:45:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:45:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:45:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:45:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:45:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:45:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:45:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:45:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+try{
 bucket.restoreState(originalState);
+}finally{
+bestValidState=bucket.saveState();
+}
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 1, INS : 0, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:45:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+bestValidState=bucket.saveState();
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3545/pattern-ver1-serial/components.device-mgt.org.wso2.carbon.device.mgt.core.src.main.java.org.wso2.carbon.device.mgt.core.operation.mgt.dao.impl.CommandOperationDAOImpl.java-deleteOperation.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:45:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<0&&parsePos<4000000){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V28/46/pattern-ver1-serial/raw.master.registryKit.registryKit.registryKit.src.main.java.com.registryKit.survey.surveyManager.java-saveSurveyDocument.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:46:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos&&parsePos<4000000){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V28/46/pattern-ver1-serial/raw.master.registryKit.registryKit.registryKit.src.main.java.com.registryKit.survey.surveyManager.java-saveSurveyDocument.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:46:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos>bestInvalidPos&&parsePos<4000000){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V28/46/pattern-ver1-serial/raw.master.registryKit.registryKit.registryKit.src.main.java.com.registryKit.survey.surveyManager.java-saveSurveyDocument.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:46:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<=position&&bestValidPos<4000000){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V28/46/pattern-ver1-serial/raw.master.registryKit.registryKit.registryKit.src.main.java.com.registryKit.survey.surveyManager.java-saveSurveyDocument.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:46:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos>=position&&parsePos<4000000){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V28/46/pattern-ver1-serial/raw.master.registryKit.registryKit.registryKit.src.main.java.com.registryKit.survey.surveyManager.java-saveSurveyDocument.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:46:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(bestValidState!=null||bestValidState==null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/4704/pattern-ver1-serial/src.main.java.com.alibaba.fastjson.parser.ParserConfig.java-createJavaBeanDeserializer.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:46:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
-if(parser==null){
+if(parser==null||parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/4704/pattern-ver1-serial/src.main.java.com.alibaba.fastjson.parser.ParserConfig.java-createJavaBeanDeserializer.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:46:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+if(parsePos<=0){
+return -1;
+}
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:46:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
 }
+if(parsePos<=0){
+return -1;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:46:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
+if(parsePos<=0){
+return -1;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:47:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+parsePos=~parsePos;
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/2177/pattern-ver1-serial/app.src.main.java.com.kshitij.android.clickme.ui.PhotoFeedActivity.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:47:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos&&parsePos!=9999){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5798/pattern-ver1-serial/SONPlugin.src.org.workcraft.plugins.son.granularity.HourMins.java-getHour.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:47:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(bestValidPos<=position&&bestValidPos!=9999){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5798/pattern-ver1-serial/SONPlugin.src.org.workcraft.plugins.son.granularity.HourMins.java-getHour.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:47:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<0&&parsePos!=9999){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5798/pattern-ver1-serial/SONPlugin.src.org.workcraft.plugins.son.granularity.HourMins.java-getHour.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:47:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(parsePos>bestInvalidPos&&parsePos!=9999){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5798/pattern-ver1-serial/SONPlugin.src.org.workcraft.plugins.son.granularity.HourMins.java-getHour.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:47:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos>=position&&parsePos!=9999){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5798/pattern-ver1-serial/SONPlugin.src.org.workcraft.plugins.son.granularity.HourMins.java-getHour.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:47:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
+if(position>0&&bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/553/pattern-ver1-serial/src.main.java.edu.berkeley.cs.nlp.ocular.main.TrainFont.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:47:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(bestValidPos>0&&parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/553/pattern-ver1-serial/src.main.java.edu.berkeley.cs.nlp.ocular.main.TrainFont.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:47:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
+if(bestInvalidPos>0&&parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/553/pattern-ver1-serial/src.main.java.edu.berkeley.cs.nlp.ocular.main.TrainFont.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:47:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(position>0&&parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/553/pattern-ver1-serial/src.main.java.edu.berkeley.cs.nlp.ocular.main.TrainFont.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:48:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(0>0&&parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/553/pattern-ver1-serial/src.main.java.edu.berkeley.cs.nlp.ocular.main.TrainFont.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:48:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
+assert (position>=0):"Receive a negative tratment";
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6481/pattern-ver1-serial/QualCurso.app.src.main.java.models.Book.java-setChapters.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:48:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
+assert (position>=0):"Receive a negative tratment";
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6481/pattern-ver1-serial/QualCurso.app.src.main.java.models.Book.java-setChapters.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:48:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+assert (position>=0):"Receive a negative tratment";
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6481/pattern-ver1-serial/QualCurso.app.src.main.java.models.Book.java-setChapters.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:48:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
+assert (position>=0):"Receive a negative tratment";
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6481/pattern-ver1-serial/QualCurso.app.src.main.java.models.Book.java-setChapters.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:48:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+parsePos=~parsePos;
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
-parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V69/354/pattern-ver1-serial/app.src.main.java.org.jorge.lbudget.ui.frags.MovementDetailDialogFragment.java-onCreateDialog.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:48:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:48:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:48:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:49:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:49:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:49:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:49:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:49:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.LinkedList;
+
+import java.util.List;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+isOptional=true;
 bestValidState=bucket.saveState();
 }
+isOptional=true;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/5/pattern-ver1-serial/week04.src.UCodeGeneratorListener.java-exitIf_stmt.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 2, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:49:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.LinkedList;
+
+import java.util.List;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+isOptional=true;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+isOptional=true;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/5/pattern-ver1-serial/week04.src.UCodeGeneratorListener.java-exitIf_stmt.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 2, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:49:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.LinkedList;
+
+import java.util.List;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
+isOptional=true;
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+isOptional=true;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/5/pattern-ver1-serial/week04.src.UCodeGeneratorListener.java-exitIf_stmt.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 2, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:49:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.LinkedList;
+
+import java.util.List;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+isOptional=true;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+isOptional=true;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/5/pattern-ver1-serial/week04.src.UCodeGeneratorListener.java-exitIf_stmt.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 2, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:49:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.LinkedList;
+
+import java.util.List;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+isOptional=true;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+isOptional=true;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/5/pattern-ver1-serial/week04.src.UCodeGeneratorListener.java-exitIf_stmt.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 2, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:49:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.LinkedList;
+
+import java.util.List;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+bestInvalidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+bestInvalidPos=parsePos;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/5/pattern-ver1-serial/week04.src.UCodeGeneratorListener.java-exitIf_stmt.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 2, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:50:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.LinkedList;
+
+import java.util.List;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+bestInvalidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+bestInvalidPos=parsePos;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/5/pattern-ver1-serial/week04.src.UCodeGeneratorListener.java-exitIf_stmt.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 2, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:50:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+bestValidState=bucket.saveState();
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V18/2625/pattern-ver1-serial/app.src.main.java.de.aw.cash.action.FragmentBuchungRegelm.java-bindView.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:50:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+assert (bucket!=null):"Appointments day is not allowed to be null!";
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:50:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+assert (bucket!=null):"Appointments day is not allowed to be null!";
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:50:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+assert (text!=null):"Appointments day is not allowed to be null!";
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:50:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+assert (bucket!=null):"Appointments day is not allowed to be null!";
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:50:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+assert (text!=null):"Appointments day is not allowed to be null!";
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:50:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+assert (text!=null):"Appointments day is not allowed to be null!";
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:50:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+assert (bucket!=null):"Appointments day is not allowed to be null!";
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:50:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+assert (bucket!=null):"Appointments day is not allowed to be null!";
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:51:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.Calendar;
+
+import java.util.Date;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
+assert (position!=0):"Receive a size tratment";
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6481/pattern-ver1-serial/QualCurso.app.src.main.java.models.Course.java-newArray.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:51:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.Calendar;
+
+import java.util.Date;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
+assert (position!=0):"Receive a size tratment";
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6481/pattern-ver1-serial/QualCurso.app.src.main.java.models.Course.java-newArray.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:51:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.Calendar;
+
+import java.util.Date;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
+assert (position!=0):"Receive a size tratment";
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6481/pattern-ver1-serial/QualCurso.app.src.main.java.models.Course.java-newArray.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:51:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
+import java.util.Calendar;
+
+import java.util.Date;
+
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
+assert (position!=0):"Receive a size tratment";
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6481/pattern-ver1-serial/QualCurso.app.src.main.java.models.Course.java-newArray.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:51:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(text.isEmpty()){
+throw new IllegalArgumentException("Title must not be empty!");
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/1109/pattern-ver1-serial/eclipse.src.stoberry.dataManagement.Management.java-sendMessage.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:51:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if(bucket==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:51:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+if(bucket==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:51:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(text==null){
+throw new IllegalStateException("player is not initialised, game might not be started");
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/378/pattern-ver1-serial/src.main.java.game.Game.java-extraLife.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:51:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
+}
+if(position>7){
+throw new RuntimeException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:51:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if(bestValidState==null){
+throw new IllegalStateException("Cannot instantiate Page whitout String url constructor parameter or @PageURL class annotation");
+}
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4732/pattern-ver1-serial/src.main.java.com.mgiorda.page.AbstractPage.java-AbstractPage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:52:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
 }
+if(originalState==null){
+throw new IllegalStateException("Cannot instantiate Page whitout String url constructor parameter or @PageURL class annotation");
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4732/pattern-ver1-serial/src.main.java.com.mgiorda.page.AbstractPage.java-AbstractPage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:52:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+if(originalState!=null){
 bucket.restoreState(originalState);
+}
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/7166/pattern-ver1-serial/src.main.java.net.dandielo.core.items.dItem.java-addAttribute.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 3, INS : 0, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:52:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+if(bestInvalidPos<0){
+bestInvalidPos=0;
+}
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:52:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
+if(bestInvalidPos<0){
+bestInvalidPos=0;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:52:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
+if(bestInvalidPos<0){
+bestInvalidPos=0;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:52:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
+if(bestValidState.equals("")){
+bestValidState="Manchester United FC";
+}
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V11/4958/pattern-ver1-serial/FootballScores.app.src.main.java.barqsoft.footballscores.widget.ScoresWidgetIntentService.java-onHandleIntent.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:52:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+if(bestInvalidPos!=parsePos){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/529/pattern-ver1-serial/src.com.crankcode.threads.MediaThread.java-end.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 3, INS : 0, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:52:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
+}
+if(bestInvalidPos<=0){
+bestInvalidPos=1;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/1761/pattern-ver1-serial/JazminServer.src.jazmin.core.monitor.DispatcherMonitorAgent.java-sample.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:52:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+if(isOptional!=true){
 bucket.restoreState(originalState);
+}
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V28/568/pattern-ver1-serial/src.net.skycraftmc.SkyQuest.utilitygui.ObjectiveEditPanel.java-clear.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 3, INS : 0, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:52:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
+if(bestInvalidPos!=parsePos){
 bucket.restoreState(originalState);
+}
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V28/568/pattern-ver1-serial/src.net.skycraftmc.SkyQuest.utilitygui.ObjectiveEditPanel.java-clear.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 3, INS : 0, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:53:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(bestValidState!=null&&!bestValidState.equals("")){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/6260/pattern-ver1-serial/Client.src.com.way.chat.activity.ChatActivity.java-onItemClick.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:53:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
-if(parser==null){
+if(parser==null&&!parser.equals("")){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/6260/pattern-ver1-serial/Client.src.com.way.chat.activity.ChatActivity.java-onItemClick.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:53:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
+bucket.restoreState(bestValidState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
+bucket.restoreState(originalState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/4615/pattern-ver1-serial/org.smartsnip.src.org.smartsnip.client.TagArea.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:53:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
-bucket.restoreState(bestValidState);
+bucket.restoreState(originalState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/4615/pattern-ver1-serial/org.smartsnip.src.org.smartsnip.client.TagArea.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:53:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
+bucket.restoreState(bestValidState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/4615/pattern-ver1-serial/org.smartsnip.src.org.smartsnip.client.TagArea.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:53:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
 }
+if(bestInvalidPos<=0){
+bestInvalidPos=parsePos;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1816/pattern-ver1-serial/dkpro-tc-ml.src.main.java.org.dkpro.tc.ml.FoldClassificationUnitCasMultiplier.java-process.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:53:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
+if(bestInvalidPos<=0){
+bestInvalidPos=parsePos;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1816/pattern-ver1-serial/dkpro-tc-ml.src.main.java.org.dkpro.tc.ml.FoldClassificationUnitCasMultiplier.java-process.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:53:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
+}
+if(bestInvalidPos<=0){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V36/1816/pattern-ver1-serial/dkpro-tc-ml.src.main.java.org.dkpro.tc.ml.FoldClassificationUnitCasMultiplier.java-process.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:53:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+synchronized(this){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
+}
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:53:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
+synchronized(this){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
+}
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:54:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidState!=null){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
+}else {
+bucket.restoreState("");
+}
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V38/6520/pattern-ver1-serial/src.main.java.org.metadatacenter.submission.biosample.core.BioSampleValidator.java-generateBioSampleSubmissionXML.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:54:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidState!=null){
+bucket.restoreState(bestValidState);
+}
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 0, INS : 1, DEL : 6
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:54:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
+}else {
+bucket.restoreState(bestValidState);
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/2602/pattern-ver1-serial/src.com.github.norbo11.game.poker.PokerPlayer.java-bet.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:54:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
 bucket.restoreState(bestValidState);
-}
-return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2729/pattern-ver1-serial/Spykes.CloudVision.app.src.main.java.inovation.lab.cloudvision.Speech.java-onInit.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:54:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
+if(originalState==null){
+throw new IllegalStateException("User isn't registered! "+bucket);
+}
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/5393/pattern-ver1-serial/peergos.user.UserContext.java-sendFollowRequest.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:54:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if((bestValidPos>position)||((bestValidPos==position&&isOptional))){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V17/5331/pattern-ver1-serial/src.main.java.groupProject.twentyFortyEight.GameLogic.java-gameOver.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:54:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(text.startsWith("\r\n")){
+text=text.substring(2);
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:54:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(text.startsWith("\r\n")){
+text=text.substring(2);
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:54:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+if(text.startsWith("/")){
+text=text.substring(1);
+}
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V47/2604/pattern-ver1-serial/components.data-services.org.wso2.carbon.dataservices.core.src.main.java.org.wso2.carbon.dataservices.core.DBDeployer.java-createAxisOperation.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:54:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+if(text.startsWith("/")){
+text=text.substring(1);
+}
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V47/2604/pattern-ver1-serial/components.data-services.org.wso2.carbon.dataservices.core.src.main.java.org.wso2.carbon.dataservices.core.DBDeployer.java-createAxisOperation.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:55:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
+if(bestValidPos<0){
+bestValidPos=position;
+}
 Object bestValidState=null;
 int bestInvalidPos=position;
+if(bestInvalidPos<0){
+bestInvalidPos=position;
+}
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V3/5043/pattern-ver1-serial/src.Server.ServerWorld.java-updateObjects.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:55:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
-return position;
+if(bestValidState!=null){
+bucket.restoreState(bestValidState);
+}
+return bestValidPos;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
-bucket.restoreState(bestValidState);
-}
-return bestValidPos;
+return position;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/606/pattern-ver1-serial/aws-java-sdk-s3.src.main.java.com.amazonaws.services.s3.internal.BucketNameUtils.java-isValidV2BucketName.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:55:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
-if(bestValidPos<=position){
-return position;
+if(bestValidState!=null){
+bucket.restoreState(bestValidState);
 }
-isOptional=true;
-break;
+return bestValidPos;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
-return bestValidPos;
+return position;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V46/4540/pattern-ver1-serial/core-cube.src.main.java.org.apache.kylin.gridtable.GTScanRangePlanner.java-compare.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:55:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos==position&&isOptional)||"查看红包".equals(bestValidPos>position)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:55:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos<0L||(bestValidPos>position||(bestValidPos==position&&isOptional))){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/110/pattern-ver1-serial/src.com.firebirdberlin.nightdream.ui.NightDreamUI.java-updateWeatherData.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:55:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(true){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:55:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos==position&&isOptional)&&isOptional){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2749/pattern-ver1-serial/Stuyablo.java-combat.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:55:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if((bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/293/pattern-ver1-serial/src.snpsvm.app.CommandLineApp.java-main.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:55:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
+boolean haveBreadCrumbs=false;
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos&&haveBreadCrumbs){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+haveBreadCrumbs=true;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:56:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
+boolean haveBreadCrumbs=false;
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos&&haveBreadCrumbs){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+haveBreadCrumbs=true;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:56:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
+boolean haveBreadCrumbs=false;
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos&&haveBreadCrumbs){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+haveBreadCrumbs=true;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:56:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
+boolean haveBreadCrumbs=false;
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos&&haveBreadCrumbs){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+haveBreadCrumbs=true;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:56:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
+boolean haveBreadCrumbs=false;
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
+if(parsePos>bestValidPos&&haveBreadCrumbs){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+haveBreadCrumbs=true;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:56:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
+boolean haveBreadCrumbs=false;
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+haveBreadCrumbs=true;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos<0&&haveBreadCrumbs){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:56:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(isOptional&&(bestValidPos>position||(bestValidPos==position&&isOptional))){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:56:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position||(bestValidPos==position&&isOptional)||isOptional){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:56:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bestValidPos>position){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/1184/pattern-ver1-serial/swagplash.src.main.java.com.github.albertosh.swagplash.actions.ApiBodyParamAction.java-call.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:56:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if(bucket==null||bestValidState==null){
+throw new NullPointerException();
+}
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:56:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
+if(bucket==null||bestValidState==null){
+throw new NullPointerException();
+}
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:57:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
+}
+if(text==null||bucket==null){
+throw new NullPointerException();
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:57:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
+}
+if(bucket==null||bestValidState==null){
+throw new NullPointerException();
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:57:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
+if(text==null||bucket==null){
+throw new NullPointerException();
+}
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:57:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
+}
+if(bucket==null||text==null){
+throw new NullPointerException();
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:57:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+if(parsePos==-2){
 if(parsePos>bestInvalidPos){
+bestInvalidPos=0;
+}else {
 bestInvalidPos=parsePos;
+}
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4193/pattern-ver1-serial/simple-comsumer.src.main.java.com.wxmimperio.simple.consumer.clients.SimpleConsumerAPI.java-init.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:57:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos==-2){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
+if(parsePos<0){
+bestInvalidPos=0;
+}else {
 bestInvalidPos=parsePos;
+}
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4193/pattern-ver1-serial/simple-comsumer.src.main.java.com.wxmimperio.simple.consumer.clients.SimpleConsumerAPI.java-init.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:57:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
+if(parsePos==-2){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4193/pattern-ver1-serial/simple-comsumer.src.main.java.com.wxmimperio.simple.consumer.clients.SimpleConsumerAPI.java-init.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:57:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
+if(parsePos==-2){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4193/pattern-ver1-serial/simple-comsumer.src.main.java.com.wxmimperio.simple.consumer.clients.SimpleConsumerAPI.java-init.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:57:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(parsePos==-2){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
 if(parsePos>bestValidPos){
+bestValidPos=0;
+}else {
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4193/pattern-ver1-serial/simple-comsumer.src.main.java.com.wxmimperio.simple.consumer.clients.SimpleConsumerAPI.java-init.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:57:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+synchronized(this){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:58:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
-if(parser==null){
-if(bestValidPos<=position){
-return position;
-}
-isOptional=true;
-break;
-}
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/1889/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.internal.partition.impl.PartitionReplicaStateChecker.java-isReplicaInSyncState.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 0, DEL : 10
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:58:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(isOptional||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5778/pattern-ver1-serial/src.main.java.cn.momia.mapi.api.AbstractIndexApi.java-getBanners.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:58:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if(position==3){
+System.out.println("debug");
+}
 bucket.restoreState(bestValidState);
+if(position==3){
+System.out.println("debug");
+}
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V9/4383/pattern-ver1-serial/Dameo.src.dameo.gametree.NegaMax.java-alphaBeta.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:58:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(position==3){
+System.out.println("debug");
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+if(position==3){
+System.out.println("debug");
+}
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V9/4383/pattern-ver1-serial/Dameo.src.dameo.gametree.NegaMax.java-alphaBeta.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:58:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+if(length==3){
+System.out.println("debug");
+}
 bucket.restoreState(bestValidState);
+if(length==3){
+System.out.println("debug");
+}
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V9/4383/pattern-ver1-serial/Dameo.src.dameo.gametree.NegaMax.java-alphaBeta.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:58:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+}else {
+bestInvalidPos=parsePos;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/2602/pattern-ver1-serial/src.com.github.norbo11.game.poker.PokerPlayer.java-bet.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:58:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
-parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
-}
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2729/pattern-ver1-serial/Spykes.CloudVision.app.src.main.java.inovation.lab.cloudvision.Speech.java-onInit.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:58:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(parsePos<0){
+parsePos--;
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
 }
+if(parsePos<0){
+parsePos--;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2288/pattern-ver1-serial/src.fr.jules_cesar.Loto.main.java-onEnable.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:58:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+if(text.endsWith("/")==false){
+text=text+"/";
+}
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V37/627/pattern-ver1-serial/src.main.java.com.thunder.util.Util.java-restMap.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:58:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if("Chrome".equals(parsePos>=text.length())||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V17/4219/pattern-ver1-serial/src.browsermator.com.STAppController.java-itemStateChanged.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:59:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
-bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/5667/pattern-ver1-serial/src.AccessorBean.java-onPageLoaded.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 8, INS : 0, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:59:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
+}
+if(parsers[i]==null){
+throw new IllegalArgumentException("Failed to get an icon for "+text.getClass().getName());
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V38/995/pattern-ver1-serial/libtech.RenderLightmap.java-renderWorldBlock.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:59:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+}
+if(parsers[i]==null){
+throw new IllegalArgumentException("Failed to get an icon for "+text.getClass().getName());
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V38/995/pattern-ver1-serial/libtech.RenderLightmap.java-renderWorldBlock.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:59:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
+if(parsers[i]==null){
+throw new IllegalArgumentException("Failed to get an icon for "+text.getClass().getName());
+}
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V38/995/pattern-ver1-serial/libtech.RenderLightmap.java-renderWorldBlock.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 11, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:59:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(parsers==null||bucket==null||text==null){
+return 0;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 0, INS : 12, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:59:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(parsers==null||text==null||bucket==null){
+return 0;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 0, INS : 12, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:59:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(bucket==null||text==null||parsers==null){
+return 0;
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/1000/pattern-ver1-serial/common.crazypants.enderio.machine.crusher.CrusherRecipeManager.java-addRecipe.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 0, INS : 12, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:59:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
+if(bestValidPos<3){
+bestValidPos=3;
+}
 Object bestValidState=null;
 int bestInvalidPos=position;
+if(bestInvalidPos<3){
+bestInvalidPos=3;
+}
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/5504/pattern-ver1-serial/components.insight.SRC.org.openmicroscopy.shoola.util.image.geom.Factory.java-magnifyImage.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 0, INS : 12, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:59:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
+if(length<3){
+length=3;
+}
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
+if(bestValidPos<3){
+bestValidPos=3;
+}
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/5504/pattern-ver1-serial/components.insight.SRC.org.openmicroscopy.shoola.util.image.geom.Factory.java-magnifyImage.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 0, INS : 12, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 08:59:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
+if(bestValidPos>position){
+if(bestValidState!=null&&(bestValidPos==position&&isOptional)){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V21/4076/pattern-ver1-serial/moho-impl.src.main.java.com.voxeo.moho.sip.DirectAI2NOJoinDelegate.java-doInviteResponse.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 12, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:00:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(parsePos<0){
+parsePos=0;
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
 }
+if(parsePos<0){
+parsePos=0;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/399/pattern-ver1-serial/src.client.panel.FormEntryPanel.java-keyPressed.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 0, INS : 12, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:00:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
-parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
-}
-}
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V54/1742/pattern-ver1-serial/obdalib-protege41.src.main.java.it.unibz.krdb.obda.protege4.gui.action.R2RMLImportAction.java-actionPerformed.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 13, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:00:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
-if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
-}
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/2602/pattern-ver1-serial/src.com.github.norbo11.game.poker.PokerPlayer.java-bet.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 13, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:00:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
+long startTime=System.currentTimeMillis();
 bucket.restoreState(bestValidState);
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:00:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+long startTime=System.currentTimeMillis();
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:00:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+long startTime=System.currentTimeMillis();
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:00:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
+long startTime=System.currentTimeMillis();
 bestInvalidPos=parsePos;
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:00:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+long startTime=System.currentTimeMillis();
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:00:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+long startTime=System.currentTimeMillis();
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:00:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
+}
+}
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 0, INS : 1, DEL : 13
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:00:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+}
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
-}
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V38/926/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.FileVirtualPoolService.java-prepareVirtualPool.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 0, INS : 1, DEL : 13
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:01:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
+}
+}
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/5429/pattern-ver1-serial/src.com.github.dreamrec.edf.EdfWriter.java-onDataReceived.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 0, INS : 1, DEL : 13
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:01:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
+}
+}
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V31/1697/pattern-ver1-serial/yamcs-core.src.main.java.org.yamcs.xtceproc.AlarmChecker.java-performAlarmCheckingEnumerated.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 0, INS : 1, DEL : 13
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:01:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
-}
-if(bestValidPos>position||(bestValidPos==position&&isOptional)){
-if(bestValidState!=null){
-bucket.restoreState(bestValidState);
-}
-return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 0, DEL : 16
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:01:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null||"查看红包".equals(parsePos>=text.length()||(i+1)>=length)){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:01:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null||(i+1)=='%'){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/6049/pattern-ver1-serial/src.main.java.org.wltea.analyzer.core.LaTeXSegmenter.java-addOperatorFormula.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:01:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(true){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:01:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null&&isOptional){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2749/pattern-ver1-serial/Stuyablo.java-combat.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:01:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null==false){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:01:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null&&(i+1)>0){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/3401/pattern-ver1-serial/src.edu.gordian.scopes.Scope.java-toElement.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:02:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/293/pattern-ver1-serial/src.snpsvm.app.CommandLineApp.java-main.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:02:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/947/pattern-ver1-serial/advinst-server.src.main.java.jetbrains.buildServer.advinst.server.AdvinstRunTypePropertiesProcessor.java-process.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:02:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(isOptional&&(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null)){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:02:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null||isOptional){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:02:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null==true){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:02:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/3655/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.placement.RecoverPointScheduler.java-scheduleStorageSourcePoolConstraint.pattern
MATCHLEVEL : ALL
ALL : 19, UPD : 0, INS : 1, DEL : 18
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:02:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+}
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V11/5689/pattern-ver1-serial/minecraft.net.minecraft.src.BlockCocoaSapling.java-blockActivated.pattern
MATCHLEVEL : ALL
ALL : 19, UPD : 0, INS : 1, DEL : 18
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:02:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
-if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
+if(parsePos>=position){
+if(parsePos>bestValidPos){
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1562/pattern-ver1-serial/assignment6.src.assignment6.TicketClient.java-run.pattern
MATCHLEVEL : ALL
ALL : 19, UPD : 0, INS : 1, DEL : 18
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:02:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
-}
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
 }
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1562/pattern-ver1-serial/assignment6.src.assignment6.TicketClient.java-run.pattern
MATCHLEVEL : ALL
ALL : 19, UPD : 0, INS : 1, DEL : 18
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:02:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/2878/pattern-ver1-serial/src.main.java.de.webfilesys.FileLinkSelector.java-selectFiles.pattern
MATCHLEVEL : ALL
ALL : 19, UPD : 0, INS : 1, DEL : 18
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:02:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/2878/pattern-ver1-serial/src.main.java.de.webfilesys.FileLinkSelector.java-selectFiles.pattern
MATCHLEVEL : ALL
ALL : 19, UPD : 0, INS : 1, DEL : 18
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:03:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+synchronized(this){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+}
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 25, UPD : 25, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:03:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+synchronized(this){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+}
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 28, UPD : 28, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:03:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
-}
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/2685/pattern-ver1-serial/src.MatrixGraph.java-add.pattern
MATCHLEVEL : ALL
ALL : 28, UPD : 28, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:03:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 29, UPD : 0, INS : 1, DEL : 28
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:03:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 29, UPD : 0, INS : 1, DEL : 28
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:03:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 29, UPD : 0, INS : 1, DEL : 28
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:03:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 29, UPD : 0, INS : 1, DEL : 28
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:03:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 29, UPD : 0, INS : 1, DEL : 28
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:03:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V11/5689/pattern-ver1-serial/minecraft.net.minecraft.src.BlockCocoaSapling.java-blockActivated.pattern
MATCHLEVEL : ALL
ALL : 29, UPD : 0, INS : 1, DEL : 28
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:03:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
+}
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
 }
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V11/5689/pattern-ver1-serial/minecraft.net.minecraft.src.BlockCocoaSapling.java-blockActivated.pattern
MATCHLEVEL : ALL
ALL : 29, UPD : 0, INS : 1, DEL : 28
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:04:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/2878/pattern-ver1-serial/src.main.java.de.webfilesys.FileLinkSelector.java-selectFiles.pattern
MATCHLEVEL : ALL
ALL : 29, UPD : 0, INS : 1, DEL : 28
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:04:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
+if(parser!=null){
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
+}
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/258/pattern-ver1-serial/web.src.main.java.com.epam.freelancer.web.controller.UserController.java-addIsComplaintInOrderings.pattern
MATCHLEVEL : ALL
ALL : 31, UPD : 3, INS : 0, DEL : 28
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:04:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
-if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
 }
-bestValidPos=parsePos;
-bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3134/pattern-ver1-serial/app.src.main.java.ru.vif2ne.ui.MainActivity.java-refreshBottomMenu.pattern
MATCHLEVEL : ALL
ALL : 31, UPD : 31, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:04:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+bestInvalidPos=parsePos;
+}else {
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
-}else {
-if(parsePos<0){
-parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/3937/pattern-ver1-serial/src.Main.Analysis.java-calculatePrecisionRecall.pattern
MATCHLEVEL : ALL
ALL : 31, UPD : 31, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:04:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
 if(parsePos>bestValidPos){
+bestValidState+="+";
+}
+}else {
+if(parsePos<0){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
-}
-}else {
-if(parsePos<0){
-parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
-}
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V13/4205/pattern-ver1-serial/NewtonRaphsonApp.java-updateCommand.pattern
MATCHLEVEL : ALL
ALL : 35, UPD : 35, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:04:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
 if(parsePos>=position){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
+}
+}else {
+if(parsePos<0){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
-}
-}else {
-if(parsePos<0){
-parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/3937/pattern-ver1-serial/src.Main.Analysis.java-calculatePrecisionRecall.pattern
MATCHLEVEL : ALL
ALL : 38, UPD : 38, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:04:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
-if(parsePos>=position){
-if(parsePos>bestValidPos){
-if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
-return parsePos;
-}
-bestValidPos=parsePos;
-bestValidState=bucket.saveState();
-}
-}else {
-if(parsePos<0){
-parsePos=~parsePos;
-if(parsePos>bestInvalidPos){
-bestInvalidPos=parsePos;
-}
-}
-}
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V32/2603/pattern-ver1-serial/Android.BarcodeScanner.2.0.0.src.com.phonegap.plugins.barcodescanner.BarcodeScanner.java-onActivityResult.pattern
MATCHLEVEL : ALL
ALL : 44, UPD : 0, INS : 0, DEL : 44
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:04:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(parsePos>=position){
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
+}
+}else {
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
+}
+}
+}
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V31/1697/pattern-ver1-serial/yamcs-core.src.main.java.org.yamcs.xtceproc.AlarmChecker.java-performAlarmCheckingEnumerated.pattern
MATCHLEVEL : ALL
ALL : 45, UPD : 0, INS : 1, DEL : 44
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:04:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java[2667,2722]
------------Candidate---------------
 public int parseInto(DateTimeParserBucket bucket,String text,int position){
 DateTimeParser[] parsers=iParsers;
 int length=parsers.length;
  final Object originalState=bucket.saveState();
 boolean isOptional=false;
 int bestValidPos=position;
 Object bestValidState=null;
 int bestInvalidPos=position;
 for(int i=0;i<length;i++){
 DateTimeParser parser=parsers[i];
 if(parser==null){
 if(bestValidPos<=position){
 return position;
 }
 isOptional=true;
 break;
 }
 int parsePos=parser.parseInto(bucket,text,position);
+if(parsePos>=position){
+if(parsePos>bestValidPos){
+if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
+return parsePos;
+}
+bestValidPos=parsePos;
+bestValidState=bucket.saveState();
+}
+}else {
+if(parsePos<0){
+parsePos=~parsePos;
+if(parsePos>bestInvalidPos){
+bestInvalidPos=parsePos;
+}
+}
+}
 if(parsePos>=position){
 if(parsePos>bestValidPos){
 if(parsePos>=text.length()||(i+1)>=length||parsers[i+1]==null){
 return parsePos;
 }
 bestValidPos=parsePos;
 bestValidState=bucket.saveState();
 }
 }else {
 if(parsePos<0){
 parsePos=~parsePos;
 if(parsePos>bestInvalidPos){
 bestInvalidPos=parsePos;
 }
 }
 }
 bucket.restoreState(originalState);
 }
 if(bestValidPos>position||(bestValidPos==position&&isOptional)){
 if(bestValidState!=null){
 bucket.restoreState(bestValidState);
 }
 return bestValidPos;
 }
 return ~bestInvalidPos;
 }

PATTERN : /home/jiajun/GithubData/2015/V31/1697/pattern-ver1-serial/yamcs-core.src.main.java.org.yamcs.xtceproc.AlarmChecker.java-performAlarmCheckingEnumerated.pattern
MATCHLEVEL : ALL
ALL : 45, UPD : 0, INS : 1, DEL : 44
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 09:04:51 CDT
--------------- END -----------------
Location : org.joda.time.format.DateTimeParserBucket.computeMillis:[335, 336, 363, 341, 342, 343, 344, 353, 377, 332, 333, 334, 338, 339, 350, 352, 360, 362]#0.14586499149789456
Compute Candidate : 2019.09.05 AD at 09:05:09 CDT - 2019.09.05 AD at 10:11:47 CDT , PNumber : 11385, CandNumber : 537 
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+continue;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/7570/pattern-ver1-serial/src.main.java.com.rayn.jflask.framework.mvc.MultipartHelper.java-parseMultipartParamList.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:11:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:11:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
+ DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:12:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
+ DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:12:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
-SavedField[] savedFields=iSavedFields;
+ SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:12:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
-int count=iSavedFieldsCount;
+ int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:12:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
-long millis=iMillis;
+ long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:12:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count>1){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5133/pattern-ver1-serial/app.src.main.java.com.bignerdranch.android.photogallery.PhotoGalleryFragment.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:12:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count>=0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/3225/pattern-ver1-serial/src.org.peg4d.ParserContext.java-beginPeformStat.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:12:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
-if(text!=null){
+if(text==null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V40/1240/pattern-ver1-serial/flexo-foundation.src.main.java.org.openflexo.foundation.viewpoint.FlexoConceptInstanceRole.java-applyValidation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:12:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
-if(text!=null){
+if(text==null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V40/1240/pattern-ver1-serial/flexo-foundation.src.main.java.org.openflexo.foundation.viewpoint.FlexoConceptInstanceRole.java-applyValidation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:12:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
+millis-=1;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:12:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
+return 0l;
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:12:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+return 0l;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
+return 0l;
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+return 0l;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+return 0l;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0;millis<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/7268/pattern-ver1-serial/src.org.easypr.core.CharsSegment.java-SortRect.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0;i<=count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V45/3857/pattern-ver1-serial/src.com.urverkspel.humancompanion.AttackData.java-roll.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
+millis-=offset;
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import java.util.Collection;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0,myUid;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V12/276/pattern-ver1-serial/actor-sdk.sdk-core.core.core-shared.src.main.java.im.actor.core.viewmodel.GroupVM.java-create.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0,DEFAULT_TIMEOUT2;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V49/3872/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ManageAccount.java-addNewUserAccount.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0;i>count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V44/4500/pattern-ver1-serial/src.main.java.com.michael.e.liquislots.item.ItemLiquipack.java-addInformation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
+millis-=0;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V32/6155/pattern-ver1-serial/SideScroller.src.net.masterzach32.sidescroller.entity.enemy.Boss.java-Boss.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0,MAX_SERVICE_NODES;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V48/4395/pattern-ver1-serial/vipr-portal.com.emc.sa.common.src.java.com.emc.sa.zookeeper.ZkServiceDescriptors.java-start.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0,MAX_ZK_WAIT_RETRY_TIMES;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7180/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.vdc.VdcOpHandler.java-waitForAllNodesAndReboot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+break;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:13:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(resetFields){
 saveField(DateTimeFieldType.year(),iDefaultYear);
+}
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V4/3119/pattern-ver1-serial/X3-InteractiveMap_GUI.src.main.java.de.ncm.x3.iam.gui.component.universe.JSector.java-setHighlighted.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+if(resetFields){
 millis=savedFields[i].set(millis,resetFields);
+}
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V4/3119/pattern-ver1-serial/X3-InteractiveMap_GUI.src.main.java.de.ncm.x3.iam.gui.component.universe.JSector.java-setHighlighted.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)>0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V40/2013/pattern-ver1-serial/src.main.java.mousio.client.retry.RetryWithExponentialBackOff.java-shouldRetry.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0;i<count;i--){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V7/4666/pattern-ver1-serial/src.main.java.com.deanveloper.playtimeplus.commands.playtime.subcommand.TopSubCmd.java-execute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+iSavedFields=savedFields=(SavedField[])savedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/3614/pattern-ver1-serial/library.src.main.java.com.davidstemmer.screenplay.flow.Screenplay.java-go.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
-if(iZone==null){
+if(text==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5778/pattern-ver1-serial/src.main.java.cn.momia.mapi.api.AbstractIndexApi.java-getBanners.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
-if(iZone==null){
+if(savedFields==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5778/pattern-ver1-serial/src.main.java.cn.momia.mapi.api.AbstractIndexApi.java-getBanners.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+resetFields+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/174/pattern-ver1-serial/src.main.java.fr.novia.zaproxyplugin.ZAProxy.java-setUpAuthenticationMethod.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
-message="Cannot parse \""+text+"\": "+message;
+message="Cannot parse \""+resetFields+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/174/pattern-ver1-serial/src.main.java.fr.novia.zaproxyplugin.ZAProxy.java-setUpAuthenticationMethod.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count<0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3672/pattern-ver1-serial/src.edu.miamioh.cse283.htw.Room.java-shoot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count!=0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/71/pattern-ver1-serial/src.edu.stanford.nlp.mt.decoder.feat.base.TranslationModelFeaturizer.java-ruleFeaturize.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
-millis=savedFields[i].set(millis,resetFields);
+millis=savedFields[1].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+return 0;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V18/2131/pattern-ver1-serial/src.nl.dobots.bluenet.extended.structs.BleDeviceList.java-compare.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+return 0;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V18/2131/pattern-ver1-serial/src.nl.dobots.bluenet.extended.structs.BleDeviceList.java-compare.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:14:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
-int count=iSavedFieldsCount;
+Integer count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7237/pattern-ver1-serial/Project.src.main.java.util.AdjacencyList.java-kruskal.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:15:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+if(true){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:15:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
+return 0;
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/5432/pattern-ver1-serial/app.src.main.java.com.rrdevs.peerboard.DBCompare.java-authenticateLogin.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:15:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
+return 0;
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/5432/pattern-ver1-serial/app.src.main.java.com.rrdevs.peerboard.DBCompare.java-authenticateLogin.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:15:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+return 0;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/5432/pattern-ver1-serial/app.src.main.java.com.rrdevs.peerboard.DBCompare.java-authenticateLogin.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:15:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+savedFields+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/1763/pattern-ver1-serial/lealone-common.src.main.java.org.lealone.db.ConnectionInfo.java-setBaseDir.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:15:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
-message="Cannot parse \""+text+"\": "+message;
+message="Cannot parse \""+savedFields+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/1763/pattern-ver1-serial/lealone-common.src.main.java.org.lealone.db.ConnectionInfo.java-setBaseDir.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:15:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+iSavedFields+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/1763/pattern-ver1-serial/lealone-common.src.main.java.org.lealone.db.ConnectionInfo.java-setBaseDir.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:15:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+iSavedFieldsShared+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/1763/pattern-ver1-serial/lealone-common.src.main.java.org.lealone.db.ConnectionInfo.java-setBaseDir.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:15:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+millis+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/1763/pattern-ver1-serial/lealone-common.src.main.java.org.lealone.db.ConnectionInfo.java-setBaseDir.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:15:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0,localLevel;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/1178/pattern-ver1-serial/wrapper.src.main.java.com.ankit.wrapper.Logger.java-w.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:15:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
-return millis;
+return 0;
 }

PATTERN : /home/jiajun/GithubData/2016/V12/5321/pattern-ver1-serial/app.src.main.java.edu.gatech.johndoe.carecoordinator.community.UI.CommunityAdapter.java-compare.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
+iSavedFieldsShared=true;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6486/pattern-ver1-serial/src.noughtsandcrosses.VictoryConditions.java-gameWon.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/3196/pattern-ver1-serial/src.game.Game.java-dealerTurn.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0,iSavedFields;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4714/pattern-ver1-serial/gisWebProject.src.emergencyProcess.FollowUser.java-doPost.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
+millis-=2;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V2/2316/pattern-ver1-serial/TaskScheduler.src.ApplicationWindow.java-actionPerformed.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import java.util.ArrayList;
+
+import com.sun.javafx.scene.control.behavior.KeyBinding;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0;i<count;i++,new ArrayList<KeyBinding>()){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/314/pattern-ver1-serial/src.main.java.jfxtras.labs.internal.scene.control.behavior.SixteenSegmentBehavior.java-SixteenSegmentBehavior.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)>=0.0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/3703/pattern-ver1-serial/Muehle_Master.src.de.dhbw.muehle.model.theme.Sound.java-fade.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)<=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/4156/pattern-ver1-serial/src.eduapp.level.quest.GroupingQuest.java-setResult.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
-long millis=iMillis;
+Long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/3545/pattern-ver1-serial/nifi-nar-bundles.nifi-framework-bundle.nifi-framework.nifi-framework-core.src.main.java.org.apache.nifi.controller.StandardFlowFileQueue.java-summarize.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)>=0&&compareReverse(first,days)>=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6682/pattern-ver1-serial/src.Geometry.Graham_Scan.java-leftTurn.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
+millis-=0.0;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/4063/pattern-ver1-serial/playgrounds.agarwalamit.src.main.java.playground.agarwalamit.mixedTraffic.plots.LinkPersonInfoContainer.java-updateAvailableLinkSpace.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
-return millis;
+return 1;
 }

PATTERN : /home/jiajun/GithubData/2011/V4/7202/pattern-ver1-serial/client.SurvivalGuide.src.ch.ethz.inf.vs.android.g54.a4.ui.TouchImageView.java-getPointerCount.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:16:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0;i<count;millis++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4470/pattern-ver1-serial/core.src.com.esbjon.inventories.Inventory.java-commandTransferTo.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:18:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0;i<count;count++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4470/pattern-ver1-serial/core.src.com.esbjon.inventories.Inventory.java-commandTransferTo.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:20:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
-if(text!=null){
+if(savedFields!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/4918/pattern-ver1-serial/src.org.traccar.protocol.Gl200ProtocolDecoder.java-decode.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:20:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
-if(text!=null){
+if(savedFields!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/4918/pattern-ver1-serial/src.org.traccar.protocol.Gl200ProtocolDecoder.java-decode.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:20:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
-if(text!=null){
+if(iSavedFields!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/4918/pattern-ver1-serial/src.org.traccar.protocol.Gl200ProtocolDecoder.java-decode.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:21:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0,_afterComposeMethodCache;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V6/5922/pattern-ver1-serial/zkbind.src.org.zkoss.bind.BindComposer.java-doAfterCompose.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:21:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
-if(text!=null){
+if(iSavedFields!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V9/1150/pattern-ver1-serial/src.main.java.de.nedelosk.modularmachines.client.gui.GuiAssembler.java-onUpdate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:21:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import java.util.List;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0,mActions;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/428/pattern-ver1-serial/quickaction.src.main.java.com.imallan.quickaction.QuickActionOnTouchListener.java-onDown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:21:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
-return millis;
+return count;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V28/454/pattern-ver1-serial/src.main.java.io.vertx.rxcore.RxSupport.java-call.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:21:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
-millis-=offset;
+millis-=millis;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V33/6978/pattern-ver1-serial/UnionByRankPathCompression.java-union.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:21:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
-millis-=offset;
+millis-=count;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V33/6978/pattern-ver1-serial/UnionByRankPathCompression.java-union.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:21:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
+sort(savedFields,count);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V29/3884/pattern-ver1-serial/TcpChat.src.client.gui.ClientGuiThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:21:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
+sort(savedFields,count);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V29/3884/pattern-ver1-serial/TcpChat.src.client.gui.ClientGuiThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:21:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0,mRelationId;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V16/910/pattern-ver1-serial/app.src.main.java.fr.sims.coachingproject.ui.fragment.RelationChatFragment.java-bindView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:21:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+sort(savedFields,count);
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/5087/pattern-ver1-serial/src.main.java.ch.vorburger.raspberry.turtle.Turtle.java-haltInSeconds.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+sort(savedFields,count);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/5087/pattern-ver1-serial/src.main.java.ch.vorburger.raspberry.turtle.Turtle.java-haltInSeconds.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
+sort(savedFields,count);
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/5087/pattern-ver1-serial/src.main.java.ch.vorburger.raspberry.turtle.Turtle.java-haltInSeconds.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
+sort(savedFields,count);
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/5087/pattern-ver1-serial/src.main.java.ch.vorburger.raspberry.turtle.Turtle.java-haltInSeconds.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
-return millis;
+return computeMillis(false);
 }

PATTERN : /home/jiajun/GithubData/2015/V12/4268/pattern-ver1-serial/library.src.main.java.com.mbientlab.metawear.impl.DefaultMetaWearBoard.java-fromSensor.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
-return millis;
+return this.computeMillis();
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6962/pattern-ver1-serial/CodenameOne.src.com.codename1.ui.Toolbar.java-constructSideNavigationComponent.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ final DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
+ final DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
+ final DurationField months=DurationFieldType.months().getField(iChrono);
+ final DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
-int count=iSavedFieldsCount;
+ final int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ final DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
+ final DurationField days=DurationFieldType.days().getField(iChrono);
+ final DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ final DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
-int offset=iZone.getOffsetFromLocal(millis);
+ final int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/7209/pattern-ver1-serial/bundles.org.eclipse.emf.emfstore.client.ui.src.org.eclipse.emf.emfstore.internal.client.ui.views.historybrowserview.graph.PlotCommitProvider.java-getColorsForBranch.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
+millis-=-1;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
-SavedField[] savedFields=iSavedFields;
+ SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:22:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
-long millis=iMillis;
+ long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
-String message="Illegal instant due to time zone offset transition ("+iZone+')';
+ String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
-int count=iSavedFieldsCount;
+ int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
-SavedField[] savedFields=iSavedFields;
+ SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
+ DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
+ DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
-long millis=iMillis;
+ long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
+ DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
-String message="Illegal instant due to time zone offset transition ("+iZone+')';
+ String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
-int count=iSavedFieldsCount;
+ int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
+ DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
-SavedField[] savedFields=iSavedFields;
+ SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
+ DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
+ DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
-long millis=iMillis;
+ long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
-int count=iSavedFieldsCount;
+ final int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
+ final DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/6331/pattern-ver1-serial/src.java.growthcraft.api.fishtrap.FishTrapEntry.java-getFishable.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+iSavedFields=savedFields=(SavedField[])this.iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V18/4298/pattern-ver1-serial/src.main.java.org.spongepowered.api.service.command.SimpleCommandService.java-getHelp.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
+this.computeMillis();
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:23:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+this.computeMillis();
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+this.computeMillis();
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+this.computeMillis();
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+this.computeMillis();
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+this.computeMillis();
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+this.computeMillis();
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V35/5018/pattern-ver1-serial/app.src.main.java.it.unimi.unimiplaces.presenters.BookmarksPresenter.java-init.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
+count++;
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
+count++;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+if(!iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/5542/pattern-ver1-serial/RedZone.redzone.blocks.Pipe.java-onBlockPlaced.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
+millis++;
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/6147/pattern-ver1-serial/src.system.ResultPathCompare.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+i++;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/868/pattern-ver1-serial/src.main.java.gcommon.objects.NumberFormatter.java-format.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+millis--;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
+millis--;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:24:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+i--;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/965/pattern-ver1-serial/src.Game.java-loop.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:26:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
+count--;
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/965/pattern-ver1-serial/src.Game.java-loop.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:26:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
+synchronized(this){
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
+}
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V20/1267/pattern-ver1-serial/src.main.java.io.vertx.ext.shell.command.impl.ProcessImpl.java-endHandler.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:27:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+return 0l;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
+return 0l;
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/4557/pattern-ver1-serial/src.de.rincewind.api.gui.elements.ElementCounter.java-setCount.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:27:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+synchronized(this){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+}
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V27/3450/pattern-ver1-serial/hbase-server.src.main.java.org.apache.hadoop.hbase.security.visibility.VisibilityController.java-postOpen.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:27:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+synchronized(this){
 iSavedFieldsShared=false;
+}
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V27/3450/pattern-ver1-serial/hbase-server.src.main.java.org.apache.hadoop.hbase.security.visibility.VisibilityController.java-postOpen.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:27:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+synchronized(this){
 millis=savedFields[i].set(millis,resetFields);
+}
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V27/3450/pattern-ver1-serial/hbase-server.src.main.java.org.apache.hadoop.hbase.security.visibility.VisibilityController.java-postOpen.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:27:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+computeMillis(resetFields);
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V21/3252/pattern-ver1-serial/care-reporting.commcare-migration.src.main.java.org.motechproject.care.reporting.migration.task.MigrationTask.java-postToMotech.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:27:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+synchronized(this){
 saveField(DateTimeFieldType.year(),iDefaultYear);
+}
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/6621/pattern-ver1-serial/src.com.qozix.tileview.tiles.TileCache.java-addBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:27:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
+synchronized(this){
 sort(savedFields,count);
+}
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/6621/pattern-ver1-serial/src.com.qozix.tileview.tiles.TileCache.java-addBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:27:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0,continentName,countryCode;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V9/6266/pattern-ver1-serial/app.src.main.java.com.hyperion.dashdroid.radio.RadioListFragment.java-refresh.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:27:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
-return millis;
+return (long)(millis);
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/1621/pattern-ver1-serial/src.lab4.FileService.FileService.java-readFile.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:27:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+return 0l;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+return 0l;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V46/144/pattern-ver1-serial/lettuce.src.main.java.com.lambdaworks.redis.Connections.java-close.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:27:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
+}
+while(true){
+
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:29:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
+}
+while(true){
+
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:30:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+while(true){
+
+}
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:32:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+while(true){
+
+}
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:34:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+while(true){
+
+}
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/177/pattern-ver1-serial/flink-addons.flink-streaming.flink-streaming-core.src.main.java.org.apache.flink.streaming.api.streamvertex.StreamVertex.java-invoke.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+text.toString()+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V3/7313/pattern-ver1-serial/Core.astra.interpreter.src.astra.reasoner.util.ContentCodec.java-test_predicate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
-message="Cannot parse \""+text+"\": "+message;
+message="Cannot parse \""+text.toString()+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V3/7313/pattern-ver1-serial/Core.astra.interpreter.src.astra.reasoner.util.ContentCodec.java-test_predicate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
+synchronized(this){
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
+}
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
+synchronized(this){
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+}
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
+synchronized(this){
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
+}
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+synchronized(this){
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
+}
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+synchronized(this){
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
+}
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V7/3100/pattern-ver1-serial/src.de.uni_koblenz.jgralab.greql.evaluator.GreqlQueryImpl.java-evaluate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import java.nio.charset.Charset;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0;i<count;i++,Charset.forName("UTF-8")){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/3733/pattern-ver1-serial/Code.Part1.src.core.Intraprocedural.java-callgraph.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
-if(iZone==null){
+if(iZone.equals(null)){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/343/pattern-ver1-serial/src.gui.batches.ItemBatchView.java-selectProduct.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
+synchronized(this){
 millis-=iOffset;
+}
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+if(savedFields[i].set(millis,resetFields)!=0){
 millis=savedFields[i].set(millis,resetFields);
+}
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7542/pattern-ver1-serial/gde-backend.src.main.java.com.nagarro.gde.persistence.model.UserSpecialization.java-populateAreaOfSpecialization.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:36:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
+if(iOffset!=0){
 millis-=iOffset;
+}
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/7542/pattern-ver1-serial/gde-backend.src.main.java.com.nagarro.gde.persistence.model.UserSpecialization.java-populateAreaOfSpecialization.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
+sort(savedFields,30-(count));
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/1792/pattern-ver1-serial/rangebar.src.com.appyvet.rangebar.RangeBar.java-onAnimationUpdate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
-int count=iSavedFieldsCount;
+ final int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ final DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
+ final DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3285/pattern-ver1-serial/project.core.src.se.computerscience.kelde.model.entities.EntityBat.java-getHeading.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
-int count=iSavedFieldsCount;
+ final int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ final DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
-int offset=iZone.getOffsetFromLocal(millis);
+ final int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3285/pattern-ver1-serial/project.core.src.se.computerscience.kelde.model.entities.EntityBat.java-getHeading.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
-SavedField[] savedFields=iSavedFields;
+ @SuppressWarnings("UnusedAssignment") SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ @SuppressWarnings("UnusedAssignment") DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
-long millis=iMillis;
+ @SuppressWarnings("UnusedAssignment") long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
-SavedField[] savedFields=iSavedFields;
+ @SuppressWarnings("UnusedAssignment") SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ @SuppressWarnings("UnusedAssignment") DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
-String message="Illegal instant due to time zone offset transition ("+iZone+')';
+ @SuppressWarnings("UnusedAssignment") String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ @SuppressWarnings("UnusedAssignment") DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
-long millis=iMillis;
+ @SuppressWarnings("UnusedAssignment") long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
-String message="Illegal instant due to time zone offset transition ("+iZone+')';
+ @SuppressWarnings("UnusedAssignment") String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
-SavedField[] savedFields=iSavedFields;
-int count=iSavedFieldsCount;
+ @SuppressWarnings("UnusedAssignment") SavedField[] savedFields=iSavedFields;
+ @SuppressWarnings("UnusedAssignment") int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ @SuppressWarnings("UnusedAssignment") DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
-int count=iSavedFieldsCount;
+ @SuppressWarnings("UnusedAssignment") int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ @SuppressWarnings("UnusedAssignment") DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
-long millis=iMillis;
+ @SuppressWarnings("UnusedAssignment") long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
-int count=iSavedFieldsCount;
+ @SuppressWarnings("UnusedAssignment") int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
+ @SuppressWarnings("UnusedAssignment") DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
-String message="Illegal instant due to time zone offset transition ("+iZone+')';
+ @SuppressWarnings("UnusedAssignment") String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
+resetFields=resetFields;
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V31/432/pattern-ver1-serial/src.arcane_arcade_menus.MainMenuMenuCreator.java-MainMenuElement.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
+text=text;
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V31/432/pattern-ver1-serial/src.arcane_arcade_menus.MainMenuMenuCreator.java-MainMenuElement.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:37:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+if(i==4){
+continue;
+}
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/5508/pattern-ver1-serial/common.enhancedportals.item.ItemPortalModifierUpgrade.java-getSubItems.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
-return millis;
+return millis&0xff;
 }

PATTERN : /home/jiajun/GithubData/2015/V16/5603/pattern-ver1-serial/uk.ac.herts.SmartLab.XBee.Response.XBeeRx64Response.java-GetReceiveStatus.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
-if(iZone==null){
+if(true){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(true){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
+if(savedFields[0].iField!=null){
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
+}
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/258/pattern-ver1-serial/web.src.main.java.com.epam.freelancer.web.controller.UserController.java-addIsComplaintInOrderings.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+Arrays.sort(savedFields);
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/5055/pattern-ver1-serial/cli.src.main.java.com.vmware.bdd.cli.commands.ClusterCommands.java-getCluster.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
+Arrays.sort(savedFields);
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/5055/pattern-ver1-serial/cli.src.main.java.com.vmware.bdd.cli.commands.ClusterCommands.java-getCluster.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+if(iSavedFields==null){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+}
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V53/4035/pattern-ver1-serial/whois-client.src.main.java.net.ripe.db.whois.common.rpsl.RpslAttribute.java-extractCleanValueAndComment.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import java.util.Arrays;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
+Arrays.sort(savedFields);
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/405/pattern-ver1-serial/twitter-topic-strand-core.src.main.java.twittertopicstrand.util.FileOperations.java-getFiles.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import java.util.Calendar;
+
+import java.io.Serializable;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
-return millis;
+return millis*1000l;
 }

PATTERN : /home/jiajun/GithubData/2015/V32/5781/pattern-ver1-serial/app.src.main.java.com.badou.mworking.entity.category.CategoryDetail.java-getStartline_c.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
+millis-=0xEfffffff&(iOffset);
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/1711/pattern-ver1-serial/src.main.java.com.ociweb.pronghorn.ring.RingWriter.java-writeBytes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count>0/2){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/7651/pattern-ver1-serial/src.net.vicp.lylab.utils.cache.CacheContainer.java-exec.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+int a=0;
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:38:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+int a=0;
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:39:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+int a=0;
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:39:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
+int a=0;
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:39:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+int a=0;
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:39:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+int a=0;
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:39:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+int a=0;
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:39:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+iSavedFieldsShared=false;
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:39:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+iSavedFieldsShared=false;
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:39:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
+iSavedFieldsShared=false;
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:39:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
+iSavedFieldsShared=false;
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:39:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
+iSavedFieldsShared=false;
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:39:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
+iSavedFieldsShared=false;
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/2616/pattern-ver1-serial/app.src.main.java.com.example.koba.reklappclient.YoutubeFragment.java-disappearPush.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 2, INS : 1, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
-message="Cannot parse \""+text+"\": "+message;
+message=text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V42/222/pattern-ver1-serial/src.com.yuval.aiconnotation.FileSystem.java-saveObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
-message="Cannot parse \""+text+"\": "+message;
+message=resetFields+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V42/222/pattern-ver1-serial/src.com.yuval.aiconnotation.FileSystem.java-saveObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+String OUTSTRING="";
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+String OUTSTRING="";
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+String OUTSTRING="";
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+String OUTSTRING="";
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+String OUTSTRING="";
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+String OUTSTRING="";
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
+String OUTSTRING="";
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(text.isEmpty()){
+return 0l;
+}
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/5856/pattern-ver1-serial/src.main.java.io.aif.associations.builder.ExperimentsConnectionsGraphReducer.java-normalize.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+if(text.isEmpty()){
+return 0l;
+}
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/5856/pattern-ver1-serial/src.main.java.io.aif.associations.builder.ExperimentsConnectionsGraphReducer.java-normalize.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:40:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+if(text.isEmpty()){
+return 0l;
+}
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V3/5856/pattern-ver1-serial/src.main.java.io.aif.associations.builder.ExperimentsConnectionsGraphReducer.java-normalize.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0;i<count;){
+i++;
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/7304/pattern-ver1-serial/vipr-portal.com.iwave.isa.content.src.java.com.emc.sa.service.vipr.file.tasks.IngestUnmanagedFilesystems.java-ingestInChunks.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+if(iSavedFieldsShared&&(iSavedFieldsShared)){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
+int DurationFieldType=5;
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V48/7018/pattern-ver1-serial/app.src.main.java.com.priteshjain.popularmovies.util.EndlessRecyclerOnScrollListener.java-onScrolled.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
+int iChrono=5;
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V48/7018/pattern-ver1-serial/app.src.main.java.com.priteshjain.popularmovies.util.EndlessRecyclerOnScrollListener.java-onScrolled.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+if(iSavedFieldsShared||iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V34/3215/pattern-ver1-serial/src.Output.java-writeAutoC.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
+sort(savedFields,Math.round(count));
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V16/7706/pattern-ver1-serial/pixi.src.main.java.org.openpixi.pixi.diagnostics.methods.ProjectedEnergyDensity.java-initialize.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+iSavedFields=savedFields=null;
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/2637/pattern-ver1-serial/de.bund.bfr.knime.openkrise.views.src.de.bund.bfr.knime.openkrise.views.gisgraphview.GraphSettings.java-GraphSettings.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(Double.isNaN(count)){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V32/1622/pattern-ver1-serial/src.mckay.utilities.staticlibraries.StringMethods.java-getDoubleInScientificNotation.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+if(iSavedFieldsShared&&iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V16/5215/pattern-ver1-serial/src.usask.hci.fastdraw.DrawView.java-changeSelection.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
-for(int i=0;i<count;i++){
+for(int i=0;i<count;Math.abs(i++)){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1979/pattern-ver1-serial/h2o-algos.src.main.java.hex.tree.gbm.GBM.java-map.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(equals(months)){
+return 0l;
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
+if(equals(savedFields)){
+return 0l;
+}
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+if(equals(savedFields)){
+return 0l;
+}
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(equals(days)){
+return 0l;
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+int indexSelection=0;
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
+int indexSelection=0;
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
+int indexSelection=0;
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+int indexSelection=0;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+int indexSelection=0;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+int indexSelection=0;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7667/pattern-ver1-serial/Handyboy.src.com.vallverk.handyboy.view.HandyBoyViewFragment.java-updateJobsContainer.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import java.util.Arrays;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
-millis=savedFields[i].set(millis,resetFields);
+millis=savedFields[i-1].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/7420/pattern-ver1-serial/src.webradio.Show.java-convertArrToString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+this.iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
+millis-=0;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V45/4372/pattern-ver1-serial/src.DataStructures.PriorityQueue.MinPQ.java-MinPQ.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+this.iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
-millis-=offset;
+millis-=0;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V45/4372/pattern-ver1-serial/src.DataStructures.PriorityQueue.MinPQ.java-MinPQ.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
+millis-=millis+iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V18/2052/pattern-ver1-serial/cg.cg.GTSurferMove.java-drawFactor.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
-millis-=offset;
+millis-=millis+offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V18/2052/pattern-ver1-serial/cg.cg.GTSurferMove.java-drawFactor.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+int a=1;
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+int a=1;
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+int a=1;
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
+int a=1;
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+int a=1;
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+int a=1;
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+int a=1;
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V25/7434/pattern-ver1-serial/app.src.main.java.hummingbird.android.mobile_app.views.fragments.LibraryFragmentAdapter.java-onFragmentSelected.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+boolean b=true;
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+boolean b=true;
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+boolean b=true;
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+boolean b=true;
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+boolean b=true;
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
+boolean b=true;
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+boolean b=true;
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V30/6898/pattern-ver1-serial/minijava-compiler-frontend.SamplePrograms.SampleMiniJavaPrograms.QuickSort.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+if(months==null){
+return 0l;
+}
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/grib.src.main.java.ucar.nc2.grib.grib1.tables.NcepHtmlScraper.java-parseTable2.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
+if(days==null){
+return 0l;
+}
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/grib.src.main.java.ucar.nc2.grib.grib1.tables.NcepHtmlScraper.java-parseTable2.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(first==null){
+return 0l;
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/grib.src.main.java.ucar.nc2.grib.grib1.tables.NcepHtmlScraper.java-parseTable2.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
+if(savedFields==null){
+return 0l;
+}
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/2822/pattern-ver1-serial/grib.src.main.java.ucar.nc2.grib.grib1.tables.NcepHtmlScraper.java-parseTable2.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
+Arrays.fill(savedFields,null);
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V26/7483/pattern-ver1-serial/src.edu.stanford.nlp.util.StringUtils.java-mapStringToArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+if(iSavedFields==null){
+return 0l;
+}
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
+if(iSavedFields==null){
+return 0l;
+}
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/3094/pattern-ver1-serial/scribengin.core.src.main.java.com.neverwinterdp.scribengin.storage.hdfs.sink.HDFSSinkPartitionStreamWriter.java-prepareCommit.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
+if(text==null){
+return 0l;
+}
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/886/pattern-ver1-serial/src.com.inovex.zabbixmobile.activities.BaseSeverityFilterActivity.java-onSeveritySelected.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+if(savedFields==null){
+return 0l;
+}
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V60/886/pattern-ver1-serial/src.com.inovex.zabbixmobile.activities.BaseSeverityFilterActivity.java-onSeveritySelected.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(text==null){
+return 0l;
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V45/2972/pattern-ver1-serial/app.src.main.java.com.nealyi.app.activity.UserProfileActivity.java-onActivityResult.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(months==null){
+return 0l;
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V45/2972/pattern-ver1-serial/app.src.main.java.com.nealyi.app.activity.UserProfileActivity.java-onActivityResult.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(days==null){
+return 0l;
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V45/2972/pattern-ver1-serial/app.src.main.java.com.nealyi.app.activity.UserProfileActivity.java-onActivityResult.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if("index".equals(text)){
+return 0;
+}
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+if("index".equals(text)){
+return 0;
+}
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+if("index".equals(text)){
+return 0;
+}
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+if("index".equals(text)){
+return 0;
+}
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if("index".equals(resetFields)){
+return 0;
+}
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+if("index".equals(resetFields)){
+return 0;
+}
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+if("index".equals(resetFields)){
+return 0;
+}
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+if("index".equals(months)){
+return 0;
+}
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+if("index".equals(resetFields)){
+return 0;
+}
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+sort(savedFields,count);
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
+sort(savedFields,count);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
+sort(savedFields,count);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+sort(savedFields,count);
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+sort(savedFields,count);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+sort(savedFields,count);
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
+sort(savedFields,count);
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+sort(savedFields,count);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
+sort(savedFields,count);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
+sort(savedFields,count);
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
+iSavedFieldsShared=false;
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
-if(iZone==null){
 millis-=iOffset;
+if(iZone==null){
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+iSavedFieldsShared=false;
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+iSavedFieldsShared=false;
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+iSavedFieldsShared=false;
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+iSavedFieldsShared=false;
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+millis-=iOffset;
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+iSavedFieldsShared=false;
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V49/5647/pattern-ver1-serial/src.worms.model.statements.Print.java-executeStatement.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
+sort(savedFields,count);
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/2664/pattern-ver1-serial/src.main.java.micdoodle8.mods.galacticraft.planets.asteroids.entities.EntityGrapple.java-EntityGrapple.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
+sort(savedFields,count);
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
+sort(savedFields,count);
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
+sort(savedFields,count);
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+sort(savedFields,count);
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
+sort(savedFields,count);
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
+iSavedFieldsShared=false;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/2094/pattern-ver1-serial/src.main.java.com.dagobert_engine.core.service.UpdateService.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+if(months.equals("-1")){
+return 0l;
+}
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
+if(days.equals("-1")){
+return 0l;
+}
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(first.equals("-1")){
+return 0l;
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
+if(savedFields.equals("-1")){
+return 0l;
+}
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V10/4405/pattern-ver1-serial/src.edu.ucsb.cs.Main.java-editGuardianGivenName.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count>0||count==Long.MIN_VALUE){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V5/7087/pattern-ver1-serial/BDEBase.src.main.java.gr.demokritos.iit.base.util.Utils.java-extractYearMonthDayLiteral.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+if(this.iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
+this.iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/7075/pattern-ver1-serial/mind-map.nb-mind-map.src.main.java.com.igormaznitsa.nbmindmap.nb.MMDGraphEditor.java-componentActivated.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+sort(savedFields,count);
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/4215/pattern-ver1-serial/Mage.Server.src.main.java.mage.server.TableController.java-joinTournament.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
+sort(savedFields,count);
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/4215/pattern-ver1-serial/Mage.Server.src.main.java.mage.server.TableController.java-joinTournament.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
+iSavedFieldsShared=false;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V9/6301/pattern-ver1-serial/app.src.main.java.client.example.sj.pulltoscaleheaderlayout.PullToScaleHeaderLayout.java-computeScroll.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
-}
 sort(savedFields,count);
+}
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
+sort(savedFields,count);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+text.replaceAll("[^\\w\\s]","")+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/547/pattern-ver1-serial/src.main.java.com.driver.locator.pageobject.PageObjectGenerator.java-formatWebElement.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
-message="Cannot parse \""+text+"\": "+message;
+message="Cannot parse \""+text.replaceAll("[^\\w\\s]","")+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/547/pattern-ver1-serial/src.main.java.com.driver.locator.pageobject.PageObjectGenerator.java-formatWebElement.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+text.replace("Cannot parse \"","")+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/2038/pattern-ver1-serial/LabPal.app.src.main.java.danandzach.labpal.LabCalculations.java-setErrorDisplay.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
-message="Cannot parse \""+text+"\": "+message;
+message="Cannot parse \""+text.replace("Cannot parse \"","")+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/2038/pattern-ver1-serial/LabPal.app.src.main.java.danandzach.labpal.LabCalculations.java-setErrorDisplay.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+iSavedFieldsShared=false;
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1875/pattern-ver1-serial/TherapistApp.src.application.Main.java-handle.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
+sort(savedFields,count);
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3904/pattern-ver1-serial/src.heartbeat.TachySyringe.java-Use.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+if(text==null){
+return 0l;
+}
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/4925/pattern-ver1-serial/statemachine-persistence.src.main.java.de.teck.statemachine.persistence.model.TransitionGraph.java-addTransition.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+try{
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+}finally{
 iSavedFieldsShared=false;
+}
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 1, INS : 0, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+assert (text!=null);
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+assert (text!=null);
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+assert (text!=null);
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+assert (months!=null);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V42/2471/pattern-ver1-serial/src.main.java.seedu.taskell.model.task.TaskDate.java-convertMonthIntoInteger.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
+assert (!text.isEmpty());
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+assert (!text.isEmpty());
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
+assert (!text.isEmpty());
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
+assert (!text.isEmpty());
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V33/3866/pattern-ver1-serial/src.SigmaEC.util.Parameters.java-getBooleanParameter.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(text!=null){
+saveField(DateTimeFieldType.year(),iDefaultYear);
+return computeMillis(resetFields,text);
+}
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+if(text!=null){
+DurationField months=DurationFieldType.months().getField(iChrono);
+DurationField days=DurationFieldType.days().getField(iChrono);
+DurationField first=savedFields[0].iField.getDurationField();
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+saveField(DateTimeFieldType.year(),iDefaultYear);
+return computeMillis(resetFields,text);
+}
+}
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
+if(text!=null){
 if(text!=null){
+e.prependMessage("Cannot parse \""+text+'"');
+}
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
+if(text!=null){
+if(text!=null){
+e.prependMessage("Cannot parse \""+text+'"');
+}
+throw e;
+}
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+if(text!=null){
+SavedField[] savedFields=iSavedFields;
+int count=iSavedFieldsCount;
+if(iSavedFieldsShared){
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+iSavedFieldsShared=false;
+}
+sort(savedFields,count);
+if(count>0){
+DurationField months=DurationFieldType.months().getField(iChrono);
+DurationField days=DurationFieldType.days().getField(iChrono);
+DurationField first=savedFields[0].iField.getDurationField();
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+saveField(DateTimeFieldType.year(),iDefaultYear);
+return computeMillis(resetFields,text);
+}
+}
+long millis=iMillis;
+try{
+for(int i=0;i<count;i++){
+millis=savedFields[i].set(millis,resetFields);
+}
+}catch(IllegalFieldValueException e){
+if(text!=null){
+e.prependMessage("Cannot parse \""+text+'"');
+}
+throw e;
+}
+if(iZone==null){
+millis-=iOffset;
+}else {
+int offset=iZone.getOffsetFromLocal(millis);
+millis-=offset;
+if(offset!=iZone.getOffset(millis)){
+String message="Illegal instant due to time zone offset transition ("+iZone+')';
+if(text!=null){
+message="Cannot parse \""+text+"\": "+message;
+}
+throw new IllegalArgumentException(message);
+}
+}
+return millis;
+}
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V8/384/pattern-ver1-serial/app.src.main.java.com.farfromsober.ffs.activities.LoginActivity.java-onDataParsed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+if(millis==0){
+return 0l;
+}
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+}
+if(millis==0){
+return 0l;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
+}
+if(millis==0){
+return 0l;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+if(millis==0){
+return 0l;
+}
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+assert (months!=DurationFieldType.months().getField(iChrono));
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
+assert (days!=DurationFieldType.days().getField(iChrono));
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+assert (first!=savedFields[0].iField.getDurationField());
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
+assert (savedFields!=iSavedFields);
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
+assert (count!=iSavedFieldsCount);
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
+assert (millis!=iMillis);
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/3232/pattern-ver1-serial/src.main.java.com.about.java.controllers.MainController.java-mainpage.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+assert (savedFields!=null);
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V33/4564/pattern-ver1-serial/app.src.main.java.com.squirrel.justrread.api.RedditAPI.java-checkIfSubscribed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+assert (savedFields!=null);
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V33/4564/pattern-ver1-serial/app.src.main.java.com.squirrel.justrread.api.RedditAPI.java-checkIfSubscribed.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
+millis-=-1;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
+millis++;
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
+millis-=-1;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
+millis++;
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1212/pattern-ver1-serial/src.main.java.com.sk89q.mclauncher.update.Updater.java-downloadFiles.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 2, INS : 2, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+assert (text!=null);
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V28/126/pattern-ver1-serial/main.table.org.gamegineer.table.core.src.org.gamegineer.table.core.ComponentPath.java-compareTo.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
+assert (text!=null);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
+assert (text!=null);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
+assert (text!=null);
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
+assert (text!=null);
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+assert (text!=null);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
+assert (text!=null);
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
+assert (text!=null);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4812/pattern-ver1-serial/graal.com.oracle.graal.nodes.src.com.oracle.graal.nodes.calc.IsNullNode.java-IsNullNode.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(months.equals("655")){
+System.out.println();
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3726/pattern-ver1-serial/src.protosocket.client.WriteThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(days.equals("655")){
+System.out.println();
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3726/pattern-ver1-serial/src.protosocket.client.WriteThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(first.equals("655")){
+System.out.println();
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3726/pattern-ver1-serial/src.protosocket.client.WriteThread.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 4, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
-if(iZone==null){
+if(iZone==null||"查看红包".equals(iZone)){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count>0||"查看红包".equals(count)){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count>0||count==3){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/1380/pattern-ver1-serial/Cluedo.src.control.Player.java-validMove.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+saveField(DateTimeFieldType.year(),iDefaultYear);
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+saveField(DateTimeFieldType.year(),iDefaultYear);
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+saveField(DateTimeFieldType.year(),iDefaultYear);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
+saveField(DateTimeFieldType.year(),iDefaultYear);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+saveField(DateTimeFieldType.year(),iDefaultYear);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+saveField(DateTimeFieldType.year(),iDefaultYear);
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+saveField(DateTimeFieldType.year(),iDefaultYear);
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
+saveField(DateTimeFieldType.year(),iDefaultYear);
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
+if(text.isEmpty()){
+text=null;
+}
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+if(text.isEmpty()){
+text=null;
+}
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
+if(text.isEmpty()){
+text=null;
+}
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
+if(text.isEmpty()){
+text=null;
+}
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
+if(text.isEmpty()){
+text=null;
+}
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
+}
+if(text.isEmpty()){
+text=null;
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
+if(text.isEmpty()){
+text=null;
+}
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
+if(text.isEmpty()){
+text=null;
+}
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/4117/pattern-ver1-serial/src.main.java.es.uvigo.esei.compi.gui.SwingDemo.java-compiExecution.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count<0||count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1602/pattern-ver1-serial/src.engine.network.server.ServerClient.java-knowMap.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+saveField(DateTimeFieldType.year(),iDefaultYear);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6349/pattern-ver1-serial/src.com.example.smartphone.SelectECActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
+saveField(DateTimeFieldType.year(),iDefaultYear);
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6349/pattern-ver1-serial/src.com.example.smartphone.SelectECActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
+saveField(DateTimeFieldType.year(),iDefaultYear);
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6349/pattern-ver1-serial/src.com.example.smartphone.SelectECActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+saveField(DateTimeFieldType.year(),iDefaultYear);
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/3128/pattern-ver1-serial/src.cubicmadness.gamestates.GameStateManager.java-popCurrentState.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+saveField(DateTimeFieldType.year(),iDefaultYear);
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/3128/pattern-ver1-serial/src.cubicmadness.gamestates.GameStateManager.java-popCurrentState.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+saveField(DateTimeFieldType.year(),iDefaultYear);
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/3128/pattern-ver1-serial/src.cubicmadness.gamestates.GameStateManager.java-popCurrentState.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)>=0&&compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V34/1272/pattern-ver1-serial/rest-provider.src.main.java.org.jboss.pressgang.ccms.proxy.RESTCSRelatedNodeV1ProxyHandler.java-internalInvoke.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+saveField(DateTimeFieldType.year(),iDefaultYear);
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if((compareReverse(first,months)>=0||compareReverse(first,months)=='\'')&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/6625/pattern-ver1-serial/src.com.google.javascript.jscomp.CodeConsumer.java-add.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count>0||count==0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1056/pattern-ver1-serial/lts-admin.src.main.java.com.github.ltsopensource.admin.web.api.SuspendJobQueueApi.java-suspendJobRecovery.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count>0||count>9){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2964/pattern-ver1-serial/main.plugins.org.talend.dataquality.sampling.src.main.java.org.talend.dataquality.datamasking.FunctionApplier.java-generateDuplicate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+text+'"'+" -u "+text);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V38/5800/pattern-ver1-serial/tools.gsissh.src.main.java.org.apache.airavata.gsi.ssh.api.job.SlurmJobConfiguration.java-getJobIdMonitorCommand.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+text+'"'+" -u "+resetFields);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V38/5800/pattern-ver1-serial/tools.gsissh.src.main.java.org.apache.airavata.gsi.ssh.api.job.SlurmJobConfiguration.java-getJobIdMonitorCommand.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+text+'"'+" -u "+savedFields);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V38/5800/pattern-ver1-serial/tools.gsissh.src.main.java.org.apache.airavata.gsi.ssh.api.job.SlurmJobConfiguration.java-getJobIdMonitorCommand.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+text+'"'+" -u "+count);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V38/5800/pattern-ver1-serial/tools.gsissh.src.main.java.org.apache.airavata.gsi.ssh.api.job.SlurmJobConfiguration.java-getJobIdMonitorCommand.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+text+'"'+" -u "+millis);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V38/5800/pattern-ver1-serial/tools.gsissh.src.main.java.org.apache.airavata.gsi.ssh.api.job.SlurmJobConfiguration.java-getJobIdMonitorCommand.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
+saveField(DateTimeFieldType.year(),iDefaultYear);
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+saveField(DateTimeFieldType.year(),iDefaultYear);
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V49/3822/pattern-ver1-serial/app.src.main.java.com.peprally.jeremy.peprally.activities.ProfileActivity.java-SetupNewUserProfile.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count>0&&count<4000000){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V28/46/pattern-ver1-serial/raw.master.registryKit.registryKit.registryKit.src.main.java.com.registryKit.survey.surveyManager.java-saveSurveyDocument.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+iSavedFields=null;
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V19/2637/pattern-ver1-serial/de.bund.bfr.knime.openkrise.views.src.de.bund.bfr.knime.openkrise.views.gisgraphview.GraphSettings.java-GraphSettings.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+saveField(DateTimeFieldType.year(),iDefaultYear);
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V39/1103/pattern-ver1-serial/Graphs.src.com.jmga.graphs.classes.GView.java-update.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
+saveField(DateTimeFieldType.year(),iDefaultYear);
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V39/1103/pattern-ver1-serial/Graphs.src.com.jmga.graphs.classes.GView.java-update.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+saveField(DateTimeFieldType.year(),iDefaultYear);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V39/1103/pattern-ver1-serial/Graphs.src.com.jmga.graphs.classes.GView.java-update.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+saveField(DateTimeFieldType.year(),iDefaultYear);
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V39/1103/pattern-ver1-serial/Graphs.src.com.jmga.graphs.classes.GView.java-update.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
+saveField(DateTimeFieldType.year(),iDefaultYear);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V39/1103/pattern-ver1-serial/Graphs.src.com.jmga.graphs.classes.GView.java-update.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
-if(iZone==null){
+if(iZone==null||iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/4704/pattern-ver1-serial/src.main.java.com.alibaba.fastjson.parser.ParserConfig.java-createJavaBeanDeserializer.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
+if(millis<=0){
+return -1;
+}
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
+}
 }
+if(millis<=0){
+return -1;
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(count>0&&count!=9999){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5798/pattern-ver1-serial/SONPlugin.src.org.workcraft.plugins.son.granularity.HourMins.java-getHour.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
+if(0>0&&count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V30/553/pattern-ver1-serial/src.main.java.edu.berkeley.cs.nlp.ocular.main.TrainFont.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+iSavedFields=savedFields;
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V29/7874/pattern-ver1-serial/jmetal-algorithm.src.main.java.org.uma.jmetal.algorithm.singleobjective.particleswarmoptimization.StandardPSO2007.java-StandardPSO2007.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
+saveField(DateTimeFieldType.year(),iDefaultYear);
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/5656/pattern-ver1-serial/Project1.src.com.example.project1.EditTextModified.java-onSelectionChanged.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
+saveField(DateTimeFieldType.year(),iDefaultYear);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/5656/pattern-ver1-serial/Project1.src.com.example.project1.EditTextModified.java-onSelectionChanged.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
+saveField(DateTimeFieldType.year(),iDefaultYear);
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/5656/pattern-ver1-serial/Project1.src.com.example.project1.EditTextModified.java-onSelectionChanged.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 1, DEL : 4
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if((compareReverse(first,months)>=0)&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/4601/pattern-ver1-serial/core.src.by.matveev.rorty.entities.Robot.java-updateControlState.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+JOptionPane.showMessageDialog(null,"Uspješno ste odjavljeni sa sistema!","Info",JOptionPane.INFORMATION_MESSAGE);
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/3046/pattern-ver1-serial/Projekat.iTravel.src.main.java.ba.unsa.etf.si.app.iTravel.Forms.Meni.java-OdjaviSe.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+assert (text!=null):"Appointments day is not allowed to be null!";
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
+assert (text!=null):"Appointments day is not allowed to be null!";
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
+assert (text!=null):"Appointments day is not allowed to be null!";
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
+assert (text!=null):"Appointments day is not allowed to be null!";
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+assert (text!=null):"Appointments day is not allowed to be null!";
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
+assert (text!=null):"Appointments day is not allowed to be null!";
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+assert (text!=null):"Appointments day is not allowed to be null!";
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+assert (text!=null):"Appointments day is not allowed to be null!";
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/3408/pattern-ver1-serial/tutorfinder.src.main.java.ch.unibe.ese.Tutorfinder.model.Appointment.java-setDay.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
+if(text.isEmpty()){
+throw new IllegalArgumentException("Title must not be empty!");
+}
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/1109/pattern-ver1-serial/eclipse.src.stoberry.dataManagement.Management.java-sendMessage.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
+if(text.isEmpty()){
+throw new IllegalArgumentException("Title must not be empty!");
+}
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/1109/pattern-ver1-serial/eclipse.src.stoberry.dataManagement.Management.java-sendMessage.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
-millis=savedFields[i].set(millis,resetFields);
+millis=savedFields[i].set(millis,resetFields)+1;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2011/V1/5032/pattern-ver1-serial/mapreduce.src.contrib.streaming.src.java.org.wikimedia.wikihadoop.StreamWikiDumpInputFormat.java-MyRecordReader.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
+}
+if(millis>7){
+throw new RuntimeException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+if(iChrono==null){
+throw new IllegalStateException("Cannot instantiate Page whitout String url constructor parameter or @PageURL class annotation");
+}
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4732/pattern-ver1-serial/src.main.java.com.mgiorda.page.AbstractPage.java-AbstractPage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+if(iChrono==null){
+throw new IllegalStateException("Cannot instantiate Page whitout String url constructor parameter or @PageURL class annotation");
+}
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4732/pattern-ver1-serial/src.main.java.com.mgiorda.page.AbstractPage.java-AbstractPage.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+if(millis<0){
+millis=0;
+}
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+}
+if(millis<0){
+millis=0;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
+}
+if(millis<0){
+millis=0;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+if(millis<0){
+millis=0;
+}
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+if(iSavedFieldsShared!=false){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
+}
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/529/pattern-ver1-serial/src.com.crankcode.threads.MediaThread.java-end.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 3, INS : 0, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+}
+if(count<=0){
+count=1;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/1761/pattern-ver1-serial/JazminServer.src.jazmin.core.monitor.DispatcherMonitorAgent.java-sample.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+boolean haveBreadCrumbs=false;
+if(iSavedFieldsShared&&haveBreadCrumbs){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 3, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage("Cannot parse \""+"\""+text+"\""+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4748/pattern-ver1-serial/exportLibraries.vnxe.src.main.java.com.emc.storageos.vnxe.requests.FileSystemListRequest.java-getByFSName.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
-message="Cannot parse \""+text+"\": "+message;
+message="Cannot parse \""+"\""+text+"\""+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V31/4748/pattern-ver1-serial/exportLibraries.vnxe.src.main.java.com.emc.storageos.vnxe.requests.FileSystemListRequest.java-getByFSName.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
+millis-=iOffset*2;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
-millis-=offset;
+millis-=offset*2;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V48/1126/pattern-ver1-serial/src.game.renderer.Position.java-translate.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
-millis-=iOffset;
-}else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
+if(offset!=iZone.getOffset(millis)){
+String message="Illegal instant due to time zone offset transition ("+iZone+')';
+if(text!=null){
+message="Cannot parse \""+text+"\": "+message;
+}
+throw new IllegalArgumentException(message);
+}
+}else {
+int offset=iZone.getOffsetFromLocal(millis);
+millis-=iOffset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5622/pattern-ver1-serial/src.main.java.com.github.randoapp.adapter.RandoPairsAdapter.java-initData.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
+sort(savedFields,count-1);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
+saveField(DateTimeFieldType.year(),iDefaultYear-1);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/7554/pattern-ver1-serial/src.rush.hour.Board.java-getGoalTiles.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
+sort(savedFields,count-1);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/7554/pattern-ver1-serial/src.rush.hour.Board.java-getGoalTiles.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
+int offset=iZone.getOffsetFromLocal(millis);
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
-int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2011/V5/1113/pattern-ver1-serial/src.main.java.org.encog.neural.neat.training.NEATTraining.java-crossover.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
-if(iZone==null){
+if(iZone==null&&!iZone.equals("")){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/6260/pattern-ver1-serial/Client.src.com.way.chat.activity.ChatActivity.java-onItemClick.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+if(iSavedFields!=null){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
+}
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V24/3931/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.fetch.OFetchHelper.java-fetchCollectionRidMap.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 3, INS : 0, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+synchronized(this){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
+}
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+DurationField months=DurationFieldType.months().getField(iChrono);
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 0, INS : 1, DEL : 6
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+DurationField days=DurationFieldType.days().getField(iChrono);
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 0, INS : 1, DEL : 6
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(first==null){
+throw new IllegalStateException("User isn't registered! "+savedFields);
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V15/5393/pattern-ver1-serial/peergos.user.UserContext.java-sendFollowRequest.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/6741/pattern-ver1-serial/core.src.main.java.org.jahia.modules.external.ExternalSessionImpl.java-move.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/6741/pattern-ver1-serial/core.src.main.java.org.jahia.modules.external.ExternalSessionImpl.java-move.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V23/6741/pattern-ver1-serial/core.src.main.java.org.jahia.modules.external.ExternalSessionImpl.java-move.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V27/1794/pattern-ver1-serial/src.com.olympicat.scheduleupdates.DataFactory.java-loadData.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6349/pattern-ver1-serial/src.com.example.smartphone.SelectECActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2749/pattern-ver1-serial/src.org.opencms.importexport.CmsImportVersion7.java-addAccessControlEntry.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+if(iSavedFieldsShared){
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/2094/pattern-ver1-serial/src.main.java.com.dagobert_engine.core.service.UpdateService.java-run.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
+e.prependMessage("Cannot parse \""+text+'"');
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/7429/pattern-ver1-serial/library.src.main.java.com.datatorrent.lib.appdata.qr.processor.AbstractWEQueryQueueManager.java-enqueueHelper.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
+e.prependMessage("Cannot parse \""+text+'"');
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/7429/pattern-ver1-serial/library.src.main.java.com.datatorrent.lib.appdata.qr.processor.AbstractWEQueryQueueManager.java-enqueueHelper.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
+e.prependMessage("Cannot parse \""+text+'"');
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+String message="Illegal instant due to time zone offset transition ("+iZone+')';
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
-String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+String message="Illegal instant due to time zone offset transition ("+iZone+')';
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
-String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1875/pattern-ver1-serial/TherapistApp.src.application.Main.java-handle.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+ final String dropStatement="Cannot parse \""+text+'"';
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage(dropStatement);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6019/pattern-ver1-serial/src.main.java.nz.co.gregs.dbvolution.internal.h2.MultiPoint2DFunctions.java-add.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 5, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(text.startsWith("\r\n")){
+text=text.substring(2);
+}
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+if(text.startsWith("\r\n")){
+text=text.substring(2);
+}
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
+if(text.startsWith("\r\n")){
+text=text.substring(2);
+}
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+if(text.startsWith("\r\n")){
+text=text.substring(2);
+}
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+if(text.startsWith("\r\n")){
+text=text.substring(2);
+}
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7437/pattern-ver1-serial/distributed.src.main.java.com.orientechnologies.orient.server.distributed.impl.task.OSyncDatabaseTask.java-onMessage.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
+try{
 sort(savedFields,count);
+}finally{
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+}
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 1, INS : 0, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+try{
 iSavedFieldsShared=false;
+}finally{
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+}
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 1, INS : 0, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+String loc="Cannot parse \""+text+'"';
+e.prependMessage(loc);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/5610/pattern-ver1-serial/app.src.main.java.com.toddburgessmedia.stackoverflowretrofit.MeetupActivity.java-onNext.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 5, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
+String loc="Cannot parse \""+text+'"';
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage(loc);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/5610/pattern-ver1-serial/app.src.main.java.com.toddburgessmedia.stackoverflowretrofit.MeetupActivity.java-onNext.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 5, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+String loc="Cannot parse \""+text+'"';
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
+e.prependMessage(loc);
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/5610/pattern-ver1-serial/app.src.main.java.com.toddburgessmedia.stackoverflowretrofit.MeetupActivity.java-onNext.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 5, INS : 3, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
+}
+if(text.startsWith("/")){
+text=text.substring(1);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V47/2604/pattern-ver1-serial/components.data-services.org.wso2.carbon.dataservices.core.src.main.java.org.wso2.carbon.dataservices.core.DBDeployer.java-createAxisOperation.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
+}
+if(text.startsWith("/")){
+text=text.substring(1);
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V47/2604/pattern-ver1-serial/components.data-services.org.wso2.carbon.dataservices.core.src.main.java.org.wso2.carbon.dataservices.core.DBDeployer.java-createAxisOperation.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
+String message="Illegal instant due to time zone offset transition ("+iZone+')';
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
-String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2011/V5/1113/pattern-ver1-serial/src.main.java.org.encog.neural.neat.training.NEATTraining.java-crossover.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+boolean haveBreadCrumbs=false;
+if(iSavedFieldsShared&&haveBreadCrumbs){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
+haveBreadCrumbs=true;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+boolean haveBreadCrumbs=false;
+if(iSavedFieldsShared&&haveBreadCrumbs){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
+haveBreadCrumbs=true;
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+boolean haveBreadCrumbs=false;
+if(iSavedFieldsShared&&haveBreadCrumbs){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
+haveBreadCrumbs=true;
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+boolean haveBreadCrumbs=false;
+if(iSavedFieldsShared&&haveBreadCrumbs){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
+haveBreadCrumbs=true;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+boolean haveBreadCrumbs=false;
+if(iSavedFieldsShared&&haveBreadCrumbs){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
+haveBreadCrumbs=true;
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
-if(iSavedFieldsShared){
+boolean haveBreadCrumbs=false;
+if(iSavedFieldsShared&&haveBreadCrumbs){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
+haveBreadCrumbs=true;
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+if(!iSavedFieldsShared){
 iSavedFieldsShared=false;
+}
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V37/918/pattern-ver1-serial/src.com.isrtk.nihtfti.MainService.java-onStartCommand.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 2, INS : 0, DEL : 7
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(months==null||first==null){
+throw new NullPointerException();
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(first==null||months==null){
+throw new NullPointerException();
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2177/pattern-ver1-serial/projects.core.src.main.java.org.quick.core.prop.DefaultExpressionContext.java-withFunction.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 9, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+synchronized(this){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+}
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
-if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
+if(text!=null){
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/5994/pattern-ver1-serial/repository.src.org.pentaho.platform.repository2.unified.webservices.RepositoryFileTreeAdapter.java-RepositoryFileTreeAdapter.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
+if(text.endsWith("/")==false){
+text=text+"/";
+}
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V37/627/pattern-ver1-serial/src.main.java.com.thunder.util.Util.java-restMap.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0||"查看红包".equals(compareReverse(first,months)>=0)){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0||compareReverse(first,days)=='%'){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V5/6049/pattern-ver1-serial/src.main.java.org.wltea.analyzer.core.LaTeXSegmenter.java-addOperatorFormula.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)<0L||(compareReverse(first,months)>=0&&compareReverse(first,days)<=0)){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V8/110/pattern-ver1-serial/src.com.firebirdberlin.nightdream.ui.NightDreamUI.java-updateWeatherData.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
+if(text!=null){
+e.prependMessage("Cannot parse \""+text+'"');
+}
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 0, INS : 1, DEL : 10
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(true){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0&&iSavedFieldsShared){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2749/pattern-ver1-serial/Stuyablo.java-combat.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0==false){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3764/pattern-ver1-serial/uDig.org.locationtech.udig.processingtoolbox.src.org.locationtech.udig.processingtoolbox.tools.TextfileToPointDialog.java-getTextColumns.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V26/5667/pattern-ver1-serial/src.AccessorBean.java-onPageLoaded.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 8, INS : 0, DEL : 3
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)>=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V9/573/pattern-ver1-serial/src.CollisionDetection.java-detection.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(iSavedFieldsShared&&(compareReverse(first,months)>=0&&compareReverse(first,days)<=0)){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V13/270/pattern-ver1-serial/modules.lang-painless.src.main.java.org.elasticsearch.painless.AnalyzerExternal.java-processExtvar.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0==true){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V1/1922/pattern-ver1-serial/app.src.main.java.ch.hsr.edu.sinv_56082.gastroginiapp.ui.activities.menu.ProductListListEditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
+if(text!=null){
+message="Cannot parse \""+text+"\": "+message;
+}
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
+long startTime=System.currentTimeMillis();
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
+long startTime=System.currentTimeMillis();
 millis=savedFields[i].set(millis,resetFields);
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
+long startTime=System.currentTimeMillis();
 millis-=iOffset;
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
+long startTime=System.currentTimeMillis();
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+long startTime=System.currentTimeMillis();
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
+long startTime=System.currentTimeMillis();
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
+long endTime=System.currentTimeMillis();
+long totalTime=endTime-startTime;
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5668/pattern-ver1-serial/Euler.src.Euler20.java-main.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 13, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
+saveField(DateTimeFieldType.year(),iDefaultYear);
+return computeMillis(resetFields,text);
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
-return computeMillis(resetFields,text);
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+iSavedFieldsShared=false;
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/3709/pattern-ver1-serial/src.main.java.jfxtras.labs.scene.layout.GridPane.java-apply.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 17, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
+if("Cannot parse \""+text+'"'!=null){
 sort(savedFields,count);
+}
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V5/1328/pattern-ver1-serial/controllersvc.src.main.java.com.emc.storageos.volumecontroller.impl.xtremio.XtremIOSnapshotOperations.java-createGroupSnapshots.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 3, INS : 0, DEL : 14
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+saveField(DateTimeFieldType.year(),iDefaultYear);
+return computeMillis(resetFields,text);
+}
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/3655/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.placement.RecoverPointScheduler.java-scheduleStorageSourcePoolConstraint.pattern
MATCHLEVEL : ALL
ALL : 19, UPD : 0, INS : 1, DEL : 18
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+if(DurationFieldType.months()!=null){
 DurationField months=DurationFieldType.months().getField(iChrono);
+}
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
-return computeMillis(resetFields,text);
-}
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/258/pattern-ver1-serial/web.src.main.java.com.epam.freelancer.web.controller.UserController.java-addIsComplaintInOrderings.pattern
MATCHLEVEL : ALL
ALL : 21, UPD : 3, INS : 0, DEL : 18
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
+if(DurationFieldType.days()!=null){
 DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
-return computeMillis(resetFields,text);
 }
+DurationField first=savedFields[0].iField.getDurationField();
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V19/258/pattern-ver1-serial/web.src.main.java.com.epam.freelancer.web.controller.UserController.java-addIsComplaintInOrderings.pattern
MATCHLEVEL : ALL
ALL : 21, UPD : 3, INS : 0, DEL : 18
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
-if(offset!=iZone.getOffset(millis)){
-String message="Illegal instant due to time zone offset transition ("+iZone+')';
-if(text!=null){
-message="Cannot parse \""+text+"\": "+message;
-}
-throw new IllegalArgumentException(message);
-}
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 26, UPD : 0, INS : 0, DEL : 26
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
+if(offset!=iZone.getOffset(millis)){
+String message="Illegal instant due to time zone offset transition ("+iZone+')';
+if(text!=null){
+message="Cannot parse \""+text+"\": "+message;
+}
+throw new IllegalArgumentException(message);
+}
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V11/3655/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.placement.RecoverPointScheduler.java-scheduleStorageSourcePoolConstraint.pattern
MATCHLEVEL : ALL
ALL : 27, UPD : 0, INS : 1, DEL : 26
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
+String message="Illegal instant due to time zone offset transition ("+iZone+')';
+if(text!=null){
+message="Cannot parse \""+text+"\": "+message;
+}
+throw new IllegalArgumentException(message);
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
-String message="Illegal instant due to time zone offset transition ("+iZone+')';
-if(text!=null){
-message="Cannot parse \""+text+"\": "+message;
-}
-throw new IllegalArgumentException(message);
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+iSavedFieldsShared=false;
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/3709/pattern-ver1-serial/src.main.java.jfxtras.labs.scene.layout.GridPane.java-apply.pattern
MATCHLEVEL : ALL
ALL : 31, UPD : 31, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
-int offset=iZone.getOffsetFromLocal(millis);
-millis-=offset;
-if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
-}
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/2602/pattern-ver1-serial/src.com.github.norbo11.game.poker.PokerPlayer.java-bet.pattern
MATCHLEVEL : ALL
ALL : 34, UPD : 34, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
+synchronized(this){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
+}
 }
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 36, UPD : 36, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
+}else {
+saveField(DateTimeFieldType.year(),iDefaultYear);
+return computeMillis(resetFields,text);
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/2602/pattern-ver1-serial/src.com.github.norbo11.game.poker.PokerPlayer.java-bet.pattern
MATCHLEVEL : ALL
ALL : 36, UPD : 36, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
 if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
-}
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2729/pattern-ver1-serial/Spykes.CloudVision.app.src.main.java.inovation.lab.cloudvision.Speech.java-onInit.pattern
MATCHLEVEL : ALL
ALL : 36, UPD : 36, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
-return computeMillis(resetFields,text);
-}
-}
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4121/pattern-ver1-serial/main.plugins.org.talend.dataprofiler.core.src.org.talend.dataprofiler.core.ImageLib.java-getImageNameByRepositoryNode.pattern
MATCHLEVEL : ALL
ALL : 39, UPD : 0, INS : 0, DEL : 39
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+long millis=iMillis;
+try{
+for(int i=0;i<count;i++){
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
-long millis=iMillis;
-try{
-for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 40, UPD : 0, INS : 1, DEL : 39
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+long millis=iMillis;
+try{
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
-long millis=iMillis;
-try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 40, UPD : 0, INS : 1, DEL : 39
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+long millis=iMillis;
+try{
+for(int i=0;i<count;i++){
+millis=savedFields[i].set(millis,resetFields);
+}
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
-}
 }
-long millis=iMillis;
-try{
-for(int i=0;i<count;i++){
-millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/5429/pattern-ver1-serial/src.com.github.dreamrec.edf.EdfWriter.java-onDataReceived.pattern
MATCHLEVEL : ALL
ALL : 40, UPD : 0, INS : 1, DEL : 39
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
-return computeMillis(resetFields,text);
-}
-}
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
+if(count>0){
+DurationField months=DurationFieldType.months().getField(iChrono);
+DurationField days=DurationFieldType.days().getField(iChrono);
+DurationField first=savedFields[0].iField.getDurationField();
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+saveField(DateTimeFieldType.year(),iDefaultYear);
+return computeMillis(resetFields,text);
+}
+}
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/5429/pattern-ver1-serial/src.com.github.dreamrec.edf.EdfWriter.java-onDataReceived.pattern
MATCHLEVEL : ALL
ALL : 40, UPD : 0, INS : 1, DEL : 39
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
-}
-sort(savedFields,count);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
+}
 }
 }
+sort(savedFields,count);
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/5429/pattern-ver1-serial/src.com.github.dreamrec.edf.EdfWriter.java-onDataReceived.pattern
MATCHLEVEL : ALL
ALL : 40, UPD : 0, INS : 1, DEL : 39
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
-return computeMillis(resetFields,text);
-}
-}
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
+}
+if(count>0){
+DurationField months=DurationFieldType.months().getField(iChrono);
+DurationField days=DurationFieldType.days().getField(iChrono);
+DurationField first=savedFields[0].iField.getDurationField();
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+saveField(DateTimeFieldType.year(),iDefaultYear);
+return computeMillis(resetFields,text);
+}
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/5429/pattern-ver1-serial/src.com.github.dreamrec.edf.EdfWriter.java-onDataReceived.pattern
MATCHLEVEL : ALL
ALL : 40, UPD : 0, INS : 1, DEL : 39
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+long millis=iMillis;
+try{
+for(int i=0;i<count;i++){
+millis=savedFields[i].set(millis,resetFields);
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
 }
 }
-long millis=iMillis;
-try{
-for(int i=0;i<count;i++){
-millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/5429/pattern-ver1-serial/src.com.github.dreamrec.edf.EdfWriter.java-onDataReceived.pattern
MATCHLEVEL : ALL
ALL : 40, UPD : 0, INS : 1, DEL : 39
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
+long millis=iMillis;
+try{
+for(int i=0;i<count;i++){
+millis=savedFields[i].set(millis,resetFields);
+}
+}catch(IllegalFieldValueException e){
+if(text!=null){
+e.prependMessage("Cannot parse \""+text+'"');
 if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
-}
 }
-long millis=iMillis;
-try{
-for(int i=0;i<count;i++){
-millis=savedFields[i].set(millis,resetFields);
 }
-}catch(IllegalFieldValueException e){
-if(text!=null){
-e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/5429/pattern-ver1-serial/src.com.github.dreamrec.edf.EdfWriter.java-onDataReceived.pattern
MATCHLEVEL : ALL
ALL : 40, UPD : 0, INS : 1, DEL : 39
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
-return computeMillis(resetFields,text);
-}
-}
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
+if(count>0){
+DurationField months=DurationFieldType.months().getField(iChrono);
+DurationField days=DurationFieldType.days().getField(iChrono);
+DurationField first=savedFields[0].iField.getDurationField();
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+saveField(DateTimeFieldType.year(),iDefaultYear);
+return computeMillis(resetFields,text);
+}
+}
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/5429/pattern-ver1-serial/src.com.github.dreamrec.edf.EdfWriter.java-onDataReceived.pattern
MATCHLEVEL : ALL
ALL : 40, UPD : 0, INS : 1, DEL : 39
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
 iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
 iSavedFieldsShared=false;
 }
 sort(savedFields,count);
-if(count>0){
-DurationField months=DurationFieldType.months().getField(iChrono);
-DurationField days=DurationFieldType.days().getField(iChrono);
-DurationField first=savedFields[0].iField.getDurationField();
-if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
-saveField(DateTimeFieldType.year(),iDefaultYear);
-return computeMillis(resetFields,text);
-}
-}
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
+if(count>0){
+DurationField months=DurationFieldType.months().getField(iChrono);
+DurationField days=DurationFieldType.days().getField(iChrono);
+DurationField first=savedFields[0].iField.getDurationField();
+if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
+saveField(DateTimeFieldType.year(),iDefaultYear);
+return computeMillis(resetFields,text);
+}
+}
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V35/5429/pattern-ver1-serial/src.com.github.dreamrec.edf.EdfWriter.java-onDataReceived.pattern
MATCHLEVEL : ALL
ALL : 40, UPD : 0, INS : 1, DEL : 39
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/time/time_26_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java[321,378]
------------Candidate---------------
 public long computeMillis(boolean resetFields,String text){
 SavedField[] savedFields=iSavedFields;
 int count=iSavedFieldsCount;
 if(iSavedFieldsShared){
-iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
-iSavedFieldsShared=false;
-}
-sort(savedFields,count);
-if(count>0){
 DurationField months=DurationFieldType.months().getField(iChrono);
 DurationField days=DurationFieldType.days().getField(iChrono);
 DurationField first=savedFields[0].iField.getDurationField();
 if(compareReverse(first,months)>=0&&compareReverse(first,days)<=0){
 saveField(DateTimeFieldType.year(),iDefaultYear);
 return computeMillis(resetFields,text);
+}
 }
+sort(savedFields,count);
+if(count>0){
+iSavedFields=savedFields=(SavedField[])iSavedFields.clone();
+iSavedFieldsShared=false;
 }
 long millis=iMillis;
 try{
 for(int i=0;i<count;i++){
 millis=savedFields[i].set(millis,resetFields);
 }
 }catch(IllegalFieldValueException e){
 if(text!=null){
 e.prependMessage("Cannot parse \""+text+'"');
 }
 throw e;
 }
 if(iZone==null){
 millis-=iOffset;
 }else {
 int offset=iZone.getOffsetFromLocal(millis);
 millis-=offset;
 if(offset!=iZone.getOffset(millis)){
 String message="Illegal instant due to time zone offset transition ("+iZone+')';
 if(text!=null){
 message="Cannot parse \""+text+"\": "+message;
 }
 throw new IllegalArgumentException(message);
 }
 }
 return millis;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V51/3709/pattern-ver1-serial/src.main.java.jfxtras.labs.scene.layout.GridPane.java-apply.pattern
MATCHLEVEL : ALL
ALL : 46, UPD : 46, INS : 0, DEL : 0
Failing Tests:[org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_purify_2]
---------START : 2019.09.05 AD at 05:41:46 CDT
---------TIME : 2019.09.05 AD at 10:41:51 CDT
--------------- END -----------------
Current failed test : org.joda.time.TestDateTimeZoneCutover::testWithMillisOfSecondInDstChange_Paris_summer_purify_2 | 2019.09.05 AD at 10:41:51 CDT
Current failed test : org.joda.time.TestDateTimeZoneCutover::testBug2182444_usCentral_purify_6 | 2019.09.05 AD at 10:43:50 CDT
Current failed test : org.joda.time.TestDateTimeZoneCutover::testBug2182444_usCentral_purify_7 | 2019.09.05 AD at 10:45:46 CDT
Current failed test : org.joda.time.TestDateTimeZoneCutover::testBug2182444_ausNSW_purify_8 | 2019.09.05 AD at 10:47:55 CDT
Current failed test : org.joda.time.TestDateTimeZoneCutover::testBug2182444_ausNSW_purify_9 | 2019.09.05 AD at 10:49:47 CDT
Current failed test : org.joda.time.TestDateTimeZoneCutover::testWithMinuteOfHourInDstChange_mockZone_purify_4 | 2019.09.05 AD at 10:51:42 CDT
Current failed test : org.joda.time.TestDateTimeZoneCutover::testWithHourOfDayInDstChange_purify_2 | 2019.09.05 AD at 10:53:35 CDT
Current failed test : org.joda.time.TestDateTimeZoneCutover::testWithSecondOfMinuteInDstChange_purify_2 | 2019.09.05 AD at 10:55:34 CDT
Current failed test : org.joda.time.TestDateTimeZoneCutover::testWithMillisOfSecondInDstChange_NewYork_winter_purify_2 | 2019.09.05 AD at 10:57:35 CDT
Finish : time-26 > patch : 0 | Start : Thu Sep 05 05:41:46 CDT 2019 | End : 2019.09.05 AD at 10:59:30 CDT
