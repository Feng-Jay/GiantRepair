Repair : math_80
Current failed test : org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02 | 2019.09.07 AD at 20:35:34 CDT
Location : org.apache.commons.math.linear.EigenDecompositionImpl.processGeneralBlock:[871, 872, 827, 828, 829, 830, 831, 834, 840, 843, 846, 847, 848, 849, 850, 851, 852, 855, 856, 857, 860, 861, 864, 865, 866, 867, 868, 869, 870, 874, 875, 876, 878, 879, 881, 884, 886, 887, 888, 889, 894, 895, 899, 927, 929]#1.0
Compute Candidate : 2019.09.07 AD at 20:36:10 CDT - 2019.09.07 AD at 22:36:46 CDT , PNumber : 7969, CandNumber : 1007 
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+return ;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:36:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+return ;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:36:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+return ;
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:36:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
+return ;
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/2173/pattern-ver1-serial/hu.bme.mit.viatra.ttc.dse.src.hu.bme.mit.viatra.ttc.dse.DseSolverMain.java-main.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
+return ;
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/5432/pattern-ver1-serial/app.src.main.java.com.rrdevs.peerboard.DBCompare.java-authenticateLogin.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+return ;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/5432/pattern-ver1-serial/app.src.main.java.com.rrdevs.peerboard.DBCompare.java-authenticateLogin.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
+return ;
 }

PATTERN : /home/jiajun/GithubData/2015/V6/5432/pattern-ver1-serial/app.src.main.java.com.rrdevs.peerboard.DBCompare.java-authenticateLogin.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+continue;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/5856/pattern-ver1-serial/internalLibraries.backup.src.main.java.com.emc.storageos.management.backup.DbBackupHandler.java-dumpBackup.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+continue;
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/5856/pattern-ver1-serial/internalLibraries.backup.src.main.java.com.emc.storageos.management.backup.DbBackupHandler.java-dumpBackup.pattern
MATCHLEVEL : ALL
ALL : 0, UPD : 0, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==8)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/7671/pattern-ver1-serial/vipr-portal.portal.app.controllers.resources.FileSystems.java-extractTypeFromId.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==8)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/7671/pattern-ver1-serial/vipr-portal.portal.app.controllers.resources.FileSystems.java-extractTypeFromId.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==8)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/7671/pattern-ver1-serial/vipr-portal.portal.app.controllers.resources.FileSystems.java-extractTypeFromId.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag==8){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/7671/pattern-ver1-serial/vipr-portal.portal.app.controllers.resources.FileSystems.java-extractTypeFromId.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+ int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+ double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
-int i0=0;
+ int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
-int n0=n;
+ int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
-double offDiagMax=0;
+ double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:37:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
-double diagMin=diagMax;
+ double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
-double diagMax=work[4*n0-4];
+ double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/2219/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.client.impl.MemberImpl.java-getBooleanAttribute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
-while(n0>0){
+while(n0>1){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5133/pattern-ver1-serial/app.src.main.java.com.bignerdranch.android.photogallery.PhotoGalleryFragment.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>1)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/5133/pattern-ver1-serial/app.src.main.java.com.bignerdranch.android.photogallery.PhotoGalleryFragment.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==0)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/4568/pattern-ver1-serial/src.client.game.GameFrame.java-received.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/4568/pattern-ver1-serial/src.client.game.GameFrame.java-received.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
-while(n0>0){
+while(n0>=0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/3225/pattern-ver1-serial/src.org.peg4d.ParserContext.java-beginPeformStat.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>=3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/3225/pattern-ver1-serial/src.org.peg4d.ParserContext.java-beginPeformStat.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=1;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=1;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=1;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=1;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=1;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=1;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=1;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:38:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
-i0=0;
+i0=1;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:40:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
+sigmaLow=1;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:40:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;tau<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/7268/pattern-ver1-serial/src.org.easypr.core.CharsSegment.java-SortRect.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:41:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;tType<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/7268/pattern-ver1-serial/src.org.easypr.core.CharsSegment.java-SortRect.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:41:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;dMin1<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/7268/pattern-ver1-serial/src.org.easypr.core.CharsSegment.java-SortRect.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:41:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;dMin2<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/7268/pattern-ver1-serial/src.org.easypr.core.CharsSegment.java-SortRect.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:41:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;dN<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/7268/pattern-ver1-serial/src.org.easypr.core.CharsSegment.java-SortRect.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:41:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;dN1<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/7268/pattern-ver1-serial/src.org.easypr.core.CharsSegment.java-SortRect.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:41:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:-work[4*n0-1];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/3678/pattern-ver1-serial/src.main.java.org.fcrepo.client.FedoraClient.java-getPids.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:41:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-1);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/3678/pattern-ver1-serial/src.main.java.org.fcrepo.client.FedoraClient.java-getPids.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:43:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
-work[4*n0-2]=offDiagMin;
+work[4*n0-1]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/3678/pattern-ver1-serial/src.main.java.org.fcrepo.client.FedoraClient.java-getPids.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:43:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-1]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/3678/pattern-ver1-serial/src.main.java.org.fcrepo.client.FedoraClient.java-getPids.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:43:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:work[4*n0-1];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/3678/pattern-ver1-serial/src.main.java.org.fcrepo.client.FedoraClient.java-getPids.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:43:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
-double diagMax=work[4*n0-4];
+double diagMax=work[4*n0-1];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/3678/pattern-ver1-serial/src.main.java.org.fcrepo.client.FedoraClient.java-getPids.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:43:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+int maxIter=30*(n0-1);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/3678/pattern-ver1-serial/src.main.java.org.fcrepo.client.FedoraClient.java-getPids.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:43:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<=n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V45/3857/pattern-ver1-serial/src.com.urverkspel.humancompanion.AttackData.java-roll.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:43:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0;i0<=n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V45/3857/pattern-ver1-serial/src.com.urverkspel.humancompanion.AttackData.java-roll.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:43:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
+pingPong=1-pingPong;
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:43:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
+pingPong=1-pingPong;
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:43:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
+i0=0;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+pingPong=0;
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
+sigma=(n0==n)?0:-work[4*n0-2];
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
+pingPong=1-pingPong;
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
+n0=goodStep(i0,n0);
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
+sigma=(n0==n)?0:-work[4*n0-2];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
+sigma=(n0==n)?0:-work[4*n0-2];
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
+sigma=(n0==n)?0:-work[4*n0-2];
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/2554/pattern-ver1-serial/src.GreenTeaScript.java-CommentToken.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+2]<=2){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V42/3732/pattern-ver1-serial/reformulation-core.src.main.java.org.semanticweb.ontop.owlrefplatform.core.unfolding.TypeLift.java-f.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.util.Collection;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0,myUid;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/276/pattern-ver1-serial/actor-sdk.sdk-core.core.core-shared.src.main.java.im.actor.core.viewmodel.GroupVM.java-create.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.util.Collection;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2),myUid;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/276/pattern-ver1-serial/actor-sdk.sdk-core.core.core-shared.src.main.java.im.actor.core.viewmodel.GroupVM.java-create.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.util.Collection;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0,myUid;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/276/pattern-ver1-serial/actor-sdk.sdk-core.core.core-shared.src.main.java.im.actor.core.viewmodel.GroupVM.java-create.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0,DEFAULT_TIMEOUT2;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V49/3872/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ManageAccount.java-addNewUserAccount.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2),DEFAULT_TIMEOUT2;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V49/3872/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ManageAccount.java-addNewUserAccount.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:44:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0,DEFAULT_TIMEOUT2;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V49/3872/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ManageAccount.java-addNewUserAccount.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:45:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2);i>=2;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V39/6961/pattern-ver1-serial/src.Actions.FailedGuessAction.java-FailedGuessAction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:45:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=2){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V39/6961/pattern-ver1-serial/src.Actions.FailedGuessAction.java-FailedGuessAction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:45:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
-while(n0>0){
+while(n0>3){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/925/pattern-ver1-serial/Group_Project_Bork.CommandFactory.java-parse.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:45:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i>n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V44/4500/pattern-ver1-serial/src.main.java.com.michael.e.liquislots.item.ItemLiquipack.java-addInformation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:45:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0;i0>n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V44/4500/pattern-ver1-serial/src.main.java.com.michael.e.liquislots.item.ItemLiquipack.java-addInformation.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:47:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2);i>0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4108/pattern-ver1-serial/src.main.java.org.roaringbitmap.buffer.MappeableArrayContainer.java-inot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:47:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4108/pattern-ver1-serial/src.main.java.org.roaringbitmap.buffer.MappeableArrayContainer.java-inot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:47:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4108/pattern-ver1-serial/src.main.java.org.roaringbitmap.buffer.MappeableArrayContainer.java-inot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:47:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0,MAX_SERVICE_NODES;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/4395/pattern-ver1-serial/vipr-portal.com.emc.sa.common.src.java.com.emc.sa.zookeeper.ZkServiceDescriptors.java-start.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:47:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2),MAX_SERVICE_NODES;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/4395/pattern-ver1-serial/vipr-portal.com.emc.sa.common.src.java.com.emc.sa.zookeeper.ZkServiceDescriptors.java-start.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:47:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0,MAX_SERVICE_NODES;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/4395/pattern-ver1-serial/vipr-portal.com.emc.sa.common.src.java.com.emc.sa.zookeeper.ZkServiceDescriptors.java-start.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:47:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0,MAX_ZK_WAIT_RETRY_TIMES;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7180/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.vdc.VdcOpHandler.java-waitForAllNodesAndReboot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:47:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2),MAX_ZK_WAIT_RETRY_TIMES;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7180/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.vdc.VdcOpHandler.java-waitForAllNodesAndReboot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:47:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0,MAX_ZK_WAIT_RETRY_TIMES;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/7180/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.vdc.VdcOpHandler.java-waitForAllNodesAndReboot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:47:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+break;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:47:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+break;
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V38/3005/pattern-ver1-serial/LifeOnLine.src.lol.DateParser.java-getUserInputWithoutDueDate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:48:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<sumOffDiag-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V27/6021/pattern-ver1-serial/src.org.andengine.util.algorithm.path.astar.ManhattanHeuristic.java-getExpectedRestCost.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:48:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<i-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V27/6021/pattern-ver1-serial/src.org.andengine.util.algorithm.path.astar.ManhattanHeuristic.java-getExpectedRestCost.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:48:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+break;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/1233/pattern-ver1-serial/crm.src.main.java.com.ogg.crm.ui.activity.CustomerPublicListActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:48:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+break;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/1233/pattern-ver1-serial/crm.src.main.java.com.ogg.crm.ui.activity.CustomerPublicListActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:48:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
+break;
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/1233/pattern-ver1-serial/crm.src.main.java.com.ogg.crm.ui.activity.CustomerPublicListActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
-sumOffDiag+=ei;
+sumOffDiag+=2;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=2;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=2;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=2;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=2;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=2;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=2;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=2;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag<=0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/4307/pattern-ver1-serial/core.src.com.arkanoid.stm.gameStates.ArkanoidGdx.java-block.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong<=0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/4307/pattern-ver1-serial/core.src.com.arkanoid.stm.gameStates.ArkanoidGdx.java-block.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0<=n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/4307/pattern-ver1-serial/core.src.com.arkanoid.stm.gameStates.ArkanoidGdx.java-block.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0<=n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/4307/pattern-ver1-serial/core.src.com.arkanoid.stm.gameStates.ArkanoidGdx.java-block.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:50:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=3;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=3;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=3;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=3;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=3;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=3;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=3;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
+sigmaLow=3;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1-i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/163/pattern-ver1-serial/app.src.main.java.th.zirata.Blocks.EnemyBlocks.Hydra.java-createHydra.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ final double ei=work[fourI-2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/163/pattern-ver1-serial/app.src.main.java.th.zirata.Blocks.EnemyBlocks.Hydra.java-createHydra.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i-2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/163/pattern-ver1-serial/app.src.main.java.th.zirata.Blocks.EnemyBlocks.Hydra.java-createHydra.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,work[i-4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/163/pattern-ver1-serial/app.src.main.java.th.zirata.Blocks.EnemyBlocks.Hydra.java-createHydra.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,work[i-2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/163/pattern-ver1-serial/app.src.main.java.th.zirata.Blocks.EnemyBlocks.Hydra.java-createHydra.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+work[i-2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/163/pattern-ver1-serial/app.src.main.java.th.zirata.Blocks.EnemyBlocks.Hydra.java-createHydra.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,work[i-2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/163/pattern-ver1-serial/app.src.main.java.th.zirata.Blocks.EnemyBlocks.Hydra.java-createHydra.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]-work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/163/pattern-ver1-serial/app.src.main.java.th.zirata.Blocks.EnemyBlocks.Hydra.java-createHydra.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(n==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5778/pattern-ver1-serial/src.main.java.cn.momia.mapi.api.AbstractIndexApi.java-getBanners.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:51:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
-while(n0>0){
+while(n0<0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/3672/pattern-ver1-serial/src.edu.miamioh.cse283.htw.Room.java-shoot.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:52:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2);i>=5;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/1455/pattern-ver1-serial/NumbersFlow.src.com.braingames.sdk.numbersflow.ScoreDatabase.java-getFirstFiveScores.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:52:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=5){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/1455/pattern-ver1-serial/NumbersFlow.src.com.braingames.sdk.numbersflow.ScoreDatabase.java-getFirstFiveScores.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:52:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0;i0<4;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/1764/pattern-ver1-serial/src.main.java.ua.com.ecotep.debtprevention.MainController.java-handleArchiveAction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag>=0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/848/pattern-ver1-serial/src.com.mojang.ld22.entity.Slime.java-render.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0>=n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/848/pattern-ver1-serial/src.com.mojang.ld22.entity.Slime.java-render.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0>=n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/848/pattern-ver1-serial/src.com.mojang.ld22.entity.Slime.java-render.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong>=0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/848/pattern-ver1-serial/src.com.mojang.ld22.entity.Slime.java-render.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
-while(n0>0){
+while(n0!=0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/71/pattern-ver1-serial/src.edu.stanford.nlp.mt.decoder.feat.base.TranslationModelFeaturizer.java-ruleFeaturize.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0!=3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/71/pattern-ver1-serial/src.edu.stanford.nlp.mt.decoder.feat.base.TranslationModelFeaturizer.java-ruleFeaturize.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ final double ei=work[fourI+1];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/688/pattern-ver1-serial/src.it.demo.src.main.java.com.example.demo.Target.java-create.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+1]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/688/pattern-ver1-serial/src.it.demo.src.main.java.com.example.demo.Target.java-create.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,work[i+1]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/688/pattern-ver1-serial/src.it.demo.src.main.java.com.example.demo.Target.java-create.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+work[i+1]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/688/pattern-ver1-serial/src.it.demo.src.main.java.com.example.demo.Target.java-create.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,work[i+1]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/688/pattern-ver1-serial/src.it.demo.src.main.java.com.example.demo.Target.java-create.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,work[i+1]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/688/pattern-ver1-serial/src.it.demo.src.main.java.com.example.demo.Target.java-create.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[1]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0!=n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V46/565/pattern-ver1-serial/src.main.java.cloudservices.brokerage.policy.policycommons.model.entities.Policy.java-isValid.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:54:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0!=n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V46/565/pattern-ver1-serial/src.main.java.cloudservices.brokerage.policy.policycommons.model.entities.Policy.java-isValid.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong!=0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V46/565/pattern-ver1-serial/src.main.java.cloudservices.brokerage.policy.policycommons.model.entities.Policy.java-isValid.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag!=0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V46/565/pattern-ver1-serial/src.main.java.cloudservices.brokerage.policy.policycommons.model.entities.Policy.java-isValid.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ final Integer fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7237/pattern-ver1-serial/Project.src.main.java.util.AdjacencyList.java-kruskal.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
-int i0=0;
+Integer i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7237/pattern-ver1-serial/Project.src.main.java.util.AdjacencyList.java-kruskal.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
-int n0=n;
+Integer n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7237/pattern-ver1-serial/Project.src.main.java.util.AdjacencyList.java-kruskal.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+Integer maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7237/pattern-ver1-serial/Project.src.main.java.util.AdjacencyList.java-kruskal.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ final double ei=work[fourI+3];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/7749/pattern-ver1-serial/HowOld.src.com.gzfgeh.customview.MyHorizontalScrollView.java-initDatas.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+3]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/7749/pattern-ver1-serial/HowOld.src.com.gzfgeh.customview.MyHorizontalScrollView.java-initDatas.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,work[i+3]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/7749/pattern-ver1-serial/HowOld.src.com.gzfgeh.customview.MyHorizontalScrollView.java-initDatas.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+work[i+3]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/7749/pattern-ver1-serial/HowOld.src.com.gzfgeh.customview.MyHorizontalScrollView.java-initDatas.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,work[i+3]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/7749/pattern-ver1-serial/HowOld.src.com.gzfgeh.customview.MyHorizontalScrollView.java-initDatas.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,work[i+3]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/7749/pattern-ver1-serial/HowOld.src.com.gzfgeh.customview.MyHorizontalScrollView.java-initDatas.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:55:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0;i0<3;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/3819/pattern-ver1-serial/BootPrepWeb.src.controllers.UserController.java-validInputs.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:57:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<n-2;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/1120/pattern-ver1-serial/src.main.java.com.pratilipi.data.util.PratilipiDataUtil.java-updatePratilipiStats.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:57:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-2]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/1120/pattern-ver1-serial/src.main.java.com.pratilipi.data.util.PratilipiDataUtil.java-updatePratilipiStats.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:57:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:work[4*n0-2];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/1120/pattern-ver1-serial/src.main.java.com.pratilipi.data.util.PratilipiDataUtil.java-updatePratilipiStats.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:57:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
-double diagMax=work[4*n0-4];
+double diagMax=work[4*n0-2];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/1120/pattern-ver1-serial/src.main.java.com.pratilipi.data.util.PratilipiDataUtil.java-updatePratilipiStats.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:57:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+int maxIter=30*(n0-2);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/1120/pattern-ver1-serial/src.main.java.com.pratilipi.data.util.PratilipiDataUtil.java-updatePratilipiStats.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:57:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
-i0=0;
+i0=3;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/101/pattern-ver1-serial/PageRank.PageRank.java-PageRank.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:59:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
-pingPong=0;
+pingPong=3;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/101/pattern-ver1-serial/PageRank.PageRank.java-PageRank.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:59:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0,i0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V16/6746/pattern-ver1-serial/controllersvc.src.main.java.com.emc.storageos.vplexcontroller.VPlexDeviceController.java-deleteStorageView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 22:59:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0,localLevel;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/1178/pattern-ver1-serial/wrapper.src.main.java.com.ankit.wrapper.Logger.java-w.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:00:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2),localLevel;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/1178/pattern-ver1-serial/wrapper.src.main.java.com.ankit.wrapper.Logger.java-w.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:00:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0,localLevel;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/1178/pattern-ver1-serial/wrapper.src.main.java.com.ankit.wrapper.Logger.java-w.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:00:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=600;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SniperAssassinate.java-SniperAssassinate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:00:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=600;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SniperAssassinate.java-SniperAssassinate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:00:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=600;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SniperAssassinate.java-SniperAssassinate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:00:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=600;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SniperAssassinate.java-SniperAssassinate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:00:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=600;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SniperAssassinate.java-SniperAssassinate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:00:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=600;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SniperAssassinate.java-SniperAssassinate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:00:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=600;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SniperAssassinate.java-SniperAssassinate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:00:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
+sigmaLow=600;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SniperAssassinate.java-SniperAssassinate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:00:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
-i0=0;
+i0=600;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SniperAssassinate.java-SniperAssassinate.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:02:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ final int fourI=2*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/2024/pattern-ver1-serial/src.server.MessageHandler.java-clientPing.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:02:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:-work[2*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/2024/pattern-ver1-serial/src.server.MessageHandler.java-clientPing.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:02:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:work[2*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/2024/pattern-ver1-serial/src.server.MessageHandler.java-clientPing.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:02:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
-double diagMax=work[4*n0-4];
+double diagMax=work[2*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/2024/pattern-ver1-serial/src.server.MessageHandler.java-clientPing.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:02:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
-work[4*n0-2]=offDiagMin;
+work[2*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/2024/pattern-ver1-serial/src.server.MessageHandler.java-clientPing.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:02:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=2*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/2024/pattern-ver1-serial/src.server.MessageHandler.java-clientPing.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[2*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/2024/pattern-ver1-serial/src.server.MessageHandler.java-clientPing.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[0]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/5785/pattern-ver1-serial/src.Seminars.first.collections.ArrayPriorityQueue.java-extractMin.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=10;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=10;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=10;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=10;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=10;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=10;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=10;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
+sigmaLow=10;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[2]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag>0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V8/5819/pattern-ver1-serial/FlawlessEssenceMiner.java-active.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong>0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V8/5819/pattern-ver1-serial/FlawlessEssenceMiner.java-active.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0>n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V8/5819/pattern-ver1-serial/FlawlessEssenceMiner.java-active.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0>n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V8/5819/pattern-ver1-serial/FlawlessEssenceMiner.java-active.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-1>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/1627/pattern-ver1-serial/src.org.GreenTeaScript.JVM.GtSubProc.java-createSubProc.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:03:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag==4){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/5287/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.Activities.SubredditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:04:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==4)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/5287/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.Activities.SubredditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:04:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==4)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/5287/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.Activities.SubredditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:04:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==4)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V33/5287/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.Activities.SubredditView.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:04:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<n-sumOffDiag;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V52/5364/pattern-ver1-serial/src.beast.core.MCMC.java-doLoop.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:04:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<n-i;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V52/5364/pattern-ver1-serial/src.beast.core.MCMC.java-doLoop.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:04:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
+sigmaLow=2;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/2316/pattern-ver1-serial/TaskScheduler.src.ApplicationWindow.java-actionPerformed.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:04:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
-i0=0;
+i0=2;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V2/2316/pattern-ver1-serial/TaskScheduler.src.ApplicationWindow.java-actionPerformed.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.max(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4024/pattern-ver1-serial/MPChartLib.src.main.java.com.github.mikephil.charting.charts.BarLineChartBase.java-getLowestVisibleX.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.max(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/4024/pattern-ver1-serial/MPChartLib.src.main.java.com.github.mikephil.charting.charts.BarLineChartBase.java-getLowestVisibleX.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.util.ArrayList;
+
+import com.sun.javafx.scene.control.behavior.KeyBinding;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<n-1;++i,new ArrayList<KeyBinding>()){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/314/pattern-ver1-serial/src.main.java.jfxtras.labs.internal.scene.control.behavior.SixteenSegmentBehavior.java-SixteenSegmentBehavior.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.util.ArrayList;
+
+import com.sun.javafx.scene.control.behavior.KeyBinding;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2);i>=0;i-=4,new ArrayList<KeyBinding>()){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/314/pattern-ver1-serial/src.main.java.jfxtras.labs.internal.scene.control.behavior.SixteenSegmentBehavior.java-SixteenSegmentBehavior.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.util.ArrayList;
+
+import com.sun.javafx.scene.control.behavior.KeyBinding;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0;i0<n0;++k,new ArrayList<KeyBinding>()){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V33/314/pattern-ver1-serial/src.main.java.jfxtras.labs.internal.scene.control.behavior.SixteenSegmentBehavior.java-SixteenSegmentBehavior.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 0, INS : 1, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=100;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=100;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=100;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=100;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=100;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=100;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=100;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:06:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
+sigmaLow=100;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2);i>=0.0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/3703/pattern-ver1-serial/Muehle_Master.src.de.dhbw.muehle.model.theme.Sound.java-fade.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=0.0){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/3703/pattern-ver1-serial/Muehle_Master.src.de.dhbw.muehle.model.theme.Sound.java-fade.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0;i0<5;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/7269/pattern-ver1-serial/src.infovis.piechart.Data.java-Data.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k<=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/4156/pattern-ver1-serial/src.eduapp.level.quest.GroupingQuest.java-setResult.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2);i<=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/4156/pattern-ver1-serial/src.eduapp.level.quest.GroupingQuest.java-setResult.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin<=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/4156/pattern-ver1-serial/src.eduapp.level.quest.GroupingQuest.java-setResult.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag==5){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/2942/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.Activities.MainActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==5)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/2942/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.Activities.MainActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==5)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/2942/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.Activities.MainActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==5)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/2942/pattern-ver1-serial/app.src.main.java.me.ccrama.redditslide.Activities.MainActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+2]>=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6682/pattern-ver1-serial/src.Geometry.Graham_Scan.java-leftTurn.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]>=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6682/pattern-ver1-serial/src.Geometry.Graham_Scan.java-leftTurn.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]>=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6682/pattern-ver1-serial/src.Geometry.Graham_Scan.java-leftTurn.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=0.0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/4063/pattern-ver1-serial/playgrounds.agarwalamit.src.main.java.playground.agarwalamit.mixedTraffic.plots.LinkPersonInfoContainer.java-updateAvailableLinkSpace.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=0.0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/4063/pattern-ver1-serial/playgrounds.agarwalamit.src.main.java.playground.agarwalamit.mixedTraffic.plots.LinkPersonInfoContainer.java-updateAvailableLinkSpace.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=0.0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/4063/pattern-ver1-serial/playgrounds.agarwalamit.src.main.java.playground.agarwalamit.mixedTraffic.plots.LinkPersonInfoContainer.java-updateAvailableLinkSpace.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:07:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=0.0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/4063/pattern-ver1-serial/playgrounds.agarwalamit.src.main.java.playground.agarwalamit.mixedTraffic.plots.LinkPersonInfoContainer.java-updateAvailableLinkSpace.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=0.0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/4063/pattern-ver1-serial/playgrounds.agarwalamit.src.main.java.playground.agarwalamit.mixedTraffic.plots.LinkPersonInfoContainer.java-updateAvailableLinkSpace.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=0.0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/4063/pattern-ver1-serial/playgrounds.agarwalamit.src.main.java.playground.agarwalamit.mixedTraffic.plots.LinkPersonInfoContainer.java-updateAvailableLinkSpace.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
+sigmaLow=0.0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V33/4063/pattern-ver1-serial/playgrounds.agarwalamit.src.main.java.playground.agarwalamit.mixedTraffic.plots.LinkPersonInfoContainer.java-updateAvailableLinkSpace.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<n-4;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4905/pattern-ver1-serial/app_android.src.com.projectkaiser.app_android.MainActivity.java-getView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:-work[4*n0-4];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4905/pattern-ver1-serial/app_android.src.com.projectkaiser.app_android.MainActivity.java-getView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:work[4*n0-4];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4905/pattern-ver1-serial/app_android.src.com.projectkaiser.app_android.MainActivity.java-getView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-4);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4905/pattern-ver1-serial/app_android.src.com.projectkaiser.app_android.MainActivity.java-getView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
-work[4*n0-2]=offDiagMin;
+work[4*n0-4]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4905/pattern-ver1-serial/app_android.src.com.projectkaiser.app_android.MainActivity.java-getView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+int maxIter=30*(n0-4);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4905/pattern-ver1-serial/app_android.src.com.projectkaiser.app_android.MainActivity.java-getView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-4>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4905/pattern-ver1-serial/app_android.src.com.projectkaiser.app_android.MainActivity.java-getView.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.max(0,diagMin-2*Math.sqrt(i0*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V34/4880/pattern-ver1-serial/src.main.java.ch.trq.carrera.javapilot.akka.trackanalyzer.TrackAnalyzer.java-calculateDistance.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=i0*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V34/4880/pattern-ver1-serial/src.main.java.ch.trq.carrera.javapilot.akka.trackanalyzer.TrackAnalyzer.java-calculateDistance.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
-if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
+if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=i0*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V34/4880/pattern-ver1-serial/src.main.java.ch.trq.carrera.javapilot.akka.trackanalyzer.TrackAnalyzer.java-calculateDistance.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=i0*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V34/4880/pattern-ver1-serial/src.main.java.ch.trq.carrera.javapilot.akka.trackanalyzer.TrackAnalyzer.java-calculateDistance.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
-if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
+if((work[i+3]<=i0*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V34/4880/pattern-ver1-serial/src.main.java.ch.trq.carrera.javapilot.akka.trackanalyzer.TrackAnalyzer.java-calculateDistance.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.max(0,i0-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V34/4880/pattern-ver1-serial/src.main.java.ch.trq.carrera.javapilot.akka.trackanalyzer.TrackAnalyzer.java-calculateDistance.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:-work[i0*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V34/4880/pattern-ver1-serial/src.main.java.ch.trq.carrera.javapilot.akka.trackanalyzer.TrackAnalyzer.java-calculateDistance.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:work[i0*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V34/4880/pattern-ver1-serial/src.main.java.ch.trq.carrera.javapilot.akka.trackanalyzer.TrackAnalyzer.java-calculateDistance.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:08:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i0]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/1576/pattern-ver1-serial/src.wyil.io.WyilFileReader.java-readTypePool.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[tType]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/1576/pattern-ver1-serial/src.wyil.io.WyilFileReader.java-readTypePool.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[n0]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V25/1576/pattern-ver1-serial/src.wyil.io.WyilFileReader.java-readTypePool.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=4;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/1083/pattern-ver1-serial/action-adventure.src.main.java.niellebeck.game.PlayerCharacter.java-PlayerCharacter.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=4;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/1083/pattern-ver1-serial/action-adventure.src.main.java.niellebeck.game.PlayerCharacter.java-PlayerCharacter.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=4;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/1083/pattern-ver1-serial/action-adventure.src.main.java.niellebeck.game.PlayerCharacter.java-PlayerCharacter.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=4;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/1083/pattern-ver1-serial/action-adventure.src.main.java.niellebeck.game.PlayerCharacter.java-PlayerCharacter.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=4;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/1083/pattern-ver1-serial/action-adventure.src.main.java.niellebeck.game.PlayerCharacter.java-PlayerCharacter.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=4;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/1083/pattern-ver1-serial/action-adventure.src.main.java.niellebeck.game.PlayerCharacter.java-PlayerCharacter.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=4;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/1083/pattern-ver1-serial/action-adventure.src.main.java.niellebeck.game.PlayerCharacter.java-PlayerCharacter.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
+sigmaLow=4;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/1083/pattern-ver1-serial/action-adventure.src.main.java.niellebeck.game.PlayerCharacter.java-PlayerCharacter.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ final int fourI=4*2;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V44/6068/pattern-ver1-serial/core.src.com.blogspot.ludumdaresforfun.MainScreen.java-activateBoss.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:-work[4*2-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V44/6068/pattern-ver1-serial/core.src.com.blogspot.ludumdaresforfun.MainScreen.java-activateBoss.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:work[4*2-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V44/6068/pattern-ver1-serial/core.src.com.blogspot.ludumdaresforfun.MainScreen.java-activateBoss.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
-double diagMax=work[4*n0-4];
+double diagMax=work[4*2-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V44/6068/pattern-ver1-serial/core.src.com.blogspot.ludumdaresforfun.MainScreen.java-activateBoss.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
-work[4*n0-2]=offDiagMin;
+work[4*2-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V44/6068/pattern-ver1-serial/core.src.com.blogspot.ludumdaresforfun.MainScreen.java-activateBoss.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=5;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/26/pattern-ver1-serial/src.android.com.terrydr.eyeScope.CameraActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=5;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/26/pattern-ver1-serial/src.android.com.terrydr.eyeScope.CameraActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=5;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/26/pattern-ver1-serial/src.android.com.terrydr.eyeScope.CameraActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=5;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/26/pattern-ver1-serial/src.android.com.terrydr.eyeScope.CameraActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:09:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=5;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/26/pattern-ver1-serial/src.android.com.terrydr.eyeScope.CameraActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:10:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=5;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/26/pattern-ver1-serial/src.android.com.terrydr.eyeScope.CameraActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:10:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=5;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/26/pattern-ver1-serial/src.android.com.terrydr.eyeScope.CameraActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:10:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
+sigmaLow=5;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/26/pattern-ver1-serial/src.android.com.terrydr.eyeScope.CameraActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:10:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
-i0=0;
+i0=5;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/26/pattern-ver1-serial/src.android.com.terrydr.eyeScope.CameraActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:12:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.min(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V18/5136/pattern-ver1-serial/src.main.java.com.massivecraft.factions.zcore.persist.MemoryFaction.java-getMaxLand.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:12:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.min(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V18/5136/pattern-ver1-serial/src.main.java.com.massivecraft.factions.zcore.persist.MemoryFaction.java-getMaxLand.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:12:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.min(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V18/5136/pattern-ver1-serial/src.main.java.com.massivecraft.factions.zcore.persist.MemoryFaction.java-getMaxLand.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:12:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sigma==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/4897/pattern-ver1-serial/src.main.java.de.axxepta.oxygen.utils.WorkspaceUtils.java-newResourceOrOverwrite.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:12:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(tau==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/4897/pattern-ver1-serial/src.main.java.de.axxepta.oxygen.utils.WorkspaceUtils.java-newResourceOrOverwrite.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:12:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)!=(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V26/4543/pattern-ver1-serial/launcher.src.main.java.com.benny.openlauncher.widget.GridAppDrawer.java-readyForDrag.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:12:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)!=(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V26/4543/pattern-ver1-serial/launcher.src.main.java.com.benny.openlauncher.widget.GridAppDrawer.java-readyForDrag.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:12:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)!=(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V26/4543/pattern-ver1-serial/launcher.src.main.java.com.benny.openlauncher.widget.GridAppDrawer.java-readyForDrag.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:12:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V28/4132/pattern-ver1-serial/MainProject.src.se.chalmers.dat255.risk.view.ProvinceView.java-getTextY.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:14:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=700;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkPounce.java-SlarkPounce.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:14:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=700;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkPounce.java-SlarkPounce.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:14:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=700;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkPounce.java-SlarkPounce.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:14:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=700;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkPounce.java-SlarkPounce.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:14:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=700;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkPounce.java-SlarkPounce.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:14:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=700;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkPounce.java-SlarkPounce.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:14:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=700;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkPounce.java-SlarkPounce.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:14:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
+sigmaLow=700;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkPounce.java-SlarkPounce.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:14:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
-i0=0;
+i0=700;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkPounce.java-SlarkPounce.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:16:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+int sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V49/4536/pattern-ver1-serial/src.azdblab.executable.Main.java-runExperiment.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
-work[4*n0-2]=offDiagMin;
+work[4*n0-2]=0;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V27/506/pattern-ver1-serial/MetaChessApp.src.engine.board.ExtendedBoardModel.java-getFurthestPiece.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
-sumOffDiag+=ei;
+sumOffDiag+=0;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V27/506/pattern-ver1-serial/MetaChessApp.src.engine.board.ExtendedBoardModel.java-getFurthestPiece.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0<3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/1401/pattern-ver1-serial/XMLC.src.Learner.PLTFH.java-compare.pattern
MATCHLEVEL : ALL
ALL : 1, UPD : 1, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=-1;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=-1;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=-1;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=-1;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=-1;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=-1;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=-1;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
+sigmaLow=-1;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
-i0=0;
+i0=-1;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+ int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+ double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
-int i0=0;
+ int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
-int n0=n;
+ int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:17:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
-double offDiagMax=0;
+ double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
-double diagMin=diagMax;
+ double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
-int split=i0-1;
+ int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
-double diagMax=work[4*n0-4];
+ double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2615/pattern-ver1-serial/Android.src.org.droidplanner.android.proxy.mission.MissionProxy.java-getFirstWaypoint.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.util.Iterator;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==-1)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/7863/pattern-ver1-serial/src.main.java.util.ListTools.java-call.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.util.Iterator;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==-1)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/7863/pattern-ver1-serial/src.main.java.util.ListTools.java-call.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.util.Iterator;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==-1)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/7863/pattern-ver1-serial/src.main.java.util.ListTools.java-call.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.util.Iterator;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag==-1){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V12/7863/pattern-ver1-serial/src.main.java.util.ListTools.java-call.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+i++;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
+sumOffDiag++;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
+i0++;
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
+i0++;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+offDiagMax++;
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+offDiagMax++;
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
+offDiagMax++;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V14/297/pattern-ver1-serial/app.src.main.java.org.team2635.scoutnetclient.fragments.StrategyInfoFragment.java-getData.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+i++;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/6147/pattern-ver1-serial/src.system.ResultPathCompare.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+i0++;
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/6147/pattern-ver1-serial/src.system.ResultPathCompare.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:18:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
+offDiagMax++;
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/6147/pattern-ver1-serial/src.system.ResultPathCompare.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:19:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax++;
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/6147/pattern-ver1-serial/src.system.ResultPathCompare.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:19:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
+offDiagMin++;
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/6147/pattern-ver1-serial/src.system.ResultPathCompare.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:19:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+n0++;
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/6147/pattern-ver1-serial/src.system.ResultPathCompare.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:21:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+sumOffDiag++;
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/4356/pattern-ver1-serial/src.main.java.uk.ac.ebi.pride.spectracluster.cli.SpectraClusterCliMain.java-convertClusters.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:21:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
+sumOffDiag++;
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/4356/pattern-ver1-serial/src.main.java.uk.ac.ebi.pride.spectracluster.cli.SpectraClusterCliMain.java-convertClusters.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:21:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+sumOffDiag++;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/4356/pattern-ver1-serial/src.main.java.uk.ac.ebi.pride.spectracluster.cli.SpectraClusterCliMain.java-convertClusters.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:21:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
+sumOffDiag++;
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/4356/pattern-ver1-serial/src.main.java.uk.ac.ebi.pride.spectracluster.cli.SpectraClusterCliMain.java-convertClusters.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:21:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+sumOffDiag++;
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/4356/pattern-ver1-serial/src.main.java.uk.ac.ebi.pride.spectracluster.cli.SpectraClusterCliMain.java-convertClusters.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:21:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+sumOffDiag++;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/4356/pattern-ver1-serial/src.main.java.uk.ac.ebi.pride.spectracluster.cli.SpectraClusterCliMain.java-convertClusters.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:21:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
+sumOffDiag++;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/4356/pattern-ver1-serial/src.main.java.uk.ac.ebi.pride.spectracluster.cli.SpectraClusterCliMain.java-convertClusters.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:21:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
+sumOffDiag++;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/4356/pattern-ver1-serial/src.main.java.uk.ac.ebi.pride.spectracluster.cli.SpectraClusterCliMain.java-convertClusters.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:21:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+i++;
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V8/868/pattern-ver1-serial/src.main.java.gcommon.objects.NumberFormatter.java-format.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:21:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+i--;
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:23:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax--;
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:23:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+i0--;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:23:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+n0--;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:23:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+offDiagMax--;
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:23:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
+offDiagMax--;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/5173/pattern-ver1-serial/ejb_modules.EJB-timetable.src.main.java.be.vubrooster.ejb.managers.EHBActivityManager.java-loadActivitiesForClassRooms.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:23:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<=n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0;i0<=n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/4679/pattern-ver1-serial/src.course.Grass.java-render.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:23:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<=n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
-for(int i=4*i0;i<4*n0-16;i+=4){
+for(int i=4*i0;i<=4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/4679/pattern-ver1-serial/src.course.Grass.java-render.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:23:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0;i0<=n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
-for(int i=4*i0;i<4*n0-16;i+=4){
+for(int i=4*i0;i<=4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/4679/pattern-ver1-serial/src.course.Grass.java-render.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+sumOffDiag--;
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/965/pattern-ver1-serial/src.Game.java-loop.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+sumOffDiag--;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/965/pattern-ver1-serial/src.Game.java-loop.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
+sumOffDiag--;
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/965/pattern-ver1-serial/src.Game.java-loop.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+sumOffDiag--;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/965/pattern-ver1-serial/src.Game.java-loop.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+sumOffDiag--;
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/965/pattern-ver1-serial/src.Game.java-loop.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+i--;
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/965/pattern-ver1-serial/src.Game.java-loop.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+synchronized(this){
 sumOffDiag+=ei;
+}
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V20/1267/pattern-ver1-serial/src.main.java.io.vertx.ext.shell.command.impl.ProcessImpl.java-endHandler.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
+synchronized(this){
 work[4*n0-2]=offDiagMin;
+}
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V20/1267/pattern-ver1-serial/src.main.java.io.vertx.ext.shell.command.impl.ProcessImpl.java-endHandler.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
+synchronized(this){
 work[4*n0-1]=previousEMin;
+}
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V20/1267/pattern-ver1-serial/src.main.java.io.vertx.ext.shell.command.impl.ProcessImpl.java-endHandler.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i++]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/7673/pattern-ver1-serial/src.main.java.org.rapla.storage.dbrm.RemoteOperator.java-getFromId.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ final double ei=this.work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/2698/pattern-ver1-serial/Ant.src.main.graphics.cells.Cells.java-setCell.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,this.work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/2698/pattern-ver1-serial/Ant.src.main.graphics.cells.Cells.java-setCell.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:-this.work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/2698/pattern-ver1-serial/Ant.src.main.graphics.cells.Cells.java-setCell.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:this.work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/2698/pattern-ver1-serial/Ant.src.main.graphics.cells.Cells.java-setCell.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(this.work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/2698/pattern-ver1-serial/Ant.src.main.graphics.cells.Cells.java-setCell.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,this.work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/2698/pattern-ver1-serial/Ant.src.main.graphics.cells.Cells.java-setCell.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
-double diagMax=work[4*n0-4];
+double diagMax=this.work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/2698/pattern-ver1-serial/Ant.src.main.graphics.cells.Cells.java-setCell.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,this.work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/2698/pattern-ver1-serial/Ant.src.main.graphics.cells.Cells.java-setCell.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+this.work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/2698/pattern-ver1-serial/Ant.src.main.graphics.cells.Cells.java-setCell.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:24:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,this.work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V38/2698/pattern-ver1-serial/Ant.src.main.graphics.cells.Cells.java-setCell.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,i+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V42/2928/pattern-ver1-serial/src.offensive.Communicator.JsonMessage.java-toString.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0!=0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/5558/pattern-ver1-serial/app.src.main.java.in.attreya.dailylist.MainActivity.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0!=0)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/5558/pattern-ver1-serial/app.src.main.java.in.attreya.dailylist.MainActivity.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
+synchronized(this){
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+}
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/3450/pattern-ver1-serial/hbase-server.src.main.java.org.apache.hadoop.hbase.security.visibility.VisibilityController.java-postOpen.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+processGeneralBlock(n);
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/3252/pattern-ver1-serial/care-reporting.commcare-migration.src.main.java.org.motechproject.care.reporting.migration.task.MigrationTask.java-postToMotech.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+processGeneralBlock(i);
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/3252/pattern-ver1-serial/care-reporting.commcare-migration.src.main.java.org.motechproject.care.reporting.migration.task.MigrationTask.java-postToMotech.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+processGeneralBlock(fourI);
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V21/3252/pattern-ver1-serial/care-reporting.commcare-migration.src.main.java.org.motechproject.care.reporting.migration.task.MigrationTask.java-postToMotech.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
+initialSplits((int)(n));
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/6653/pattern-ver1-serial/Character.java-setCharstat.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ final double ei=work[fourI+(int)(2)];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/4690/pattern-ver1-serial/33_CDIO3.src.controller.DecisionController.java-askForDecision.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+(int)(2)]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/4690/pattern-ver1-serial/33_CDIO3.src.controller.DecisionController.java-askForDecision.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,work[i+(int)(4)]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/4690/pattern-ver1-serial/33_CDIO3.src.controller.DecisionController.java-askForDecision.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,work[i+(int)(2)]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/4690/pattern-ver1-serial/33_CDIO3.src.controller.DecisionController.java-askForDecision.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+work[i+(int)(2)]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/4690/pattern-ver1-serial/33_CDIO3.src.controller.DecisionController.java-askForDecision.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,work[i+(int)(2)]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/4690/pattern-ver1-serial/33_CDIO3.src.controller.DecisionController.java-askForDecision.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
+i0++;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2119/pattern-ver1-serial/src.field.initial.FieldConstructor.java-execute.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:25:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
+n0++;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2119/pattern-ver1-serial/src.field.initial.FieldConstructor.java-execute.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:27:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+offDiagMin++;
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V5/2119/pattern-ver1-serial/src.field.initial.FieldConstructor.java-execute.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:27:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ final double ei=work[fourI+-1];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4243/pattern-ver1-serial/app.src.main.java.com.ryanwedoff.senor.naoservercontroller.WalkFragment.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:27:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+-1]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4243/pattern-ver1-serial/app.src.main.java.com.ryanwedoff.senor.naoservercontroller.WalkFragment.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,work[i+-1]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4243/pattern-ver1-serial/app.src.main.java.com.ryanwedoff.senor.naoservercontroller.WalkFragment.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,work[i+-1]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4243/pattern-ver1-serial/app.src.main.java.com.ryanwedoff.senor.naoservercontroller.WalkFragment.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+work[i+-1]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4243/pattern-ver1-serial/app.src.main.java.com.ryanwedoff.senor.naoservercontroller.WalkFragment.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,work[i+-1]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4243/pattern-ver1-serial/app.src.main.java.com.ryanwedoff.senor.naoservercontroller.WalkFragment.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+synchronized(this){
 i0=1+i/4;
+}
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/6621/pattern-ver1-serial/src.com.qozix.tileview.tiles.TileCache.java-addBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+synchronized(this){
 diagMin=Math.min(diagMin,work[i+4]);
+}
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/6621/pattern-ver1-serial/src.com.qozix.tileview.tiles.TileCache.java-addBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+synchronized(this){
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V19/6621/pattern-ver1-serial/src.com.qozix.tileview.tiles.TileCache.java-addBitmap.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/(int)4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/6656/pattern-ver1-serial/src.game.Game.java-main.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 2, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0,continentName,countryCode;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/6266/pattern-ver1-serial/app.src.main.java.com.hyperion.dashdroid.radio.RadioListFragment.java-refresh.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2),continentName,countryCode;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/6266/pattern-ver1-serial/app.src.main.java.com.hyperion.dashdroid.radio.RadioListFragment.java-refresh.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0,continentName,countryCode;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/6266/pattern-ver1-serial/app.src.main.java.com.hyperion.dashdroid.radio.RadioListFragment.java-refresh.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
+if(equals(n)){
+return ;
+}
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
+return ;
+}
+if(equals(n)){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
+if(equals(n)){
+return ;
+}
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+}
+if(equals(sumOffDiag)){
+return ;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+if(equals(n)){
+return ;
+}
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
+if(equals(n)){
+return ;
+}
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+if(equals(i0)){
+return ;
+}
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:28:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
+if(equals(i0)){
+return ;
+}
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+if(equals(n0)){
+return ;
+}
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/2535/pattern-ver1-serial/src.main.java.se.intem.web.taglib.combined.node.ResourceNode.java-addEdge.pattern
MATCHLEVEL : ALL
ALL : 2, UPD : 0, INS : 2, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.nio.charset.Charset;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<n-1;++i,Charset.forName("UTF-8")){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/3733/pattern-ver1-serial/Code.Part1.src.core.Intraprocedural.java-callgraph.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.nio.charset.Charset;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2);i>=0;i-=4,Charset.forName("UTF-8")){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/3733/pattern-ver1-serial/Code.Part1.src.core.Intraprocedural.java-callgraph.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.nio.charset.Charset;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0;i0<n0;++k,Charset.forName("UTF-8")){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V19/3733/pattern-ver1-serial/Code.Part1.src.core.Intraprocedural.java-callgraph.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+if(fourI==i){
+return ;
+}
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/2945/pattern-ver1-serial/code.src.ast.MinMaxRedundancy.java-checkRedundant.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if(ei==i){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/2945/pattern-ver1-serial/code.src.ast.MinMaxRedundancy.java-checkRedundant.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+if(i==fourI){
+return ;
+}
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/2945/pattern-ver1-serial/code.src.ast.MinMaxRedundancy.java-checkRedundant.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if(ei==fourI){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/2945/pattern-ver1-serial/code.src.ast.MinMaxRedundancy.java-checkRedundant.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if(i==ei){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/2945/pattern-ver1-serial/code.src.ast.MinMaxRedundancy.java-checkRedundant.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if(fourI==ei){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/2945/pattern-ver1-serial/code.src.ast.MinMaxRedundancy.java-checkRedundant.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+if(i0==n){
+return ;
+}
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/2945/pattern-ver1-serial/code.src.ast.MinMaxRedundancy.java-checkRedundant.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+if(n==i0){
+return ;
+}
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/2945/pattern-ver1-serial/code.src.ast.MinMaxRedundancy.java-checkRedundant.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+if(n0==n){
+return ;
+}
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/2945/pattern-ver1-serial/code.src.ast.MinMaxRedundancy.java-checkRedundant.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+if(offDiagMin==n){
+return ;
+}
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/2945/pattern-ver1-serial/code.src.ast.MinMaxRedundancy.java-checkRedundant.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if(fourI==4*i){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if(ei==work[fourI+2]){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:29:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
+if(offDiagMax==0){
+return ;
+}
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+}
+if(offDiagMax==0){
+return ;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
+if(offDiagMax==0){
+return ;
+}
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+}
 }
+if(offDiagMax==0){
+return ;
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
+if(offDiagMax==0){
+return ;
+}
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5920/pattern-ver1-serial/FileReaders.gff.GVFReader.java-get_detail.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*1;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/3678/pattern-ver1-serial/src.main.java.org.fcrepo.client.FedoraClient.java-getPids.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+int maxIter=30*1;
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/3678/pattern-ver1-serial/src.main.java.org.fcrepo.client.FedoraClient.java-getPids.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
+synchronized(this){
 return ;
+}
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
+synchronized(this){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
+}
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
-pingPong=1-pingPong;
+pingPong=0;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V64/1097/pattern-ver1-serial/plugins.de.ovgu.featureide.core.mpl.src.de.ovgu.featureide.core.mpl.signature.javadoc.AJavaDocCommentMerger.java-parseTags.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=2)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V42/3732/pattern-ver1-serial/reformulation-core.src.main.java.org.semanticweb.ontop.owlrefplatform.core.unfolding.TypeLift.java-f.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=2)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V42/3732/pattern-ver1-serial/reformulation-core.src.main.java.org.semanticweb.ontop.owlrefplatform.core.unfolding.TypeLift.java-f.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
+if("index".equals(i)){
+return ;
+}
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+if("index".equals(fourI)){
+return ;
+}
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if("index".equals(ei)){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+if("index".equals(n)){
+return ;
+}
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+if("index".equals(offDiagMax)){
+return ;
+}
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+if("index".equals(diagMin)){
+return ;
+}
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+if("index".equals(offDiagMin)){
+return ;
+}
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:30:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+if("index".equals(offDiagMax)){
+return ;
+}
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+if("index".equals(diagMax)){
+return ;
+}
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+if("index".equals(diagMin)){
+return ;
+}
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/5660/pattern-ver1-serial/plugins.crawloverview-plugin.src.main.java.com.crawljax.plugins.crawloverview.StateWriter.java-getStateNumber.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>=2){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V39/6961/pattern-ver1-serial/src.Actions.FailedGuessAction.java-FailedGuessAction.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
+if("&null".equals(n)){
+return ;
+}
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+if("&null".equals(i)){
+return ;
+}
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+if("&null".equals(fourI)){
+return ;
+}
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if("&null".equals(ei)){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
+if("&null".equals(i0)){
+return ;
+}
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
+if("&null".equals(n0)){
+return ;
+}
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
+}
+if("&null".equals(n0)){
+return ;
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+if("&null".equals(offDiagMin)){
+return ;
+}
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
+if("&null".equals(offDiagMax)){
+return ;
+}
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
+if("&null".equals(diagMax)){
+return ;
+}
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/1018/pattern-ver1-serial/skuldsku-prod.src.main.java.no.steria.skuldsku.recorder.java.serializer.ClassSerializer.java-myAsObject.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*n0-2*100;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/1028/pattern-ver1-serial/coordinatorsvc.src.main.java.com.emc.storageos.coordinator.client.model.DbConsistencyStatus.java-updateCFProgress.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+int maxIter=30*n0-i0*100;
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V17/1028/pattern-ver1-serial/coordinatorsvc.src.main.java.com.emc.storageos.coordinator.client.model.DbConsistencyStatus.java-updateCFProgress.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
+n0=0;
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V32/6155/pattern-ver1-serial/SideScroller.src.net.masterzach32.sidescroller.entity.enemy.Boss.java-Boss.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(30-(diagMin),work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/1792/pattern-ver1-serial/rangebar.src.com.appyvet.rangebar.RangeBar.java-onAnimationUpdate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:31:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(30-(offDiagMax),work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/1792/pattern-ver1-serial/rangebar.src.com.appyvet.rangebar.RangeBar.java-onAnimationUpdate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(30-(offDiagMin),work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/1792/pattern-ver1-serial/rangebar.src.com.appyvet.rangebar.RangeBar.java-onAnimationUpdate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+initialSplits(n);
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+initialSplits(n);
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
+initialSplits(n);
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
+initialSplits(n);
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
+initialSplits(n);
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ @SuppressWarnings("UnusedAssignment") double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ @SuppressWarnings("UnusedAssignment") int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+ @SuppressWarnings("UnusedAssignment") int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ @SuppressWarnings("UnusedAssignment") double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ @SuppressWarnings("UnusedAssignment") double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+ @SuppressWarnings("UnusedAssignment") int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ @SuppressWarnings("UnusedAssignment") double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ @SuppressWarnings("UnusedAssignment") int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+ @SuppressWarnings("UnusedAssignment") double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ @SuppressWarnings("UnusedAssignment") double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ @SuppressWarnings("UnusedAssignment") double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+ @SuppressWarnings("UnusedAssignment") double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ @SuppressWarnings("UnusedAssignment") double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ @SuppressWarnings("UnusedAssignment") int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
-int i0=0;
+ @SuppressWarnings("UnusedAssignment") int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ @SuppressWarnings("UnusedAssignment") double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ @SuppressWarnings("UnusedAssignment") int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
-int n0=n;
+ @SuppressWarnings("UnusedAssignment") int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ @SuppressWarnings("UnusedAssignment") double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ @SuppressWarnings("UnusedAssignment") int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
-double offDiagMax=0;
+ @SuppressWarnings("UnusedAssignment") double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ @SuppressWarnings("UnusedAssignment") double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ @SuppressWarnings("UnusedAssignment") int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
-double diagMin=diagMax;
+ @SuppressWarnings("UnusedAssignment") double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:32:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ @SuppressWarnings("UnusedAssignment") double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
- final int fourI=4*i;
+ @SuppressWarnings("UnusedAssignment") int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
-int split=i0-1;
+ @SuppressWarnings("UnusedAssignment") int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:33:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
-double sumOffDiag=0;
+ @SuppressWarnings("UnusedAssignment") double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ @SuppressWarnings("UnusedAssignment") double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
-int i0=0;
+ @SuppressWarnings("UnusedAssignment") int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V19/3416/pattern-ver1-serial/mobile.src.main.java.com.harlie.radiotheater.radiomysterytheater.data_helper.LoadRadioTheaterTablesAsyncTask.java-loadEpisodes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:33:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
-pingPong=1-pingPong;
+pingPong=2;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:33:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+initialSplits(n);
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:33:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+i=n;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:33:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+work[fourI+2]=n;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/5893/pattern-ver1-serial/vipr-portal.portal.app.models.datatable.NfsACLDataTable.java-NfsAclInfo.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:33:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
+initialSplits(n);
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/6741/pattern-ver1-serial/core.src.main.java.org.jahia.modules.external.ExternalSessionImpl.java-move.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:33:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
-pingPong=1-pingPong;
+pingPong=3;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:33:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/2703/pattern-ver1-serial/src.main.java.net.minecraftforge.common.interpreter.AST.java-apply.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:35:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+1+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/2703/pattern-ver1-serial/src.main.java.net.minecraftforge.common.interpreter.AST.java-apply.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:35:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ final double ei=work[fourI+1+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/2703/pattern-ver1-serial/src.main.java.net.minecraftforge.common.interpreter.AST.java-apply.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:35:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+1+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/2703/pattern-ver1-serial/src.main.java.net.minecraftforge.common.interpreter.AST.java-apply.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:35:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,work[i+1+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/2703/pattern-ver1-serial/src.main.java.net.minecraftforge.common.interpreter.AST.java-apply.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:35:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,work[i+1+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/2703/pattern-ver1-serial/src.main.java.net.minecraftforge.common.interpreter.AST.java-apply.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:35:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+work[i+1+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/2703/pattern-ver1-serial/src.main.java.net.minecraftforge.common.interpreter.AST.java-apply.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,work[i+1+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/2703/pattern-ver1-serial/src.main.java.net.minecraftforge.common.interpreter.AST.java-apply.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+initialSplits(n);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/5726/pattern-ver1-serial/library.src.main.java.com.cocosw.bottomsheet.ClosableSlidingLayout.java-onViewReleased.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+initialSplits(n);
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/5726/pattern-ver1-serial/library.src.main.java.com.cocosw.bottomsheet.ClosableSlidingLayout.java-onViewReleased.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+n=n;
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V31/432/pattern-ver1-serial/src.arcane_arcade_menus.MainMenuMenuCreator.java-MainMenuElement.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+i=i;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V31/432/pattern-ver1-serial/src.arcane_arcade_menus.MainMenuMenuCreator.java-MainMenuElement.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong+sumOffDiag==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3750/pattern-ver1-serial/src.main.java.de.tudarmstadt.awesome.erclaerung.precomputation.LevenshteinStep.java-getAdjustedString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag+n==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3750/pattern-ver1-serial/src.main.java.de.tudarmstadt.awesome.erclaerung.precomputation.LevenshteinStep.java-getAdjustedString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag+sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3750/pattern-ver1-serial/src.main.java.de.tudarmstadt.awesome.erclaerung.precomputation.LevenshteinStep.java-getAdjustedString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong+n==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3750/pattern-ver1-serial/src.main.java.de.tudarmstadt.awesome.erclaerung.precomputation.LevenshteinStep.java-getAdjustedString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong+i0==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3750/pattern-ver1-serial/src.main.java.de.tudarmstadt.awesome.erclaerung.precomputation.LevenshteinStep.java-getAdjustedString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong+n0==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3750/pattern-ver1-serial/src.main.java.de.tudarmstadt.awesome.erclaerung.precomputation.LevenshteinStep.java-getAdjustedString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
+n0=n0;
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/1236/pattern-ver1-serial/providers.dynect.src.main.java.org.jclouds.dynect.v3.domain.Zone.java-Zone.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>=5){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/1455/pattern-ver1-serial/NumbersFlow.src.com.braingames.sdk.numbersflow.ScoreDatabase.java-getFirstFiveScores.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<4;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/1764/pattern-ver1-serial/src.main.java.ua.com.ecotep.debtprevention.MainController.java-handleArchiveAction.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+1;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/688/pattern-ver1-serial/src.it.demo.src.main.java.com.example.demo.Target.java-create.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ final double ei=work[1];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[1]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,work[1]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:36:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,work[1]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+work[1]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,work[1]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
+initialSplits(n);
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1266/pattern-ver1-serial/catroid.src.org.catrobat.catroid.livewallpaper.LiveWallpaper.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 1, DEL : 2
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+work[fourI+2]=1000;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V4/3726/pattern-ver1-serial/WeatherService.src.weatherservice.StatisticsCalculator.java-MinWindSpeed.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
+diagMin=1000;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V4/3726/pattern-ver1-serial/WeatherService.src.weatherservice.StatisticsCalculator.java-MinWindSpeed.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+offDiagMin=1000;
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V4/3726/pattern-ver1-serial/WeatherService.src.weatherservice.StatisticsCalculator.java-MinWindSpeed.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+3;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/7749/pattern-ver1-serial/HowOld.src.com.gzfgeh.customview.MyHorizontalScrollView.java-initDatas.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(true){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(true){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<3;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/3819/pattern-ver1-serial/BootPrepWeb.src.controllers.UserController.java-validInputs.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*2;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/1120/pattern-ver1-serial/src.main.java.com.pratilipi.data.util.PratilipiDataUtil.java-updatePratilipiStats.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+int maxIter=30*2;
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/1120/pattern-ver1-serial/src.main.java.com.pratilipi.data.util.PratilipiDataUtil.java-updatePratilipiStats.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
+return ;
+}
+if(n<0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/1167/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.router.Publishers.java-receivedData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:37:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
+if(n<0){
+return ;
+}
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/1167/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.router.Publishers.java-receivedData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
+}
+if(n0<0){
+return ;
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/1167/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.router.Publishers.java-receivedData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:05 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
+if(n0<0){
+return ;
+}
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/1167/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.router.Publishers.java-receivedData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
+if(n0<0){
+return ;
+}
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/1167/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.router.Publishers.java-receivedData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+if(offDiagMax<0){
+return ;
+}
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/1167/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.router.Publishers.java-receivedData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+if(diagMin<0){
+return ;
+}
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/1167/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.router.Publishers.java-receivedData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
+if(offDiagMax<0){
+return ;
+}
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/1167/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.router.Publishers.java-receivedData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
+if(diagMin<0){
+return ;
+}
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/1167/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.router.Publishers.java-receivedData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
+if(offDiagMin<0){
+return ;
+}
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/1167/pattern-ver1-serial/datakit.src.main.java.org.md2k.datakit.router.Publishers.java-receivedData.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
+n0=3;
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/101/pattern-ver1-serial/PageRank.PageRank.java-PageRank.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<n;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/6999/pattern-ver1-serial/src.mop.MopData.java-str2Mop.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:-work[2-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/2024/pattern-ver1-serial/src.server.MessageHandler.java-clientPing.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:work[2-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/2024/pattern-ver1-serial/src.server.MessageHandler.java-clientPing.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
-double diagMax=work[4*n0-4];
+double diagMax=work[2-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V24/2024/pattern-ver1-serial/src.server.MessageHandler.java-clientPing.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ final double ei=work[0];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/5785/pattern-ver1-serial/src.Seminars.first.collections.ArrayPriorityQueue.java-extractMin.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[0]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/5785/pattern-ver1-serial/src.Seminars.first.collections.ArrayPriorityQueue.java-extractMin.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,work[0]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/5785/pattern-ver1-serial/src.Seminars.first.collections.ArrayPriorityQueue.java-extractMin.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,work[0]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/5785/pattern-ver1-serial/src.Seminars.first.collections.ArrayPriorityQueue.java-extractMin.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:38:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+work[0]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/5785/pattern-ver1-serial/src.Seminars.first.collections.ArrayPriorityQueue.java-extractMin.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=0xEfffffff&(0);
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/1711/pattern-ver1-serial/src.main.java.com.ociweb.pronghorn.ring.RingWriter.java-writeBytes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
-dMin1=0;
+dMin1=0xEfffffff&(0);
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/1711/pattern-ver1-serial/src.main.java.com.ociweb.pronghorn.ring.RingWriter.java-writeBytes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
-dMin2=0;
+dMin2=0xEfffffff&(0);
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/1711/pattern-ver1-serial/src.main.java.com.ociweb.pronghorn.ring.RingWriter.java-writeBytes.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
-pingPong=1-pingPong;
+pingPong=10;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ final double ei=work[2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,work[2]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,work[2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+work[2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,work[2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
-while(n0>0){
+while(n0>0/2){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/7651/pattern-ver1-serial/src.net.vicp.lylab.utils.cache.CacheContainer.java-exec.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3/2)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/7651/pattern-ver1-serial/src.net.vicp.lylab.utils.cache.CacheContainer.java-exec.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
+int a=0;
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
+int a=0;
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
+int a=0;
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+int a=0;
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+int a=0;
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+int a=0;
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:39:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+int a=0;
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+int a=0;
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+int a=0;
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
+int a=0;
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V24/5087/pattern-ver1-serial/app.src.main.java.ru.alexandersurinov.androidtimereportingsystem.repository.ProjectRepository.java-onFailure.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(2.0*(diagMax),work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3214/pattern-ver1-serial/src.agents.manic.TransitionModel.java-anticipateNextBeliefsInPlace.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(2.0*(diagMin),work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3214/pattern-ver1-serial/src.agents.manic.TransitionModel.java-anticipateNextBeliefsInPlace.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(2.0*(offDiagMax),work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3214/pattern-ver1-serial/src.agents.manic.TransitionModel.java-anticipateNextBeliefsInPlace.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(2.0*(offDiagMin),work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3214/pattern-ver1-serial/src.agents.manic.TransitionModel.java-anticipateNextBeliefsInPlace.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*n0-2*5;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V35/2098/pattern-ver1-serial/src.com.wecanteven.Models.Stats.HealthStat.java-update.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+int maxIter=30*n0-i0*5;
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V35/2098/pattern-ver1-serial/src.com.wecanteven.Models.Stats.HealthStat.java-update.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
-pingPong=1-pingPong;
+pingPong=1;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/6985/pattern-ver1-serial/src.org.broad.igv.track.DataTrack.java-getInViewScores.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=((n0==n))?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/7415/pattern-ver1-serial/app.src.main.java.com.metinkale.prayerapp.compass.Main.java-onRotationUpdate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=((i0==n0))?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V42/7415/pattern-ver1-serial/app.src.main.java.com.metinkale.prayerapp.compass.Main.java-onRotationUpdate.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if(ei==0.0){
+continue;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4118/pattern-ver1-serial/src.behavior.irl.TabularIRL.java-getBehaviorLogProbabilityHelper.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
+if(offDiagMin==0.0){
+continue;
+}
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4118/pattern-ver1-serial/src.behavior.irl.TabularIRL.java-getBehaviorLogProbabilityHelper.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:40:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
+if(diagMin==0.0){
+continue;
+}
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4118/pattern-ver1-serial/src.behavior.irl.TabularIRL.java-getBehaviorLogProbabilityHelper.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:42:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
+if(offDiagMax==0.0){
+continue;
+}
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4118/pattern-ver1-serial/src.behavior.irl.TabularIRL.java-getBehaviorLogProbabilityHelper.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:44:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
+if(diagMax==0.0){
+continue;
+}
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4118/pattern-ver1-serial/src.behavior.irl.TabularIRL.java-getBehaviorLogProbabilityHelper.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:44:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
+if(offDiagMin==0.0){
+continue;
+}
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/4118/pattern-ver1-serial/src.behavior.irl.TabularIRL.java-getBehaviorLogProbabilityHelper.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:44:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
+String OUTSTRING="";
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:45:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+String OUTSTRING="";
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:45:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+String OUTSTRING="";
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:45:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
+String OUTSTRING="";
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:45:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+String OUTSTRING="";
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:45:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+String OUTSTRING="";
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:45:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+String OUTSTRING="";
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:45:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+String OUTSTRING="";
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:45:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
+String OUTSTRING="";
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V49/487/pattern-ver1-serial/api.src.main.java.v1.rest.LabelsResource.java-getLabel_XML.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:45:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.util.concurrent.Executors;
+
+import java.util.concurrent.ExecutorService;
+
+import java.util.Collections;
+
+import java.util.Map;
+
+import java.util.HashMap;
+
+import java.util.concurrent.TimeUnit;
+
+import java.util.concurrent.LinkedBlockingDeque;
+
+import java.util.ArrayList;
+
+import java.util.Comparator;
+
+import java.util.List;
+
+import java.util.concurrent.BlockingQueue;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+import java.util.concurrent.Semaphore;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/777/pattern-ver1-serial/src.java.picard.sam.markduplicates.EstimateLibraryComplexity.java-EstimateLibraryComplexity.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:47:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
-pingPong=1-pingPong;
+pingPong=100;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:47:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>=0.0){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/3703/pattern-ver1-serial/Muehle_Master.src.de.dhbw.muehle.model.theme.Sound.java-fade.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:47:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
-while(n0>0){
+while(true){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V45/1657/pattern-ver1-serial/reversi.src.main.java.org.kratos.reversi.application.View.java-run.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:47:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<5;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/7269/pattern-ver1-serial/src.infovis.piechart.Data.java-Data.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:47:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
+n0=1;
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V21/6053/pattern-ver1-serial/src.monopoly.Dice.java-throwIt.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:47:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.max(0,diagMin-2*Math.sqrt((int)(diagMin*offDiagMax)));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/6653/pattern-ver1-serial/Character.java-setCharstat.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:47:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
- final double ei=work[fourI+2];
+ final double ei=work[fourI];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V53/2063/pattern-ver1-serial/src.minecraft.co.uk.flansmods.common.BlockPlaneWorkbench.java-getBlockTextureFromSideAndMetadata.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:47:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*4;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4905/pattern-ver1-serial/app_android.src.com.projectkaiser.app_android.MainActivity.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:49:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+int maxIter=30*4;
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/4905/pattern-ver1-serial/app_android.src.com.projectkaiser.app_android.MainActivity.java-getView.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:49:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(Math.round(diagMin),work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V16/7706/pattern-ver1-serial/pixi.src.main.java.org.openpixi.pixi.diagnostics.methods.ProjectedEnergyDensity.java-initialize.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:49:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(Math.round(offDiagMax),work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V16/7706/pattern-ver1-serial/pixi.src.main.java.org.openpixi.pixi.diagnostics.methods.ProjectedEnergyDensity.java-initialize.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:49:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(Math.abs(diagMin)>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V5/5309/pattern-ver1-serial/IHMCJavaToolkit.src.us.ihmc.tools.FormattingTools.java-getFormattedToSignificantFigures.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2);Math.abs(i)>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V5/5309/pattern-ver1-serial/IHMCJavaToolkit.src.us.ihmc.tools.FormattingTools.java-getFormattedToSignificantFigures.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(Math.abs(k)>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V5/5309/pattern-ver1-serial/IHMCJavaToolkit.src.us.ihmc.tools.FormattingTools.java-getFormattedToSignificantFigures.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(Double.isNaN(sumOffDiag)){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V32/1622/pattern-ver1-serial/src.mckay.utilities.staticlibraries.StringMethods.java-getDoubleInScientificNotation.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(Double.isNaN(k)){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V32/1622/pattern-ver1-serial/src.mckay.utilities.staticlibraries.StringMethods.java-getDoubleInScientificNotation.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+(int)(i/4);
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/4690/pattern-ver1-serial/33_CDIO3.src.controller.DecisionController.java-askForDecision.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:21 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:24 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+ final String emailPattern="[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+";
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5976/pattern-ver1-serial/rhymecity.src.main.java.com.fly.firefly.ui.activity.Login.LoginFragment.java-forgotPassword.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+}
 }
+if(n0<=0){
+return ;
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
+if(sigma<=0){
+return ;
+}
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:42 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+}
 }
 }
+if(sigma<=0){
+return ;
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+}
 }
+if(pingPong<=0){
+return ;
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
+if(i0<=0){
+return ;
+}
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
+if(pingPong<=0){
+return ;
+}
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
+if(n0<=0){
+return ;
+}
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:50:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+}
 }
 }
+if(n0<=0){
+return ;
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:51:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+}
 }
 }
+if(i0<=0){
+return ;
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:51:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
+if(pingPong<=0){
+return ;
+}
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V25/2367/pattern-ver1-serial/ikrs.io.ReadLimitInputStream.java-read.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:51:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
+int maxIter=30*n0;
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/2671/pattern-ver1-serial/Project.EncryptaBackend.src.Converter.java-binaryStringToString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:51:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*n0;i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/2671/pattern-ver1-serial/Project.EncryptaBackend.src.Converter.java-binaryStringToString.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.max(0,diagMin-2*Math.sqrt(1.0*diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V46/7751/pattern-ver1-serial/src.main.java.info.debatty.java.stringsimilarity.Cosine.java-norm.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.max(0,1.0*diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V46/7751/pattern-ver1-serial/src.main.java.info.debatty.java.stringsimilarity.Cosine.java-norm.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i-1]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V41/5494/pattern-ver1-serial/src.war.core.War.java-addLauncher.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+-1;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4243/pattern-ver1-serial/app.src.main.java.com.ryanwedoff.senor.naoservercontroller.WalkFragment.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V28/4132/pattern-ver1-serial/MainProject.src.se.chalmers.dat255.risk.view.ProvinceView.java-getTextY.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:26 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
-for(int i=0;i<n-1;++i){
+for(int i=0;i<n-1;Math.abs(++i)){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1979/pattern-ver1-serial/h2o-algos.src.main.java.hex.tree.gbm.GBM.java-map.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.max(0,diagMin-2*Math.sqrt(Math.abs(diagMin*offDiagMax)));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1979/pattern-ver1-serial/h2o-algos.src.main.java.hex.tree.gbm.GBM.java-map.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
-initialSplits(n);
+initialSplits(Math.abs(n));
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1979/pattern-ver1-serial/h2o-algos.src.main.java.hex.tree.gbm.GBM.java-map.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
-for(int i=4*(n0-2);i>=0;i-=4){
+for(int i=4*(n0-2);i>=0;Math.abs(i-=4)){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1979/pattern-ver1-serial/h2o-algos.src.main.java.hex.tree.gbm.GBM.java-map.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
-for(int k=0;i0<n0;++k){
+for(int k=0;i0<n0;Math.abs(++k)){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1979/pattern-ver1-serial/h2o-algos.src.main.java.hex.tree.gbm.GBM.java-map.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+(int)i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/6656/pattern-ver1-serial/src.game.Game.java-main.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 3, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+if(i0==0){
+return ;
+}
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
+}
+if(i0==0){
+return ;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+}
+if(i0==0){
+return ;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:53:57 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+}
 }
 }
+if(i0==0){
+return ;
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:54:00 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+}
 }
+if(n0==0){
+return ;
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:54:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+if(diagMin==0){
+return ;
+}
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:54:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+if(offDiagMax==0){
+return ;
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:54:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+}
+if(diagMin==0){
+return ;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:54:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
+if(n0==0){
+return ;
+}
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/331/pattern-ver1-serial/flink-runtime.src.main.java.org.apache.flink.runtime.operators.hash.ReduceHashTable.java-EntryIterator.pattern
MATCHLEVEL : ALL
ALL : 3, UPD : 0, INS : 3, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:54:16 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,30-(work[i+4]));
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/1792/pattern-ver1-serial/rangebar.src.com.appyvet.rangebar.RangeBar.java-onAnimationUpdate.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:54:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,30-(work[i+2]));
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/1792/pattern-ver1-serial/rangebar.src.com.appyvet.rangebar.RangeBar.java-onAnimationUpdate.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:54:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Solution---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+flipIfWarranted(n,2);
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
-flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:54:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Solution---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
-flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+flipIfWarranted(n,2);
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:54:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Solution---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
-flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
+flipIfWarranted(n,2);
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:55:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Solution---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
-flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
+flipIfWarranted(n,2);
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/5555/pattern-ver1-serial/src.main.java.TeamRoots.Goetia.client.gui.GuiFocus.java-mouseReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:55:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Solution---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+flipIfWarranted(n,2);
 }
 if(sumOffDiag==0){
 return ;
 }
-flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V2/4414/pattern-ver1-serial/crawler.src.crawler.Crawler.java-onStatus.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:55:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Solution---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
-flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
+flipIfWarranted(n,2);
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V23/6741/pattern-ver1-serial/core.src.main.java.org.jahia.modules.external.ExternalSessionImpl.java-move.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:56:02 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Solution---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
-flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+flipIfWarranted(n,2);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/5726/pattern-ver1-serial/library.src.main.java.com.cocosw.bottomsheet.ClosableSlidingLayout.java-onViewReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:56:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Solution---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
-flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+flipIfWarranted(n,2);
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V3/5726/pattern-ver1-serial/library.src.main.java.com.cocosw.bottomsheet.ClosableSlidingLayout.java-onViewReleased.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:56:34 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
-i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+i0=0;
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1950/pattern-ver1-serial/Node.java-eventDelete.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:56:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
-pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+pingPong=0;
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1950/pattern-ver1-serial/Node.java-eventDelete.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:56:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+i0=0;
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1950/pattern-ver1-serial/Node.java-eventDelete.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:56:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+pingPong=0;
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1950/pattern-ver1-serial/Node.java-eventDelete.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:56:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+i0=0;
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1950/pattern-ver1-serial/Node.java-eventDelete.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:56:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
+pingPong=0;
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
-pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V4/389/pattern-ver1-serial/src.profilGestion.java-gestion.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:56:52 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+1);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V27/688/pattern-ver1-serial/src.it.demo.src.main.java.com.example.demo.Target.java-create.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:56:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Solution---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
+flipIfWarranted(n,2);
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
-flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V20/1266/pattern-ver1-serial/catroid.src.org.catrobat.catroid.livewallpaper.LiveWallpaper.java-onCreate.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+3);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/7749/pattern-ver1-serial/HowOld.src.com.gzfgeh.customview.MyHorizontalScrollView.java-initDatas.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
+sigmaLow=0;
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/2094/pattern-ver1-serial/src.main.java.com.dagobert_engine.core.service.UpdateService.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
+pingPong=0;
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
-pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/2094/pattern-ver1-serial/src.main.java.com.dagobert_engine.core.service.UpdateService.java-run.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:19 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag==0||sumOffDiag==Long.MIN_VALUE){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V5/7087/pattern-ver1-serial/BDEBase.src.main.java.gr.demokritos.iit.base.util.Utils.java-extractYearMonthDayLiteral.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter||k==Long.MIN_VALUE){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V5/7087/pattern-ver1-serial/BDEBase.src.main.java.gr.demokritos.iit.base.util.Utils.java-extractYearMonthDayLiteral.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
+if(sumOffDiag==12){
+return ;
+}else {
 if(sumOffDiag==0){
 return ;
+}
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V39/4902/pattern-ver1-serial/app.src.main.java.com.cs180project.ucrclasses.BaseCalendarActivity.java-interpretTime.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
+double offDiagMax=0;
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
-double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,2.0*(work[i+4]));
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3214/pattern-ver1-serial/src.agents.manic.TransitionModel.java-anticipateNextBeliefsInPlace.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,2.0*(work[i+2]));
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3214/pattern-ver1-serial/src.agents.manic.TransitionModel.java-anticipateNextBeliefsInPlace.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,2.0*(work[i+2]));
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3214/pattern-ver1-serial/src.agents.manic.TransitionModel.java-anticipateNextBeliefsInPlace.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
-int i0=0;
 int n0=n;
 while(n0>0){
+int i0=0;
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V40/2943/pattern-ver1-serial/hadoop.order_inversion.src.main.java.org.mdp.learn.hadoop.order_inversion.pairs.CoOccurrenceMatrixMapperWithPairs.java-map.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
+sigmaLow=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
-sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V48/2335/pattern-ver1-serial/app.src.main.java.swampthings.dems.LoginActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
+pingPong=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
-pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V48/2335/pattern-ver1-serial/app.src.main.java.swampthings.dems.LoginActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 0, INS : 1, DEL : 3
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i++]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
-if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
+if((work[i+3]<=TOLERANCE_2*work[i++])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3938/pattern-ver1-serial/src.main.java.de.topobyte.osm4j.geometry.CoordinateSequencesBuilder.java-createGeometry.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,Math.round(work[i+4]));
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V16/7706/pattern-ver1-serial/pixi.src.main.java.org.openpixi.pixi.diagnostics.methods.ProjectedEnergyDensity.java-initialize.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+(int)(work[i+2]));
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/4690/pattern-ver1-serial/33_CDIO3.src.controller.DecisionController.java-askForDecision.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+-1);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V12/4243/pattern-ver1-serial/app.src.main.java.com.ryanwedoff.senor.naoservercontroller.WalkFragment.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:57:59 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=-1;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
-i0=0;
+i0=-1;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/446/pattern-ver1-serial/core.src.game.MathAlgorithms.mathQCreator.java-getPathsArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=-1;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
-pingPong=0;
+pingPong=-1;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/446/pattern-ver1-serial/core.src.game.MathAlgorithms.mathQCreator.java-getPathsArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
-i0=0;
+i0=-1;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
-pingPong=0;
+pingPong=-1;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/446/pattern-ver1-serial/core.src.game.MathAlgorithms.mathQCreator.java-getPathsArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=-1;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
-tau=0;
+tau=-1;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/446/pattern-ver1-serial/core.src.game.MathAlgorithms.mathQCreator.java-getPathsArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
-dMin1=0;
+tType=-1;
+dMin1=-1;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/446/pattern-ver1-serial/core.src.game.MathAlgorithms.mathQCreator.java-getPathsArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=-1;
 dMin1=0;
-dMin2=0;
+dMin2=-1;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/446/pattern-ver1-serial/core.src.game.MathAlgorithms.mathQCreator.java-getPathsArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=-1;
 dMin1=0;
 dMin2=0;
-dN=0;
+dN=-1;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/446/pattern-ver1-serial/core.src.game.MathAlgorithms.mathQCreator.java-getPathsArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=-1;
 dMin1=0;
 dMin2=0;
 dN=0;
-dN1=0;
+dN1=-1;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/446/pattern-ver1-serial/core.src.game.MathAlgorithms.mathQCreator.java-getPathsArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
-tType=0;
+tType=-1;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
-dN2=0;
+dN2=-1;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/446/pattern-ver1-serial/core.src.game.MathAlgorithms.mathQCreator.java-getPathsArray.pattern
MATCHLEVEL : ALL
ALL : 4, UPD : 4, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag==0||"查看红包".equals(sumOffDiag)){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter||"查看红包".equals(k)){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>=4*offDiagMax||"查看红包".equals(diagMin)){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:31 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag==0||sumOffDiag==3){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/1380/pattern-ver1-serial/Cluedo.src.control.Player.java-validMove.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter||k==3){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/1380/pattern-ver1-serial/Cluedo.src.control.Player.java-validMove.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>=4*offDiagMax||diagMin==3){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/1380/pattern-ver1-serial/Cluedo.src.control.Player.java-validMove.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:39 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V5/2320/pattern-ver1-serial/mp4.src.main.java.edu.illinois.cs.mapreduce.JobManager.java-updateJobStatus.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=-1;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2043/pattern-ver1-serial/src.main.java.net.floodlightcontroller.firewall.FirewallRule.java-FirewallRule.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=0;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V64/1097/pattern-ver1-serial/plugins.de.ovgu.featureide.core.mpl.src.de.ovgu.featureide.core.mpl.signature.javadoc.AJavaDocCommentMerger.java-parseTags.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>=4*offDiagMax||4=='%'){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V5/6049/pattern-ver1-serial/src.main.java.org.wltea.analyzer.core.LaTeXSegmenter.java-addOperatorFormula.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+if(n>7){
+throw new InvalidMatrixException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
+}
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:53 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
+if(diagMin>7){
+throw new InvalidMatrixException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
+}
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
+if(offDiagMax>7){
+throw new InvalidMatrixException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
+}
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:58:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
+if(offDiagMin>7){
+throw new InvalidMatrixException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
+}
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
+if(diagMax>7){
+throw new InvalidMatrixException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
+}
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
+if(offDiagMax>7){
+throw new InvalidMatrixException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
+}
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
+if(diagMin>7){
+throw new InvalidMatrixException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
+}
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:09 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
+if(n0>7){
+throw new InvalidMatrixException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
+}
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:12 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
+if(i>7){
+throw new InvalidMatrixException("Sorry, it is impossible to determine what number it is in canonical form if base is larger than 7. \n Use rational fraction or sequence representation.");
+}
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/4557/pattern-ver1-serial/p-adic.src.main.java.vvk.numbers.PAdic.java-PAdic.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:15 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/4298/pattern-ver1-serial/anglewyrm.src.BlockHouse.java-addBlockToTown.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=3;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V4/3200/pattern-ver1-serial/app.src.main.java.com.example.jarvus.tummybuddy.DisplayMenuActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag<0||sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1602/pattern-ver1-serial/src.engine.network.server.ServerClient.java-knowMap.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k<0||k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1602/pattern-ver1-serial/src.engine.network.server.ServerClient.java-knowMap.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin<0||diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1602/pattern-ver1-serial/src.engine.network.server.ServerClient.java-knowMap.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:28 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:-work[1];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:30 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:work[1];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
-double diagMax=work[4*n0-4];
+double diagMax=work[1];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/6103/pattern-ver1-serial/src.br.unicamp.ic.recod.gpsi.applications.gpsiJGAPEvolver.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:36 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(true){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:38 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
+n0=(goodStep(i0,n0)+n0)%n0;
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
+n0=(goodStep(i0,n0)+i0)%i0;
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:44 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
-pingPong=1-pingPong;
+pingPong=(1-pingPong+pingPong)%pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.07 AD at 23:59:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*n;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V29/276/pattern-ver1-serial/src.Body.java-move.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:01:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*i;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V29/276/pattern-ver1-serial/src.Body.java-move.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:03:46 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*i0;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V29/276/pattern-ver1-serial/src.Body.java-move.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:03:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*n0;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V29/276/pattern-ver1-serial/src.Body.java-move.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:05:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=600;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SniperAssassinate.java-SniperAssassinate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:07:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=n;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/3010/pattern-ver1-serial/rakam-spi.src.main.java.com.facebook.presto.sql.RakamSqlFormatter.java-Formatter.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:09:49 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=i;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/3010/pattern-ver1-serial/rakam-spi.src.main.java.com.facebook.presto.sql.RakamSqlFormatter.java-Formatter.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:11:50 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=i0;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/3010/pattern-ver1-serial/rakam-spi.src.main.java.com.facebook.presto.sql.RakamSqlFormatter.java-Formatter.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:11:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=n0;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/3010/pattern-ver1-serial/rakam-spi.src.main.java.com.facebook.presto.sql.RakamSqlFormatter.java-Formatter.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:13:54 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>=4*offDiagMax||diagMin==Long.MIN_VALUE){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V5/7087/pattern-ver1-serial/BDEBase.src.main.java.gr.demokritos.iit.base.util.Utils.java-extractYearMonthDayLiteral.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:13:56 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
-sumOffDiag+=ei;
+sumOffDiag+=ei<0?0:ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V42/1445/pattern-ver1-serial/src.main.java.com.laudandjolynn.csvtools.CsvFile.java-CsvFile.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:14:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
-work[4*n0-2]=offDiagMin;
+work[4*n0-2]=offDiagMin<0?0:offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V42/1445/pattern-ver1-serial/src.main.java.com.laudandjolynn.csvtools.CsvFile.java-CsvFile.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:14:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[0]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/5785/pattern-ver1-serial/src.Seminars.first.collections.ArrayPriorityQueue.java-extractMin.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:14:07 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:-work[0];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/5785/pattern-ver1-serial/src.Seminars.first.collections.ArrayPriorityQueue.java-extractMin.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:14:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:work[0];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/5785/pattern-ver1-serial/src.Seminars.first.collections.ArrayPriorityQueue.java-extractMin.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:14:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
-double diagMax=work[4*n0-4];
+double diagMax=work[0];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/5785/pattern-ver1-serial/src.Seminars.first.collections.ArrayPriorityQueue.java-extractMin.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:14:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=10;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkDarkPact.java-SlarkDarkPact.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:16:18 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[2]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:16:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:-work[2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:16:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:work[2];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V2/963/pattern-ver1-serial/src.com.ict.apps.bobb.battle.BattleUtil.java-getJudgeResult.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:16:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag==0||sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1056/pattern-ver1-serial/lts-admin.src.main.java.com.github.ltsopensource.admin.web.api.SuspendJobQueueApi.java-suspendJobRecovery.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:16:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>=4*offDiagMax||diagMin==0){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1056/pattern-ver1-serial/lts-admin.src.main.java.com.github.ltsopensource.admin.web.api.SuspendJobQueueApi.java-suspendJobRecovery.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:16:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter||k==0){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1056/pattern-ver1-serial/lts-admin.src.main.java.com.github.ltsopensource.admin.web.api.SuspendJobQueueApi.java-suspendJobRecovery.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:16:41 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag==0||sumOffDiag>9){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2964/pattern-ver1-serial/main.plugins.org.talend.dataquality.sampling.src.main.java.org.talend.dataquality.datamasking.FunctionApplier.java-generateDuplicate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:16:45 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter||k>9){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2964/pattern-ver1-serial/main.plugins.org.talend.dataquality.sampling.src.main.java.org.talend.dataquality.datamasking.FunctionApplier.java-generateDuplicate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:16:48 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>=4*offDiagMax||diagMin>9){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2964/pattern-ver1-serial/main.plugins.org.talend.dataquality.sampling.src.main.java.org.talend.dataquality.datamasking.FunctionApplier.java-generateDuplicate.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:16:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=100;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.TemplarAssassinRefraction.java-TemplarAssassinRefraction.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:18:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:18:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:18:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:19:03 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:19:06 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:19:10 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:19:13 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import javax.swing.JOptionPane;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
+JOptionPane.showMessageDialog(null,"No se pudo cargar la canci�n","Error",JOptionPane.ERROR_MESSAGE);
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/7753/pattern-ver1-serial/src.entities.Playlist.java-putInMemory.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 0, INS : 5, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:19:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag==0&&sumOffDiag<4000000){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/46/pattern-ver1-serial/raw.master.registryKit.registryKit.registryKit.src.main.java.com.registryKit.survey.surveyManager.java-saveSurveyDocument.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:19:22 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter&&k<4000000){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/46/pattern-ver1-serial/raw.master.registryKit.registryKit.registryKit.src.main.java.com.registryKit.survey.surveyManager.java-saveSurveyDocument.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:19:25 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>=4*offDiagMax&&diagMin<4000000){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/46/pattern-ver1-serial/raw.master.registryKit.registryKit.registryKit.src.main.java.com.registryKit.survey.surveyManager.java-saveSurveyDocument.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:19:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/1083/pattern-ver1-serial/action-adventure.src.main.java.niellebeck.game.PlayerCharacter.java-PlayerCharacter.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:19:33 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(Double.isNaN(diagMin)){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V32/1622/pattern-ver1-serial/src.mckay.utilities.staticlibraries.StringMethods.java-getDoubleInScientificNotation.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:19:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=5;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V40/26/pattern-ver1-serial/src.android.com.terrydr.eyeScope.CameraActivity.java-onClick.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:21:37 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(sumOffDiag==0&&sumOffDiag!=9999){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5798/pattern-ver1-serial/SONPlugin.src.org.workcraft.plugins.son.granularity.HourMins.java-getHour.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:21:40 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter&&k!=9999){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5798/pattern-ver1-serial/SONPlugin.src.org.workcraft.plugins.son.granularity.HourMins.java-getHour.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:21:43 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(diagMin>=4*offDiagMax&&diagMin!=9999){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5798/pattern-ver1-serial/SONPlugin.src.org.workcraft.plugins.son.granularity.HourMins.java-getHour.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:21:47 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(maxIter>0&&k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/553/pattern-ver1-serial/src.main.java.edu.berkeley.cs.nlp.ocular.main.TrainFont.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:21:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
-if(sumOffDiag==0){
+if(0>0&&sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/553/pattern-ver1-serial/src.main.java.edu.berkeley.cs.nlp.ocular.main.TrainFont.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:21:55 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
+if(4*offDiagMax>0&&diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/553/pattern-ver1-serial/src.main.java.edu.berkeley.cs.nlp.ocular.main.TrainFont.java-run.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:21:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=700;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6884/pattern-ver1-serial/src.main.java.us.sharknet.dota.model.ability.SlarkPounce.java-SlarkPounce.pattern
MATCHLEVEL : ALL
ALL : 5, UPD : 5, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:23:58 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+2]<=0||"查看红包".equals(work[i+2])){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:01 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+2]<=0||work[i+2]==3){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V30/1380/pattern-ver1-serial/Cluedo.src.control.Player.java-validMove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:04 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+n0=goodStep(i0,n0);
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:08 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+n0=goodStep(i0,n0);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:11 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+2]<0||work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V7/1602/pattern-ver1-serial/src.engine.network.server.ServerClient.java-knowMap.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:14 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+n0=goodStep(i0,n0);
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2665/pattern-ver1-serial/channel.src.main.java.com.github.dm.jrt.channel.ReplayChannel.java-onError.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:17 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
+n0=goodStep(i0,n0);
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6349/pattern-ver1-serial/src.com.example.smartphone.SelectECActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:20 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+pingPong=1-pingPong;
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1950/pattern-ver1-serial/Node.java-eventDelete.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:23 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+n0=goodStep(i0,n0);
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1950/pattern-ver1-serial/Node.java-eventDelete.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:27 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+pingPong=1-pingPong;
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1950/pattern-ver1-serial/Node.java-eventDelete.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:29 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+n0=goodStep(i0,n0);
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V4/389/pattern-ver1-serial/src.profilGestion.java-gestion.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:32 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+pingPong=1-pingPong;
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
-pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V4/389/pattern-ver1-serial/src.profilGestion.java-gestion.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:35 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Solution---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
+pingPong=1-pingPong;
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V4/389/pattern-ver1-serial/src.profilGestion.java-gestion.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
+n0=goodStep(i0,n0);
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/2884/pattern-ver1-serial/src.edu.asu.laits.gui.nodeeditor.CalculationsPanelView.java-processNodeEquation.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+if(i0<0){
+i0=0;
+}
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
+}
+if(i0<0){
+i0=0;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+}
+if(i0<0){
+i0=0;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+}
 }
 }
+if(i0<0){
+i0=0;
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+}
 }
+if(n0<0){
+n0=0;
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+if(diagMin<0){
+diagMin=0;
+}
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+if(offDiagMax<0){
+offDiagMax=0;
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+}
+if(diagMin<0){
+diagMin=0;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+}
+if(offDiagMax<0){
+offDiagMax=0;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+}
+if(offDiagMin<0){
+offDiagMin=0;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V6/4394/pattern-ver1-serial/src.main.java.cloudsync.connector.RemoteGoogleDriveConnector.java-remove.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
+n0=goodStep(i0,n0);
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V4/1884/pattern-ver1-serial/src.java.is.idega.idegaweb.pheidippides.presentation.ParticipantsReport.java-initializeComponent.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
+if(i<0){
+return ;
+}
  final int fourI=4*i;
+if(i>=fourI){
+return ;
+}
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/4307/pattern-ver1-serial/src.structures.MatrixUtilities.java-getColumnGroup.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
+if(i<0){
+return ;
+}
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if(i>=ei){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/4307/pattern-ver1-serial/src.structures.MatrixUtilities.java-getColumnGroup.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+if(fourI<0){
+return ;
+}
+if(fourI>=i){
+return ;
+}
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/4307/pattern-ver1-serial/src.structures.MatrixUtilities.java-getColumnGroup.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+if(fourI<0){
+return ;
+}
  final double ei=work[fourI+2];
+if(fourI>=ei){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/4307/pattern-ver1-serial/src.structures.MatrixUtilities.java-getColumnGroup.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if(ei<0){
+return ;
+}
+if(ei>=i){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/4307/pattern-ver1-serial/src.structures.MatrixUtilities.java-getColumnGroup.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if(ei<0){
+return ;
+}
+if(ei>=fourI){
+return ;
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/4307/pattern-ver1-serial/src.structures.MatrixUtilities.java-getColumnGroup.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+if(offDiagMax<0){
+return ;
+}
+if(offDiagMax>=diagMin){
+return ;
+}
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/4307/pattern-ver1-serial/src.structures.MatrixUtilities.java-getColumnGroup.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+if(diagMin<0){
+return ;
+}
+if(diagMin>=offDiagMax){
+return ;
+}
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/4307/pattern-ver1-serial/src.structures.MatrixUtilities.java-getColumnGroup.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+if(offDiagMin<0){
+return ;
+}
+if(offDiagMin>=offDiagMax){
+return ;
+}
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/4307/pattern-ver1-serial/src.structures.MatrixUtilities.java-getColumnGroup.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+if(offDiagMin<0){
+return ;
+}
+if(offDiagMin>=diagMax){
+return ;
+}
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/4307/pattern-ver1-serial/src.structures.MatrixUtilities.java-getColumnGroup.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(true){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
+pingPong=1-pingPong;
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V29/2094/pattern-ver1-serial/src.main.java.com.dagobert_engine.core.service.UpdateService.java-run.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
+if(offDiagMax<=0){
+offDiagMax=1;
+}
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/1761/pattern-ver1-serial/JazminServer.src.jazmin.core.monitor.DispatcherMonitorAgent.java-sample.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
+if(diagMin<=0){
+diagMin=1;
+}
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/1761/pattern-ver1-serial/JazminServer.src.jazmin.core.monitor.DispatcherMonitorAgent.java-sample.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
+n0=goodStep(i0,n0);
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/7429/pattern-ver1-serial/library.src.main.java.com.datatorrent.lib.appdata.qr.processor.AbstractWEQueryQueueManager.java-enqueueHelper.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
+n0=goodStep(i0,n0);
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/7429/pattern-ver1-serial/library.src.main.java.com.datatorrent.lib.appdata.qr.processor.AbstractWEQueryQueueManager.java-enqueueHelper.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
+if(offDiagMax>diagMin){
+offDiagMax=diagMin;
+}
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/5173/pattern-ver1-serial/src.com.sbar.rebudget.views.ChartView.java-addPiece.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
+if(diagMin>offDiagMax){
+diagMin=offDiagMax;
+}
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/5173/pattern-ver1-serial/src.com.sbar.rebudget.views.ChartView.java-addPiece.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
+if(diagMax>i0){
+diagMax=i0;
+}
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V12/5173/pattern-ver1-serial/src.com.sbar.rebudget.views.ChartView.java-addPiece.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+2]<=0||work[i+2]==Long.MIN_VALUE){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V5/7087/pattern-ver1-serial/BDEBase.src.main.java.gr.demokritos.iit.base.util.Utils.java-extractYearMonthDayLiteral.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+n0=goodStep(i0,n0);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+if(k==12){
+return ;
+}else {
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
+}
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V39/4902/pattern-ver1-serial/app.src.main.java.com.cs180project.ucrclasses.BaseCalendarActivity.java-interpretTime.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+int split=i0-1;
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
-int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+n0=goodStep(i0,n0);
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3904/pattern-ver1-serial/src.heartbeat.TachySyringe.java-Use.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+n0=goodStep(i0,n0);
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3904/pattern-ver1-serial/src.heartbeat.TachySyringe.java-Use.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+2]<=0||work[i+2]==0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V37/1056/pattern-ver1-serial/lts-admin.src.main.java.com.github.ltsopensource.admin.web.api.SuspendJobQueueApi.java-suspendJobRecovery.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+2]<=0||work[i+2]>9){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/2964/pattern-ver1-serial/main.plugins.org.talend.dataquality.sampling.src.main.java.org.talend.dataquality.datamasking.FunctionApplier.java-generateDuplicate.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
+n0=goodStep(i0,n0);
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/4301/pattern-ver1-serial/api.src.main.java.com.abiquo.api.services.cloud.VirtualMachineService.java-changeVirtualMachineState.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+n0=goodStep(i0,n0);
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
+n0=goodStep(i0,n0);
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+n0=goodStep(i0,n0);
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
+n0=goodStep(i0,n0);
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
+n0=goodStep(i0,n0);
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V5/5159/pattern-ver1-serial/ui-common.src.main.java.org.exoplatform.selenium.platform.ecms.ContextMenu.java-lockNode.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+n0=goodStep(i0,n0);
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/6314/pattern-ver1-serial/app.src.main.java.mobile.tiis.app.postman.SynchronisationService.java-onHandleIntent.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+n0=goodStep(i0,n0);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/3854/pattern-ver1-serial/NewIntro4.java-act.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,this.work[i]+this.work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V59/2137/pattern-ver1-serial/DesignPattern.src.builder.SaltWater.java-getWeight.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
+int split=i0-1;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
-int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/1365/pattern-ver1-serial/src.main.java.nl.tue.win.vcp.virtualbreitenbergenvironment.model.Environment.java-draw.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
-double offDiagMin=(i0==n0)?0:work[4*n0-6];
+double offDiagMin=(i0==n0)?0:1;
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/4284/pattern-ver1-serial/object-filter.src.main.java.org.infinispan.objectfilter.impl.util.Interval.java-compareTo.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+2]<=0&&work[i+2]<4000000){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V28/46/pattern-ver1-serial/raw.master.registryKit.registryKit.registryKit.src.main.java.com.registryKit.survey.surveyManager.java-saveSurveyDocument.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:-2;
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/1609/pattern-ver1-serial/jsqlbox.src.main.java.com.github.drinkjava2.jsqlbox.Dao.java-executeQuiet.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(Double.isNaN(work[i+2])){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V32/1622/pattern-ver1-serial/src.mckay.utilities.staticlibraries.StringMethods.java-getDoubleInScientificNotation.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
-while(n0>0){
+while(n0>0-1){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3-1)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V62/5164/pattern-ver1-serial/roguelikeengine-libgdx.src.com.game.libgdx.roguelikeengine.Bullet.java-update.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
+n0=goodStep(i0,n0);
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
-n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/5994/pattern-ver1-serial/repository.src.org.pentaho.platform.repository2.unified.webservices.RepositoryFileTreeAdapter.java-RepositoryFileTreeAdapter.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+n0=goodStep(i0,n0);
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/2177/pattern-ver1-serial/app.src.main.java.com.kshitij.android.clickme.ui.PhotoFeedActivity.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 0, INS : 1, DEL : 5
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(work[i+2]<=0&&work[i+2]!=9999){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V44/5798/pattern-ver1-serial/SONPlugin.src.org.workcraft.plugins.son.granularity.HourMins.java-getHour.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
+if(0>0&&work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V30/553/pattern-ver1-serial/src.main.java.edu.berkeley.cs.nlp.ocular.main.TrainFont.java-run.pattern
MATCHLEVEL : ALL
ALL : 6, UPD : 6, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+synchronized(this){
 i0=1+i/4;
 break;
+}
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
+if(k>=maxIter){
+throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
+}
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/3655/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.placement.RecoverPointScheduler.java-scheduleStorageSourcePoolConstraint.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 0, INS : 1, DEL : 6
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
-while(n0>0){
+while(n0>0||n0>>>3>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V45/6215/pattern-ver1-serial/java.src.Bin.java-pack_integer.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+diagMax=work[4*i0];
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1950/pattern-ver1-serial/Node.java-eventDelete.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 0, INS : 1, DEL : 6
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=offDiagMin;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/1236/pattern-ver1-serial/providers.dynect.src.main.java.org.jclouds.dynect.v3.domain.Zone.java-Zone.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=offDiagMax;
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/1236/pattern-ver1-serial/providers.dynect.src.main.java.org.jclouds.dynect.v3.domain.Zone.java-Zone.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=diagMin;
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/1236/pattern-ver1-serial/providers.dynect.src.main.java.org.jclouds.dynect.v3.domain.Zone.java-Zone.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=(Math.min(diagMin,work[i+4])+diagMin)%diagMin;
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=(Math.min(offDiagMin,work[i+2])+offDiagMin)%offDiagMin;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=(Math.max(offDiagMax,work[i+2])+offDiagMax)%offDiagMax;
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,2.0*(work[i]+work[i+2]));
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V38/3214/pattern-ver1-serial/src.agents.manic.TransitionModel.java-anticipateNextBeliefsInPlace.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.max(0,diagMin-diagMin*offDiagMax);
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/7280/pattern-ver1-serial/lwjgl-game-core.src.com.lithia.cs.core.world.World.java-calcBlockPosZ.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.max(0,diagMin-Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V6/7280/pattern-ver1-serial/lwjgl-game-core.src.com.lithia.cs.core.world.World.java-calcBlockPosZ.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=(n0==n)?0:1;
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V34/4284/pattern-ver1-serial/object-filter.src.main.java.org.infinispan.objectfilter.impl.util.Interval.java-compareTo.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=0;
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V27/506/pattern-ver1-serial/MetaChessApp.src.engine.board.ExtendedBoardModel.java-getFurthestPiece.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=0;
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V27/506/pattern-ver1-serial/MetaChessApp.src.engine.board.ExtendedBoardModel.java-getFurthestPiece.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=0;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V27/506/pattern-ver1-serial/MetaChessApp.src.engine.board.ExtendedBoardModel.java-getFurthestPiece.pattern
MATCHLEVEL : ALL
ALL : 7, UPD : 7, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
-if(work[i+2]<=0){
 i0=1+i/4;
+if(work[i+2]<=0){
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V49/5647/pattern-ver1-serial/src.worms.model.statements.Print.java-executeStatement.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+i0=1+i/4;
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+i0=1+i/4;
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
+i0=1+i/4;
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
+i0=1+i/4;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+i0=1+i/4;
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
+i0=1+i/4;
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V24/6753/pattern-ver1-serial/app.src.main.java.com.tbd.memory_game.GameActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
 break;
 }
+i0=1+i/4;
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V9/6301/pattern-ver1-serial/app.src.main.java.client.example.sj.pulltoscaleheaderlayout.PullToScaleHeaderLayout.java-computeScroll.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+i0=1+i/4;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V39/1875/pattern-ver1-serial/TherapistApp.src.application.Main.java-handle.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
-int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+int maxIter=30*(n0-i0);
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V40/2943/pattern-ver1-serial/hadoop.order_inversion.src.main.java.org.mdp.learn.hadoop.order_inversion.pairs.CoOccurrenceMatrixMapperWithPairs.java-map.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
-sumOffDiag+=ei;
+sumOffDiag+=ei*2;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/1126/pattern-ver1-serial/src.game.renderer.Position.java-translate.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 8, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
+try{
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+}finally{
+i0=1+i/4;
+}
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 1, INS : 0, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+try{
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
+}finally{
+i0=1+i/4;
+}
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 1, INS : 0, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+i0=1+i/4;
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/1831/pattern-ver1-serial/bitrepository-audit-trail-service.src.main.java.org.bitrepository.audittrails.collector.IncrementalCollector.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+i0=1+i/4;
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V61/1831/pattern-ver1-serial/bitrepository-audit-trail-service.src.main.java.org.bitrepository.audittrails.collector.IncrementalCollector.java-handleEvent.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 1, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
+if(offDiagMax<0){
+offDiagMax=0;
+}
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
+i0=0;
+if(i0<0){
 i0=0;
+}
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/5043/pattern-ver1-serial/src.Server.ServerWorld.java-updateObjects.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
+if(offDiagMax<0){
+offDiagMax=0;
+}
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+pingPong=0;
+if(pingPong<0){
 pingPong=0;
+}
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/5043/pattern-ver1-serial/src.Server.ServerWorld.java-updateObjects.pattern
MATCHLEVEL : ALL
ALL : 8, UPD : 0, INS : 8, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/6358/pattern-ver1-serial/src.main.java.com.builtbroken.icbm.content.ams.TileAMSClient.java-onPlayerRightClick.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+offDiagMin=work[4*i0+2];
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V47/1950/pattern-ver1-serial/Node.java-eventDelete.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+boolean haveBreadCrumbs=false;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+haveBreadCrumbs=true;
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter&&haveBreadCrumbs){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+boolean haveBreadCrumbs=false;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter&&haveBreadCrumbs){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+haveBreadCrumbs=true;
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+boolean haveBreadCrumbs=false;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+haveBreadCrumbs=true;
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter&&haveBreadCrumbs){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+boolean haveBreadCrumbs=false;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter&&haveBreadCrumbs){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
+haveBreadCrumbs=true;
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+boolean haveBreadCrumbs=false;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter&&haveBreadCrumbs){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
+haveBreadCrumbs=true;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+boolean haveBreadCrumbs=false;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter&&haveBreadCrumbs){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
+haveBreadCrumbs=true;
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
+boolean haveBreadCrumbs=false;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
-if(k>=maxIter){
+if(k>=maxIter&&haveBreadCrumbs){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
+haveBreadCrumbs=true;
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/2313/pattern-ver1-serial/src.main.java.org.ednovo.gooru.client.mvp.folder.toc.FolderTocView.java-setBreadCrumbs.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 3, INS : 6, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+double previousEMin=work[4*i0+3];
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
-double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V36/2803/pattern-ver1-serial/core.src.main.java.com.orientechnologies.orient.core.index.hashindex.local.OHashTableDirectory.java-deleteWithoutOpen.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 0, INS : 1, DEL : 8
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax)-22);
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V57/2147/pattern-ver1-serial/src.main.java.ch.bfh.ti.projekt1.sokoban.view.GameWindowView.java-loadSolutionFile.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
-diagMax=work[4*i0];
+diagMax=work[4*i0]*2;
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/1126/pattern-ver1-serial/src.game.renderer.Position.java-translate.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.max(0,Math.round(diagMin-2*Math.sqrt(diagMin*offDiagMax)));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V16/7706/pattern-ver1-serial/pixi.src.main.java.org.openpixi.pixi.diagnostics.methods.ProjectedEnergyDensity.java-initialize.pattern
MATCHLEVEL : ALL
ALL : 9, UPD : 9, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+diagMin=Math.min(diagMin,work[i+4]);
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+diagMax=Math.max(diagMax,work[i+4]);
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+offDiagMin=Math.min(offDiagMin,work[i+2]);
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V14/6394/pattern-ver1-serial/src.com.withiter.frame.MainFrame.java-loadDatas.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+diagMin=Math.min(diagMin,work[i+4]);
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+offDiagMin=Math.min(offDiagMin,work[i+2]);
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/2466/pattern-ver1-serial/tajo-core.src.main.java.org.apache.tajo.worker.Task.java-run.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2665/pattern-ver1-serial/channel.src.main.java.com.github.dm.jrt.channel.ReplayChannel.java-onError.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+diagMin=Math.min(diagMin,work[i+4]);
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V31/2665/pattern-ver1-serial/channel.src.main.java.com.github.dm.jrt.channel.ReplayChannel.java-onError.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
-if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+if(diagMin>=4*offDiagMax){
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6349/pattern-ver1-serial/src.com.example.smartphone.SelectECActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V20/6349/pattern-ver1-serial/src.com.example.smartphone.SelectECActivity.java-onPause.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=diagMax;
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/1236/pattern-ver1-serial/providers.dynect.src.main.java.org.jclouds.dynect.v3.domain.Zone.java-Zone.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+diagMin=Math.min(diagMin,work[i+4]);
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V2/3128/pattern-ver1-serial/src.cubicmadness.gamestates.GameStateManager.java-popCurrentState.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V2/3128/pattern-ver1-serial/src.cubicmadness.gamestates.GameStateManager.java-popCurrentState.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
+if(i0!=1+i/4){
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+}
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/529/pattern-ver1-serial/src.com.crankcode.threads.MediaThread.java-end.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 3, INS : 0, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+if(i0!=1+i/4){
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
+}
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/529/pattern-ver1-serial/src.com.crankcode.threads.MediaThread.java-end.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 3, INS : 0, DEL : 7
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
+if(n==3){
+System.out.println("debug");
+}
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+if(n==3){
+System.out.println("debug");
+}
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V9/4383/pattern-ver1-serial/Dameo.src.dameo.gametree.NegaMax.java-alphaBeta.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+if(n==3){
+System.out.println("debug");
+}
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+if(n==3){
+System.out.println("debug");
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V9/4383/pattern-ver1-serial/Dameo.src.dameo.gametree.NegaMax.java-alphaBeta.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+if(sumOffDiag==3){
+System.out.println("debug");
+}
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+if(sumOffDiag==3){
+System.out.println("debug");
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V9/4383/pattern-ver1-serial/Dameo.src.dameo.gametree.NegaMax.java-alphaBeta.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
+if(sumOffDiag==3){
+System.out.println("debug");
+}
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+if(sumOffDiag==3){
+System.out.println("debug");
+}
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V9/4383/pattern-ver1-serial/Dameo.src.dameo.gametree.NegaMax.java-alphaBeta.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+if(i==3){
+System.out.println("debug");
+}
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+if(i==3){
+System.out.println("debug");
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V9/4383/pattern-ver1-serial/Dameo.src.dameo.gametree.NegaMax.java-alphaBeta.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
+if(i==3){
+System.out.println("debug");
+}
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
+if(i==3){
+System.out.println("debug");
+}
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V9/4383/pattern-ver1-serial/Dameo.src.dameo.gametree.NegaMax.java-alphaBeta.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
+if(fourI==3){
+System.out.println("debug");
+}
+if(fourI==3){
+System.out.println("debug");
+}
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V9/4383/pattern-ver1-serial/Dameo.src.dameo.gametree.NegaMax.java-alphaBeta.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
+if(ei==3){
+System.out.println("debug");
+}
+if(ei==3){
+System.out.println("debug");
+}
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V9/4383/pattern-ver1-serial/Dameo.src.dameo.gametree.NegaMax.java-alphaBeta.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+offDiagMin=Math.min(offDiagMin,work[i+2]);
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+diagMin=Math.min(diagMin,work[i+4]);
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+offDiagMin=Math.min(offDiagMin,work[i+2]);
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=(Math.max(diagMax,work[i]+work[i+2])+diagMax)%diagMax;
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+offDiagMin=Math.min(offDiagMin,work[i+2]);
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/7429/pattern-ver1-serial/library.src.main.java.com.datatorrent.lib.appdata.qr.processor.AbstractWEQueryQueueManager.java-enqueueHelper.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+diagMin=Math.min(diagMin,work[i+4]);
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/7429/pattern-ver1-serial/library.src.main.java.com.datatorrent.lib.appdata.qr.processor.AbstractWEQueryQueueManager.java-enqueueHelper.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+diagMin=Math.min(diagMin,work[i+4]);
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
+previousEMin=Math.min(previousEMin,work[i+3]);
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V67/6439/pattern-ver1-serial/core.src.game.screen.battle.Battle.java-render.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+diagMax=Math.max(diagMax,work[i+4]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
+import java.io.File;
+
+import java.util.HashSet;
+
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V1/3878/pattern-ver1-serial/syssvc.src.main.java.com.emc.storageos.systemservices.impl.jobs.backupscheduler.UploadExecutor.java-doUpload.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+diagMax=Math.max(diagMax,work[i+4]);
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3904/pattern-ver1-serial/src.heartbeat.TachySyringe.java-Use.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3904/pattern-ver1-serial/src.heartbeat.TachySyringe.java-Use.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+offDiagMin=Math.min(offDiagMin,work[i+2]);
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V28/3904/pattern-ver1-serial/src.heartbeat.TachySyringe.java-Use.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+offDiagMin=Math.min(offDiagMin,work[i+2]);
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V18/6417/pattern-ver1-serial/Code.DoubleAuctionWithNetworks.src.doubleAuction.Auction.java-executeSingleTransaction.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+diagMin=Math.min(diagMin,work[i+4]);
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V18/6417/pattern-ver1-serial/Code.DoubleAuctionWithNetworks.src.doubleAuction.Auction.java-executeSingleTransaction.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V18/6417/pattern-ver1-serial/Code.DoubleAuctionWithNetworks.src.doubleAuction.Auction.java-executeSingleTransaction.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+diagMin=Math.min(diagMin,work[i+4]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/3854/pattern-ver1-serial/NewIntro4.java-act.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+diagMax=Math.max(diagMax,work[i+4]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/3854/pattern-ver1-serial/NewIntro4.java-act.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
+try{
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+}finally{
+diagMin=Math.min(diagMin,work[i+4]);
+}
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/5562/pattern-ver1-serial/httplite.src.main.java.alexclin.httplite.impl.ProgressRequestBody.java-writeTo.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 1, INS : 0, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
+diagMin=Math.min(diagMin,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V23/3266/pattern-ver1-serial/src.lejosserver.TouchSensor.java-TouchSensor.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+diagMin=Math.min(diagMin,work[i+4]);
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V39/1103/pattern-ver1-serial/Graphs.src.com.jmga.graphs.classes.GView.java-update.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V39/1103/pattern-ver1-serial/Graphs.src.com.jmga.graphs.classes.GView.java-update.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 1, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+try{
 diagMin=Math.min(diagMin,work[i+4]);
+}finally{
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/6401/pattern-ver1-serial/main.java.org.logbuddy.logger.Fuse.java-log.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 1, INS : 0, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+try{
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+}finally{
+diagMin=Math.min(diagMin,work[i+4]);
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V41/6401/pattern-ver1-serial/main.java.org.logbuddy.logger.Fuse.java-log.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 1, INS : 0, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+if(offDiagMin<0){
+offDiagMin--;
+}
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
+if(maxIter<0){
+maxIter--;
+}
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2288/pattern-ver1-serial/src.fr.jules_cesar.Loto.main.java-onEnable.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+if(offDiagMin<0){
+offDiagMin--;
+}
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
+if(diagMax<0){
+diagMax--;
+}
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2288/pattern-ver1-serial/src.fr.jules_cesar.Loto.main.java-onEnable.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+if(offDiagMin<0){
+offDiagMin--;
+}
 double offDiagMax=0;
+if(offDiagMax<0){
+offDiagMax--;
+}
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V10/2288/pattern-ver1-serial/src.fr.jules_cesar.Loto.main.java-onEnable.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 0, INS : 10, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=0;
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V27/506/pattern-ver1-serial/MetaChessApp.src.engine.board.ExtendedBoardModel.java-getFurthestPiece.pattern
MATCHLEVEL : ALL
ALL : 10, UPD : 10, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=0;
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V32/6155/pattern-ver1-serial/SideScroller.src.net.masterzach32.sidescroller.entity.enemy.Boss.java-Boss.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=n;
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/1236/pattern-ver1-serial/providers.dynect.src.main.java.org.jclouds.dynect.v3.domain.Zone.java-Zone.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=n0;
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/1236/pattern-ver1-serial/providers.dynect.src.main.java.org.jclouds.dynect.v3.domain.Zone.java-Zone.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=((n0==n)?0:-work[4*n0-2]+n0)%n0;
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=((n0==n)?0:-work[4*n0-2]+n)%n;
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=1;
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V35/6537/pattern-ver1-serial/src.controller.Controller.java-Controller.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
+sigma=4;
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V32/1083/pattern-ver1-serial/action-adventure.src.main.java.niellebeck.game.PlayerCharacter.java-PlayerCharacter.pattern
MATCHLEVEL : ALL
ALL : 11, UPD : 11, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
+if(diagMin!=Math.min(diagMin,work[i+4])){
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+}
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V4/878/pattern-ver1-serial/rdt.org.eclipse.ptp.rdt.sync.ui.src.org.eclipse.ptp.rdt.sync.ui.properties.EnvManagerPropertiesPage.java-cfgChanged.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 3, INS : 0, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+if(offDiagMin<3){
+offDiagMin=3;
+}
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
+if(maxIter<3){
+maxIter=3;
+}
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/5504/pattern-ver1-serial/components.insight.SRC.org.openmicroscopy.shoola.util.image.geom.Factory.java-magnifyImage.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 0, INS : 12, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+if(offDiagMin<3){
+offDiagMin=3;
+}
 double offDiagMax=0;
+if(offDiagMax<3){
+offDiagMax=3;
+}
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/5504/pattern-ver1-serial/components.insight.SRC.org.openmicroscopy.shoola.util.image.geom.Factory.java-magnifyImage.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 0, INS : 12, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
+if(offDiagMin<3){
+offDiagMin=3;
+}
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
+if(diagMax<3){
+diagMax=3;
+}
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V55/5504/pattern-ver1-serial/components.insight.SRC.org.openmicroscopy.shoola.util.image.geom.Factory.java-magnifyImage.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 0, INS : 12, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+if(offDiagMax!=Math.max(offDiagMax,work[i+2])){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V28/568/pattern-ver1-serial/src.net.skycraftmc.SkyQuest.utilitygui.ObjectiveEditPanel.java-clear.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 3, INS : 0, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+if(diagMin!=Math.min(diagMin,work[i+4])){
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V28/568/pattern-ver1-serial/src.net.skycraftmc.SkyQuest.utilitygui.ObjectiveEditPanel.java-clear.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 3, INS : 0, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*2;
 break;
 }
 if(diagMin>=4*offDiagMax){
-diagMin=Math.min(diagMin,work[i+4]);
+diagMin=Math.min(diagMin,work[i+4])*2;
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/1126/pattern-ver1-serial/src.game.renderer.Position.java-translate.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 12, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
-diagMax=Math.max(diagMax,work[i+4]);
+diagMax=Math.max(diagMax,work[i+4])*2;
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/1126/pattern-ver1-serial/src.game.renderer.Position.java-translate.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 12, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
-offDiagMax=Math.max(offDiagMax,work[i+2]);
+offDiagMax=Math.max(offDiagMax,work[i+2])*2;
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/1126/pattern-ver1-serial/src.game.renderer.Position.java-translate.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 12, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,work[i+2])*2;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/1126/pattern-ver1-serial/src.game.renderer.Position.java-translate.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 12, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.min(offDiagMin,work[i+2])*2;
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/1126/pattern-ver1-serial/src.game.renderer.Position.java-translate.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 12, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
-previousEMin=Math.min(previousEMin,work[i+3]);
+previousEMin=Math.min(previousEMin,work[i+3])*2;
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/1126/pattern-ver1-serial/src.game.renderer.Position.java-translate.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 12, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-2;
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V9/1609/pattern-ver1-serial/jsqlbox.src.main.java.com.github.drinkjava2.jsqlbox.Dao.java-executeQuiet.pattern
MATCHLEVEL : ALL
ALL : 12, UPD : 12, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+diagMax=Math.max(diagMax,work[i]+work[i+2]);
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V8/2049/pattern-ver1-serial/src.railwaystation.infrastructure.Train.java-informAboutExternalDelay.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=offDiagMax;
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/1236/pattern-ver1-serial/providers.dynect.src.main.java.org.jclouds.dynect.v3.domain.Zone.java-Zone.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 13, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=diagMin;
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/1236/pattern-ver1-serial/providers.dynect.src.main.java.org.jclouds.dynect.v3.domain.Zone.java-Zone.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 13, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+diagMax=Math.max(diagMax,work[i]+work[i+2]);
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2011/V3/6708/pattern-ver1-serial/src.next.i.view.widgets.XFlexTable.java-XFlexTable.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=(-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax))+diagMin)%diagMin;
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V3/6203/pattern-ver1-serial/src.unogame.peer.GamePeer.java-getNextInRing.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 13, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+if(work[i+2]==12){
+return ;
+}else {
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
+}
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V39/4902/pattern-ver1-serial/app.src.main.java.com.cs180project.ucrclasses.BaseCalendarActivity.java-interpretTime.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 13, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+diagMax=Math.max(diagMax,work[i]+work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V25/1924/pattern-ver1-serial/src.gui.map.MapDrawerPanel.java-restoreSession.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 0, INS : 1, DEL : 12
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=0;
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V27/506/pattern-ver1-serial/MetaChessApp.src.engine.board.ExtendedBoardModel.java-getFurthestPiece.pattern
MATCHLEVEL : ALL
ALL : 13, UPD : 13, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
-while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
+while(n0>0){
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V66/5994/pattern-ver1-serial/repository.src.org.pentaho.platform.repository2.unified.webservices.RepositoryFileTreeAdapter.java-RepositoryFileTreeAdapter.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 0, INS : 1, DEL : 13
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
+sigma=(n0==n)?0:-work[4*n0-2];
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/2177/pattern-ver1-serial/app.src.main.java.com.kshitij.android.clickme.ui.PhotoFeedActivity.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 0, INS : 1, DEL : 13
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
-sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+sigma=(n0==n)?0:-work[4*n0-2];
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/2177/pattern-ver1-serial/app.src.main.java.com.kshitij.android.clickme.ui.PhotoFeedActivity.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 0, INS : 1, DEL : 13
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
+sigma=(n0==n)?0:-work[4*n0-2];
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V30/2177/pattern-ver1-serial/app.src.main.java.com.kshitij.android.clickme.ui.PhotoFeedActivity.java-onPostExecute.pattern
MATCHLEVEL : ALL
ALL : 14, UPD : 0, INS : 1, DEL : 13
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
+diagMax=Math.max(diagMax,work[i]+work[i+2])*2;
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/1126/pattern-ver1-serial/src.game.renderer.Position.java-translate.pattern
MATCHLEVEL : ALL
ALL : 15, UPD : 15, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V67/293/pattern-ver1-serial/common.ganymedes01.aobd.recipes.RecipesHandler.java-craftingRecipes.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V67/293/pattern-ver1-serial/common.ganymedes01.aobd.recipes.RecipesHandler.java-craftingRecipes.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V67/293/pattern-ver1-serial/common.ganymedes01.aobd.recipes.RecipesHandler.java-craftingRecipes.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/2664/pattern-ver1-serial/src.main.java.micdoodle8.mods.galacticraft.planets.asteroids.entities.EntityGrapple.java-EntityGrapple.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V22/2622/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.resource.ComputeImageService.java-updateComputeImage.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/4215/pattern-ver1-serial/Mage.Server.src.main.java.mage.server.TableController.java-joinTournament.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/4215/pattern-ver1-serial/Mage.Server.src.main.java.mage.server.TableController.java-joinTournament.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V1/4215/pattern-ver1-serial/Mage.Server.src.main.java.mage.server.TableController.java-joinTournament.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4025/pattern-ver1-serial/AZoCamSyncDesktop.src.de.quadrillenschule.azocamsyncd.gui.SwingBackgroundUpdater.java-run.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V50/4025/pattern-ver1-serial/AZoCamSyncDesktop.src.de.quadrillenschule.azocamsyncd.gui.SwingBackgroundUpdater.java-run.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V27/7577/pattern-ver1-serial/networkmonitor.src.main.java.ca.rmen.android.networkmonitor.app.prefs.PreferencesCompat.java-setupActionBar.pattern
MATCHLEVEL : ALL
ALL : 16, UPD : 0, INS : 1, DEL : 15
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
-offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/5667/pattern-ver1-serial/src.AccessorBean.java-onPageLoaded.pattern
MATCHLEVEL : ALL
ALL : 17, UPD : 8, INS : 0, DEL : 9
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
+synchronized(this){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 18, UPD : 18, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+offDiagMax=Math.round(offDiagMax*100.0)/100.0;
+diagMin=Math.round(diagMin*100.0)/100.0;
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/6081/pattern-ver1-serial/src.Calc.java-calcBasicsOfSurvivability.pattern
MATCHLEVEL : ALL
ALL : 18, UPD : 0, INS : 18, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
+diagMin=Math.round(diagMin*100.0)/100.0;
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
+offDiagMin=Math.round(offDiagMin*100.0)/100.0;
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V22/6081/pattern-ver1-serial/src.Calc.java-calcBasicsOfSurvivability.pattern
MATCHLEVEL : ALL
ALL : 18, UPD : 0, INS : 18, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
-i0=1+i/4;
+i0=1+i/4*2;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
-dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
+dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax))*2;
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V48/1126/pattern-ver1-serial/src.game.renderer.Position.java-translate.pattern
MATCHLEVEL : ALL
ALL : 18, UPD : 18, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V36/6358/pattern-ver1-serial/src.main.java.com.builtbroken.icbm.content.ams.TileAMSClient.java-onPlayerRightClick.pattern
MATCHLEVEL : ALL
ALL : 20, UPD : 20, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V15/578/pattern-ver1-serial/src.com.android.mms.model.ImageModel.java-resizeMedia.pattern
MATCHLEVEL : ALL
ALL : 20, UPD : 20, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
-diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V26/5667/pattern-ver1-serial/src.AccessorBean.java-onPageLoaded.pattern
MATCHLEVEL : ALL
ALL : 20, UPD : 8, INS : 0, DEL : 12
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
+if(diagMin==12){
+return ;
+}else {
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
+}
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V39/4902/pattern-ver1-serial/app.src.main.java.com.cs180project.ucrclasses.BaseCalendarActivity.java-interpretTime.pattern
MATCHLEVEL : ALL
ALL : 23, UPD : 23, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
+}
+if(diagMin>=4*offDiagMax){
+diagMin=Math.min(diagMin,work[i+4]);
+offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V11/3655/pattern-ver1-serial/apisvc.src.main.java.com.emc.storageos.api.service.impl.placement.RecoverPointScheduler.java-scheduleStorageSourcePoolConstraint.pattern
MATCHLEVEL : ALL
ALL : 24, UPD : 0, INS : 1, DEL : 23
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
+if(diagMin>=4*offDiagMax){
+diagMin=Math.min(diagMin,work[i+4]);
+offDiagMax=Math.max(offDiagMax,work[i+2]);
+}
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 24, UPD : 0, INS : 1, DEL : 23
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if(((pingPong==0))&&((n0-i0>3))&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
-if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
+if(((work[i+3]<=TOLERANCE_2*work[i]))||((work[i+2]<=TOLERANCE_2*sigma))){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/5331/pattern-ver1-serial/src.main.java.groupProject.twentyFortyEight.GameLogic.java-gameOver.pattern
MATCHLEVEL : ALL
ALL : 25, UPD : 25, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if(((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax))&&((work[4*n0-2]<=TOLERANCE_2*sigma))){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/5331/pattern-ver1-serial/src.main.java.groupProject.twentyFortyEight.GameLogic.java-gameOver.pattern
MATCHLEVEL : ALL
ALL : 30, UPD : 30, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)||"查看红包".equals((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax))){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V13/4605/pattern-ver1-serial/app.src.main.java.xyz.monkeytong.hongbao.utils.HongbaoSignature.java-generateSignature.pattern
MATCHLEVEL : ALL
ALL : 31, UPD : 31, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V15/1014/pattern-ver1-serial/src.main.java.HxCKDMS.HxCEnchants.Handlers.EnchantHandlers.java-handleBootEnchant.pattern
MATCHLEVEL : ALL
ALL : 31, UPD : 31, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if(!(pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V16/5542/pattern-ver1-serial/RedZone.redzone.blocks.Pipe.java-onBlockPlaced.pattern
MATCHLEVEL : ALL
ALL : 31, UPD : 31, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if(true){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V14/6216/pattern-ver1-serial/app.src.main.java.example.com.mpdlcamera.Upload.CustomAdapter.java-getView.pattern
MATCHLEVEL : ALL
ALL : 31, UPD : 31, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if(((pingPong==0)&&(n0-i0>3))&&((work[4*n0-1]<=TOLERANCE_2*diagMax))&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
-if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
+if(((work[i+3]<=TOLERANCE_2*work[i]))||((work[i+2]<=TOLERANCE_2*sigma))){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/5331/pattern-ver1-serial/src.main.java.groupProject.twentyFortyEight.GameLogic.java-gameOver.pattern
MATCHLEVEL : ALL
ALL : 36, UPD : 36, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if(((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax))&&((work[4*n0-2]<=TOLERANCE_2*sigma))){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
-if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
+if(((work[i+3]<=TOLERANCE_2*work[i]))||((work[i+2]<=TOLERANCE_2*sigma))){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2016/V17/5331/pattern-ver1-serial/src.main.java.groupProject.twentyFortyEight.GameLogic.java-gameOver.pattern
MATCHLEVEL : ALL
ALL : 47, UPD : 47, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
-if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
-if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
+if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V21/4076/pattern-ver1-serial/moho-impl.src.main.java.com.voxeo.moho.sip.DirectAI2NOJoinDelegate.java-doInviteResponse.pattern
MATCHLEVEL : ALL
ALL : 49, UPD : 49, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+synchronized(this){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
+}
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2012-2014/V13/4122/pattern-ver1-serial/hazelcast.src.main.java.com.hazelcast.impl.DefaultRecord.java-invalidateValueCache.pattern
MATCHLEVEL : ALL
ALL : 135, UPD : 135, INS : 0, DEL : 0
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
FILE : /home/jiajun/GenPat/artifacts-bak/projects/math/math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java[812,929]
------------Candidate---------------
 private void processGeneralBlock(int n) throws InvalidMatrixException{
 double sumOffDiag=0;
 for(int i=0;i<n-1;++i){
  final int fourI=4*i;
  final double ei=work[fourI+2];
 sumOffDiag+=ei;
 }
 if(sumOffDiag==0){
 return ;
 }
 flipIfWarranted(n,2);
 initialSplits(n);
 tType=0;
 dMin1=0;
 dMin2=0;
 dN=0;
 dN1=0;
 dN2=0;
 tau=0;
 int i0=0;
 int n0=n;
 while(n0>0){
 sigma=(n0==n)?0:-work[4*n0-2];
 sigmaLow=0;
 double offDiagMin=(i0==n0)?0:work[4*n0-6];
 double offDiagMax=0;
 double diagMax=work[4*n0-4];
 double diagMin=diagMax;
 i0=0;
 for(int i=4*(n0-2);i>=0;i-=4){
 if(work[i+2]<=0){
 i0=1+i/4;
 break;
 }
 if(diagMin>=4*offDiagMax){
 diagMin=Math.min(diagMin,work[i+4]);
 offDiagMax=Math.max(offDiagMax,work[i+2]);
 }
 diagMax=Math.max(diagMax,work[i]+work[i+2]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 }
 work[4*n0-2]=offDiagMin;
 dMin=-Math.max(0,diagMin-2*Math.sqrt(diagMin*offDiagMax));
 pingPong=0;
 int maxIter=30*(n0-i0);
 for(int k=0;i0<n0;++k){
 if(k>=maxIter){
 throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
 }
 n0=goodStep(i0,n0);
+if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
+int split=i0-1;
+diagMax=work[4*i0];
+offDiagMin=work[4*i0+2];
+double previousEMin=work[4*i0+3];
+for(int i=4*i0;i<4*n0-16;i+=4){
+if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
+work[i+2]=-sigma;
+split=i/4;
+diagMax=0;
+offDiagMin=work[i+6];
+previousEMin=work[i+7];
+}else {
+diagMax=Math.max(diagMax,work[i+4]);
+offDiagMin=Math.min(offDiagMin,work[i+2]);
+previousEMin=Math.min(previousEMin,work[i+3]);
+}
+}
+work[4*n0-2]=offDiagMin;
+work[4*n0-1]=previousEMin;
+i0=split+1;
+}
 pingPong=1-pingPong;
 if((pingPong==0)&&(n0-i0>3)&&(work[4*n0-1]<=TOLERANCE_2*diagMax)&&(work[4*n0-2]<=TOLERANCE_2*sigma)){
 int split=i0-1;
 diagMax=work[4*i0];
 offDiagMin=work[4*i0+2];
 double previousEMin=work[4*i0+3];
 for(int i=4*i0;i<4*n0-16;i+=4){
 if((work[i+3]<=TOLERANCE_2*work[i])||(work[i+2]<=TOLERANCE_2*sigma)){
 work[i+2]=-sigma;
 split=i/4;
 diagMax=0;
 offDiagMin=work[i+6];
 previousEMin=work[i+7];
 }else {
 diagMax=Math.max(diagMax,work[i+4]);
 offDiagMin=Math.min(offDiagMin,work[i+2]);
 previousEMin=Math.min(previousEMin,work[i+3]);
 }
 }
 work[4*n0-2]=offDiagMin;
 work[4*n0-1]=previousEMin;
 i0=split+1;
 }
 }
 }
 }

PATTERN : /home/jiajun/GithubData/2015/V1/6937/pattern-ver1-serial/library.src.main.java.com.reginald.swiperefresh.CustomSwipeRefreshLayout.java-onLayout.pattern
MATCHLEVEL : ALL
ALL : 167, UPD : 0, INS : 1, DEL : 166
Failing Tests:[org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02]
---------START : 2019.09.07 AD at 20:35:34 CDT
---------TIME : 2019.09.08 AD at 00:24:51 CDT
--------------- END -----------------
Finish : math-80 > patch : 10 | Start : Sat Sep 07 20:35:34 CDT 2019 | End : 2019.09.08 AD at 00:24:51 CDT
