Repair : hono_client_4
Current file:/Users/ffengjay/Postgraduate/PLM4APR/codex_out/valuable_patches_growing_real/hono_client_4/patch.java
Patch Number: /Users/ffengjay/Postgraduate/PLM4APR/codex_out/valuable_patches_growing_real/hono_client_4/patch.java
Following are 0th generated patches:
0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
message.setReplyTo(String.format("%s/%s/%s",CommandConstants.ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+message.setReplyTo(String.format("%s/%s/%s",CommandConstants.ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));

[1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Following are 1th generated patches:
0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
message.setReplyTo(String.format("%s/%s/%s",CommandConstants.ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+message.setReplyTo(String.format("%s/%s/%s",CommandConstants.ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.setReplyTo(String.format("%s/%s/%s",CommandConstants.ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.setReplyTo(String.format("%s/%s/%s",CommandConstants.ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToLegacyEndpointUsed(String.format("%s/%s/%s",CommandConstants.ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToLegacyEndpointUsed(String.format("%s/%s/%s",CommandConstants.ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToContainedDeviceIdOptionSet(String.format("%s/%s/%s",CommandConstants.ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToContainedDeviceIdOptionSet(String.format("%s/%s/%s",CommandConstants.ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.encodeReplyToOptions(replyToLegacyEndpointUsed,replyToLegacyEndpointUsed);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.encodeReplyToOptions(replyToLegacyEndpointUsed,replyToLegacyEndpointUsed);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.encodeReplyToOptions(false,replyToLegacyEndpointUsed);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.encodeReplyToOptions(false,replyToLegacyEndpointUsed);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.encodeReplyToOptions(true,replyToLegacyEndpointUsed);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.encodeReplyToOptions(true,replyToLegacyEndpointUsed);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToContainedDeviceIdOptionSet(originalReplyToId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToContainedDeviceIdOptionSet(originalReplyToId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.encodeReplyToOptions(replyToLegacyEndpointUsed,true);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.encodeReplyToOptions(replyToLegacyEndpointUsed,true);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.encodeReplyToOptions(replyToLegacyEndpointUsed,false);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.encodeReplyToOptions(replyToLegacyEndpointUsed,false);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToLegacyEndpointUsed(originalReplyToId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToLegacyEndpointUsed(originalReplyToId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+validationErrorJoiner.add("reply-tonottargetedattenant"+tenantId+":"+message.getReplyTo());

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToContainedDeviceIdOptionSet(deviceId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToContainedDeviceIdOptionSet(deviceId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToContainedDeviceIdOptionSet(replyToId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToContainedDeviceIdOptionSet(replyToId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToContainedDeviceIdOptionSet(correlationId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToContainedDeviceIdOptionSet(correlationId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(originalReplyToId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(originalReplyToId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(originalReplyToId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(originalReplyToId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToContainedDeviceIdOptionSet(tenantId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToContainedDeviceIdOptionSet(tenantId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToContainedDeviceIdOptionSet(requestId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToContainedDeviceIdOptionSet(requestId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+validationErrorJoiner.add("reply-topartaftertenantnotset:"+message.getReplyTo());

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(originalReplyToId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(originalReplyToId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(originalReplyToId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(originalReplyToId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(requestId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(requestId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(requestId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(requestId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToLegacyEndpointUsed(deviceId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToLegacyEndpointUsed(deviceId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToLegacyEndpointUsed(replyToId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToLegacyEndpointUsed(replyToId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToLegacyEndpointUsed(correlationId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToLegacyEndpointUsed(correlationId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(tenantId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(tenantId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(tenantId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(tenantId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(tenantId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(tenantId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(deviceId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(deviceId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(deviceId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(deviceId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(replyToId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(replyToId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(replyToId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(replyToId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(correlationId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(correlationId,Command.FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(correlationId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(correlationId,Command.FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
tenantId.equals(replyTo.getTenantId());
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+tenantId.equals(replyTo.getTenantId());

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+validationErrorJoiner.add("reply-tonotacommandaddress:"+message.getReplyTo());

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+validationErrorJoiner.add("reply-tocannotbeparsed:"+message.getReplyTo());

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(tenantId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(tenantId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
validationErrorJoiner.add("message/correlation-id not set");
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+validationErrorJoiner.add("message/correlation-idnotset");

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(replyToId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(replyToId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(replyToId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(replyToId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(correlationId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(correlationId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToLegacyEndpointUsed(tenantId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToLegacyEndpointUsed(tenantId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isReplyToLegacyEndpointUsed(requestId);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isReplyToLegacyEndpointUsed(requestId);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(correlationId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(correlationId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
message.getApplicationProperties();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+message.getApplicationProperties();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(requestId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(requestId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(deviceId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(deviceId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(deviceId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(deviceId,FLAG_REPLY_TO_CONTAINED_DEVICE_ID);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.encodeReplyToOptions(false,false);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.encodeReplyToOptions(false,false);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.decodeReplyToOption(requestId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.decodeReplyToOption(requestId,FLAG_REPLY_TO_LEGACY_ENDPOINT_USED);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
validationErrorJoiner.add("subject not set");
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+validationErrorJoiner.add("subjectnotset");

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getReplyToEndpoint();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getReplyToEndpoint();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.encodeReplyToOptions(true,false);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.encodeReplyToOptions(true,false);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.encodeReplyToOptions(false,true);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.encodeReplyToOptions(false,true);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
message.getContentType();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+message.getContentType();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.encodeReplyToOptions(true,true);
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.encodeReplyToOptions(true,true);

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
message.getReplyTo();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+message.getReplyTo();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
replyTo.getEndpoint();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+replyTo.getEndpoint();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getInvalidCommandReason();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getInvalidCommandReason();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getApplicationProperties();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getApplicationProperties();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
replyTo.getTenantId();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+replyTo.getTenantId();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getCommandMessage();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getCommandMessage();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getReplyToId();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getReplyToId();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
replyTo.getPathWithoutBase();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+replyTo.getPathWithoutBase();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
validationError.isPresent();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+validationError.isPresent();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getDeviceId();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getDeviceId();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getCorrelationId();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getCorrelationId();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getPayloadSize();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getPayloadSize();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getContentType();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getContentType();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
message.getSubject();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+message.getSubject();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
validationError.get();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+validationError.get();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getPayload();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getPayload();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
deviceId.length();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+deviceId.length();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getTenant();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getTenant();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getRequestId();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getRequestId();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.toString();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.toString();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isOneWay();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isOneWay();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.getName();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.getName();

0.0
//Following are generated patch:
  /** 
 * Creates a command for an AMQP 1.0 message that should be sent to a device. <p> The message is expected to contain <ul> <li>a non-null <em>subject</em></li> <li>either a null <em>reply-to</em> address (for a one-way command) or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists of four segments</li> <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li> </ul> <p> If any of the requirements above are not met, then the returned command's  {@link Command#isValid()}method will return  {@code false}. <p> Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains the device id.
 * @param message The message containing the command.
 * @param tenantId The tenant that the device belongs to.
 * @param deviceId The identifier of the device.
 * @return The command.
 * @throws NullPointerException if any of the parameters are {@code null}.
 */
  public static Command from(  final Message message,  final String tenantId,  final String deviceId){
    Objects.requireNonNull(message);
    Objects.requireNonNull(tenantId);
    Objects.requireNonNull(deviceId);
    final StringJoiner validationErrorJoiner=new StringJoiner(", ");
    if (message.getSubject() == null) {
      validationErrorJoiner.add("subject not set");
    }
    final String correlationId=Optional.ofNullable(message.getCorrelationId()).map(obj -> {
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
).orElseGet(() -> {
      final Object obj=message.getMessageId();
      if (obj instanceof String) {
        return (String)obj;
      }
 else {
        return null;
      }
    }
);
    if (correlationId == null) {
      validationErrorJoiner.add("message/correlation-id not set");
    }
    String originalReplyToId=null;
    boolean replyToLegacyEndpointUsed=false;
    if (message.getReplyTo() != null) {
      try {
        final ResourceIdentifier replyTo=ResourceIdentifier.fromString(message.getReplyTo());
        if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
          validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
        }
 else         if (!tenantId.equals(replyTo.getTenantId())) {
          validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": "+ message.getReplyTo());
        }
 else {
          replyToLegacyEndpointUsed=CommandConstants.isNorthboundCommandLegacyEndpoint(replyTo.getEndpoint());
          originalReplyToId=replyTo.getPathWithoutBase();
          if (originalReplyToId == null) {
            validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
          }
 else {
this.isValid();
          }
        }
      }
 catch (      IllegalArgumentException e) {
        validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
      }
    }
    final Command result=new Command(validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),message,tenantId,deviceId,correlationId,originalReplyToId,replyToLegacyEndpointUsed);
    return result;
  }
-message.setReplyTo(String.format("%s/%s/%s",CommandConstants.COMMAND_ENDPOINT,tenantId,getDeviceFacingReplyToId(originalReplyToId,deviceId,replyToLegacyEndpointUsed)));
+this.isValid();

[83, 0, 0, 0, 0, 0, 0, 0, 0, 0]
Tested:0 patches
Compile failed:0 patches
Compilation rate:NaN
Finish : hono_client-4 > patch : 0 | Start : Sun Feb 25 15:26:50 CST 2024 | End : 2024.02.25 AD at 15:26:53 CST
